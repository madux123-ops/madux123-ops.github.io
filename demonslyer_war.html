<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¬¼æ»…ä¹‹åˆƒï¼šç„¡é™åŸæ±ºæˆ° RPG (æ–‘ç´‹è¦ºé†’ç‰ˆ)</title>
    <style>
        /* --- å…¨å±€è¨­å®š --- */
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background-color: #050505;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 5px;
            background-image: repeating-linear-gradient(45deg, #110000 0, #110000 2px, transparent 0, transparent 50%);
            background-size: 30px 30px;
            user-select: none;
        }

        h1 { margin: 5px 0; font-size: 1.4em; color: #ff99cc; text-shadow: 0 0 5px #ff0055; }

        /* --- é ‚éƒ¨ç‹€æ…‹åˆ— --- */
        #phase-banner {
            width: 95%; max-width: 800px;
            text-align: center; padding: 5px 0;
            font-size: 1.1em; font-weight: bold; margin-bottom: 5px; border-radius: 5px;
            text-shadow: 1px 1px 0 #000; transition: all 0.5s;
        }
        .phase-player { background: linear-gradient(90deg, #003366, #0056b3, #003366); color: #fff; border: 1px solid #4da6ff; }
        .phase-enemy { background: linear-gradient(90deg, #440000, #8b0000, #440000); color: #ff9999; border: 1px solid #ff4d4d; }

        /* --- éŠæˆ²ä¸»å€åŸŸ --- */
        #game-wrapper {
            display: flex; gap: 10px; align-items: flex-start; justify-content: center;
            position: relative;
        }

        /* --- åœ°åœ– --- */
        #grid-container {
            display: grid;
            gap: 1px;
            background-color: #222;
            border: 3px solid #555;
            box-shadow: 0 0 15px rgba(0,0,0,0.9);
        }

        .tile {
            width: 30px; height: 30px;
            background-color: #2b2b2b;
            position: relative;
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
            font-size: 14px;
        }
        
        .tile.obstacle { 
            background-color: #3a3a3a; 
            cursor: not-allowed; 
            border: 1px solid #555;
            color: #777;
        }
        
        .tile.movable { background-color: rgba(0, 191, 255, 0.25); box-shadow: inset 0 0 4px #00bfff; }
        .tile.attackable { background-color: rgba(255, 69, 0, 0.3); box-shadow: inset 0 0 4px #ff4500; }
        .tile.healable { background-color: rgba(50, 255, 50, 0.25); box-shadow: inset 0 0 4px #00ff00; }
        
        .tile.danger-zone { 
            background-color: rgba(255, 0, 0, 0.6) !important; 
            box-shadow: inset 0 0 10px #ff0000;
            animation: dangerPulse 0.3s infinite alternate;
        }
        .tile.summon-zone {
            background-color: rgba(128, 0, 128, 0.6) !important;
            box-shadow: inset 0 0 10px #800080;
            animation: dangerPulse 0.3s infinite alternate;
        }
        @keyframes dangerPulse { from { opacity: 0.6; } to { opacity: 1; } }

        /* --- å–®ä½æ¨£å¼ --- */
        .unit {
            width: 24px; height: 24px;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 11px;
            z-index: 5; position: absolute;
            top: 3px; left: 3px;
            box-shadow: 1px 1px 2px #000;
            transition: transform 0.2s;
            border-width: 2px; border-style: solid;
        }
        
        /* è§’è‰²é…è‰² */
        .unit.tanjiro { background: radial-gradient(#2e8b57, #000); border-color: #00bfff; }
        .unit.zenitsu { background: radial-gradient(#ffd700, #b8860b); border-color: #fff; color: #000; }
        .unit.inosuke { background: radial-gradient(#708090, #2f4f4f); border-color: #dcdcdc; }
        .unit.nezuko  { background: radial-gradient(#ff99cc, #cc0055); border-color: #ff3366; color: #fff; }
        .unit.giyu    { background: radial-gradient(#3366cc, #001133); border-color: #88ccff; color: #fff; }
        .unit.rengoku { background: radial-gradient(#ffaa00, #aa0000); border-color: #ffff00; color: #fff; }
        .unit.uzui    { background: radial-gradient(#e0e0e0, #888); border-color: #ff00ff; color: #000; }
        .unit.himejima{ background: radial-gradient(#8b4513, #3e2723); border-color: #aaaaaa; color: #fff; }

        .unit.demon { background: radial-gradient(#444, #111); border-color: #f00; color: #bbb; font-size: 10px; }
        .unit.demon-range { background: radial-gradient(#4a2c5a, #200020); border-color: #a0f; color: #eef; }
        .unit.demon-healer { background: radial-gradient(#006400, #003300); border-color: #00ff00; color: #cfc; font-size: 9px; box-shadow: 0 0 4px #0f0; } 
        .unit.demon-clone { background: radial-gradient(#4b0082, #000); border-color: #9400d3; color: #d8bfd8; font-size: 9px; box-shadow: 0 0 4px #9400d3; }
        
        .unit.boss { background: radial-gradient(#a00, #300); border-color: #ff0000; color: #fff; font-size: 13px; box-shadow: 0 0 6px #f00; }
        .unit.boss-awakened { 
            background: radial-gradient(#ff0000, #500); 
            border-color: #fff; 
            box-shadow: 0 0 15px #f00, 0 0 5px #fff; 
            animation: pulseBoss 0.5s infinite alternate;
        }
        @keyframes pulseBoss { from { transform: scale(1); } to { transform: scale(1.15); } }

        .unit.done { filter: grayscale(100%) brightness(0.5); transform: scale(0.9); }
        .unit.selected { box-shadow: 0 0 8px 2px #fff; z-index: 10; transform: scale(1.2); }

        .hp-bar-bg { position: absolute; bottom: -3px; width: 100%; height: 3px; background: #000; border-radius: 2px; }
        .hp-bar-fill { height: 100%; background: #0f0; transition: width 0.3s; }
        .unit.demon .hp-bar-fill, .unit.demon-range .hp-bar-fill { background: #f00; }
        .unit.demon-healer .hp-bar-fill { background: #00ff00; }
        .unit.demon-clone .hp-bar-fill { background: #9370db; }
        .unit.boss-awakened .hp-bar-fill { background: #ff00ff; }
        .lvl-tag { position: absolute; top: -5px; right: -5px; font-size: 8px; background: #000; padding: 0 1px; border-radius: 2px; color: #fff; border: 1px solid #666; transform: scale(0.9); }

        /* --- UI é¢æ¿ --- */
        #ui-panel { width: 220px; display: flex; flex-direction: column; gap: 8px; }
        
        .panel { background: #1a1a1a; padding: 8px; border: 1px solid #444; border-radius: 5px; }
        .panel-header { color: #d4af37; border-bottom: 1px solid #444; margin-bottom: 5px; font-weight: bold; font-size: 0.9em; }

        .btn-group { display: flex; flex-direction: column; gap: 4px; }
        button {
            padding: 8px; cursor: pointer; background: #333; color: #fff; border: 1px solid #555;
            border-radius: 4px; font-size: 0.85em; text-align: left; transition: 0.2s;
        }
        button:hover { background: #444; border-color: #888; }
        button:disabled { opacity: 0.3; cursor: default; }
        .btn-skill { border-left: 3px solid #ff0055; }
        .btn-recover { border-left: 3px solid #00ff00; color: #ccffcc; }
        .btn-cancel { background: #331111; border-color: #552222; text-align: center; font-size: 0.8em; }

        .btn-system { background: #003344; border-color: #005566; color: #aaddff; font-size: 0.8em; text-align: center; }
        .btn-system:hover { background: #004455; }
        
        #skill-list { display: none; flex-direction: column; gap: 3px; margin-top: 5px; }
        .skill-item { font-size: 0.8em; padding: 5px; background: #252525; border-left: 2px solid #666; }
        .skill-heal { border-left-color: #00ff00; color: #ccffcc; } 
        .skill-ult { border-left-color: #ffd700; color: #ffeb3b; font-weight: bold; border-width: 4px; } 
        
        /* çµç®—é¸å–® Modal */
        #modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); z-index: 100;
            display: none; justify-content: center; align-items: center; flex-direction: column;
        }
        .modal-content {
            background: #222; padding: 20px; border: 2px solid #d4af37; border-radius: 10px;
            text-align: center; width: 300px;
        }
        .modal-btn {
            display: block; width: 100%; margin: 10px 0; padding: 15px;
            font-size: 1.1em; font-weight: bold; color: #fff; cursor: pointer; border: none; border-radius: 5px;
        }
        .btn-replay { background: #2e8b57; } .btn-replay:hover { background: #3cb371; }
        .btn-next { background: #1e90ff; } .btn-next:hover { background: #4682b4; }

        #log-box { height: 150px; overflow-y: auto; font-size: 0.8em; color: #bbb; line-height: 1.4; background: #111; padding: 5px; }
        .log-dmg { color: #ff6b6b; font-weight: bold; }
        .log-heal { color: #4cd137; font-weight: bold; }
        .log-sys { color: #ffd700; }
        .log-xp { color: #00bfff; font-style: italic; }
        .log-danger { color: #ff0000; font-weight: bold; background: #330000; padding: 2px; border: 1px solid #f00; }
        .log-summon { color: #d0f; font-weight: bold; border-left: 3px solid #d0f; padding-left: 5px; }
        .log-join { color: #00ffea; font-weight: bold; border-top: 1px solid #00ffea; padding-top:2px; }

        #btn-end-turn { width: 100%; padding: 10px; background: #8b0000; color: #fff; font-weight: bold; border: none; cursor: pointer; margin-top: 5px; font-size: 0.9em; }
    </style>
</head>
<body>

    <div id="phase-banner" class="phase-player">ç¬¬ 1 é—œ - æˆ‘æ–¹å›åˆ</div>

    <div id="game-wrapper">
        <div id="grid-container"></div>

        <div id="modal-overlay">
            <div class="modal-content">
                <h2 style="color: #ffd700; margin-bottom:15px;">ğŸ‰ é—œå¡å®Œæˆï¼</h2>
                <button class="modal-btn btn-replay" onclick="replayLevel()">ğŸ”„ é‡æ–°éŠç©æ­¤é—œ (ç·´åŠŸ)</button>
                <button class="modal-btn btn-next" onclick="nextLevel()">â¡ å‰å¾€ä¸‹ä¸€é—œ</button>
            </div>
        </div>

        <div id="ui-panel">
            <div class="panel">
                <div class="panel-header">å–®ä½è³‡è¨Š</div>
                <div id="unit-info" style="font-size: 0.85em;">è«‹é¸æ“‡å–®ä½...</div>
            </div>

            <div class="panel" id="action-panel" style="display:none;">
                <div class="panel-header">è¡Œå‹•æŒ‡ä»¤</div>
                <div class="btn-group">
                    <button id="btn-attack">âš”ï¸ æ”»æ“Š</button>
                    <button id="btn-skill-menu">ğŸ”¥ æˆ°æŠ€/å¥§ç¾©</button>
                    <div id="skill-list"></div>
                    <button id="btn-recover" class="btn-recover">ğŸ§ª ç™‚å‚· (Recover)</button>
                    <button id="btn-wait">âœ‹ å¾…æ©Ÿ</button>
                    <button id="btn-cancel-move" class="btn-cancel">â†© å–æ¶ˆç§»å‹•</button>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">ç³»çµ±</div>
                <div class="btn-group">
                    <button class="btn-system" id="btn-save-local">ğŸ’¾ å­˜æª”</button>
                    <button class="btn-system" id="btn-load-local">ğŸ“‚ è®€å–</button>
                    <div style="display:flex; gap:2px;">
                        <button class="btn-system" id="btn-save-file" style="flex:1;">â¬‡ ä¸‹è¼‰</button>
                        <button class="btn-system" onclick="document.getElementById('file-input').click()" style="flex:1;">â¬† è®€å–</button>
                    </div>
                    <input type="file" id="file-input" style="display:none" accept=".json">
                    <button class="btn-system" id="btn-reset" style="background:#441111; color:#ffaaaa;">âš  é‡ç½®</button>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">æˆ°é¬¥ç´€éŒ„</div>
                <div id="log-box"></div>
            </div>
            
            <button id="btn-end-turn">çµæŸå›åˆ</button>
        </div>
    </div>

<script>
    // --- éŸ³æ•ˆ ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx = new AudioContext();
    function playSound(type) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        osc.connect(gainNode); gainNode.connect(audioCtx.destination);
        if (type === 'attack') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime+0.1);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.1);
            osc.start(); osc.stop(audioCtx.currentTime+0.1);
        } else if (type === 'damage') {
            osc.type = 'square'; osc.frequency.setValueAtTime(150, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(40, audioCtx.currentTime+0.15);
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime); gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime+0.15);
            osc.start(); osc.stop(audioCtx.currentTime+0.15);
        } else if (type === 'heal') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(400, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(800, audioCtx.currentTime+0.2);
            gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.2);
            osc.start(); osc.stop(audioCtx.currentTime+0.2);
        } else if (type === 'summon') {
            osc.type = 'triangle'; osc.frequency.setValueAtTime(100, audioCtx.currentTime); osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime+0.5);
            gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime); gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime+0.5);
            osc.start(); osc.stop(audioCtx.currentTime+0.5);
        }
    }

    // --- éŠæˆ²å¸¸æ•¸ ---
    const COLS = 24; ROWS = 18; MAX_LEVEL = 25; TILE_SIZE = 30; // ç­‰ç´šä¸Šé™ 25
    
    // --- æŠ€èƒ½è³‡æ–™åº« (åŠ å…¥ Lv12 æ–‘ç´‹è¦ºé†’) ---
    const SKILL_DB = {
        tanjiro: [
            { name: "æ°´ä¹‹å‘¼å¸Â·å£¹ä¹‹å‹", reqLv: 1, range: 1, val: 1.2, cost: 0, aoe: false },
            { name: "ç«ä¹‹ç¥ç¥æ¨‚", reqLv: 3, range: 1, val: 1.6, cost: 0, aoe: false },
            { name: "æ—¥ä¹‹å‘¼å¸Â·é™½è¯çª", reqLv: 6, range: 2, val: 2.2, cost: 0, aoe: true },
            { name: "å¥§ç¾©Â·ç¬¬åä¸‰å‹", reqLv: 9, range: 3, val: 3.5, cost: 0, aoe: false, ult: true },
            { name: "æ–‘ç´‹è¦ºé†’Â·èµ«åˆ€ä¸€é–ƒ", reqLv: 12, range: 4, val: 5.0, cost: 0, aoe: true, ult: true, cd: 6 } 
        ],
        zenitsu: [
            { name: "éœ¹é‚ä¸€é–ƒ", reqLv: 1, range: 3, val: 1.1, cost: 0, aoe: false },
            { name: "éœ¹é‚ä¸€é–ƒÂ·å…­é€£", reqLv: 3, range: 4, val: 1.4, cost: 0, aoe: false },
            { name: "ç¥é€Ÿ", reqLv: 6, range: 5, val: 2.0, cost: 0, aoe: false },
            { name: "å¥§ç¾©Â·ç«é›·ç¥", reqLv: 9, range: 6, val: 3.0, cost: 0, aoe: false, ult: true },
            { name: "æ–‘ç´‹è¦ºé†’Â·ç¥é€ŸÂ·æ¥µ", reqLv: 12, range: 4, val: 5.0, cost: 0, aoe: true, ult: true, cd: 6 }
        ],
        inosuke: [
            { name: "ç¸ä¹‹å‘¼å¸Â·ç ç‰™", reqLv: 1, range: 1, val: 1.0, cost: 0, aoe: true },
            { name: "ç©ºé–“æ„ŸçŸ¥Â·æ®º", reqLv: 3, range: 1, val: 1.5, cost: 0, aoe: true },
            { name: "æŠ•æ“²ç‚¸è£‚", reqLv: 6, range: 3, val: 2.5, cost: 0, aoe: false },
            { name: "å¥§ç¾©Â·éˆé­‚è¡æ’", reqLv: 9, range: 3, val: 3.0, cost: 0, aoe: true, ult: true },
            { name: "æ–‘ç´‹è¦ºé†’Â·ç¸ä¹‹å‘¼å¸Â·çµ‚å¼", reqLv: 12, range: 4, val: 5.0, cost: 0, aoe: true, ult: true, cd: 6 } 
        ],
        nezuko: [
            { name: "å†ç”Ÿå›å¾©", reqLv: 1, range: 2, val: 50, cost: 0, aoe: false, isHeal: true }, 
            { name: "çˆ†è¡€Â·å»£åŸŸæ²»ç™’", reqLv: 3, range: 0, val: 40, cost: 0, aoe: true, isHeal: true, global: true },
            { name: "çˆ†è¡€Â·ç‡’ç¼", reqLv: 6, range: 2, val: 2.5, cost: 0, aoe: false, isHeal: false },
            { name: "å¥§ç¾©Â·å®Œå…¨è¦ºé†’", reqLv: 9, range: 2, val: 3.5, cost: 0, aoe: true, isHeal: false, ult: true },
            { name: "æ–‘ç´‹è¦ºé†’Â·é¬¼åŒ–æš´èµ°", reqLv: 12, range: 4, val: 5.0, cost: 0, aoe: true, isHeal: false, ult: true, cd: 6 }
        ],
        giyu: [
            { name: "å‡ª", reqLv: 1, range: 1, val: 1.5, cost: 0, aoe: false },
            { name: "ç”Ÿç”Ÿæµè½‰", reqLv: 3, range: 2, val: 2.0, cost: 0, aoe: false },
            { name: "æ°´ä¹‹å‘¼å¸Â·æ‹¾å£¹ä¹‹å‹", reqLv: 6, range: 1, val: 2.8, cost: 0, aoe: true },
            { name: "å¥§ç¾©Â·é©šæ¿¤é§­æµª", reqLv: 9, range: 3, val: 3.5, cost: 0, aoe: true, ult: true },
            { name: "æ–‘ç´‹è¦ºé†’Â·éœæ°´æµæ·±", reqLv: 12, range: 4, val: 5.0, cost: 0, aoe: true, ult: true, cd: 6 }
        ],
        rengoku: [
            { name: "ä¸çŸ¥ç«", reqLv: 1, range: 2, val: 1.8, cost: 0, aoe: false },
            { name: "ç››ç‚ä¹‹æ¼©æ¸¦", reqLv: 3, range: 1, val: 2.2, cost: 0, aoe: true },
            { name: "ç‚è™", reqLv: 6, range: 4, val: 3.0, cost: 0, aoe: false },
            { name: "å¥§ç¾©Â·ç…‰ç„", reqLv: 9, range: 3, val: 4.5, cost: 0, aoe: true, ult: true },
            { name: "æ–‘ç´‹è¦ºé†’Â·ç¬¬ä¹å‹Â·ç…‰ç„Â·æ”¹", reqLv: 12, range: 4, val: 5.0, cost: 0, aoe: true, ult: true, cd: 6 } 
        ],
        uzui: [ 
            { name: "é³´å¼¦å¥å¥", reqLv: 1, range: 2, val: 2.0, cost: 0, aoe: true },
            { name: "è½Ÿ", reqLv: 3, range: 1, val: 2.5, cost: 0, aoe: true },
            { name: "è­œé¢å®Œæˆ", reqLv: 6, range: 3, val: 3.2, cost: 0, aoe: false },
            { name: "å¥§ç¾©Â·è¯éº—å¤§çˆ†ç‚¸", reqLv: 9, range: 3, val: 4.0, cost: 0, aoe: true, ult: true },
            { name: "æ–‘ç´‹è¦ºé†’Â·éŸ³ä¹‹å‘¼å¸Â·éŸ¿", reqLv: 12, range: 4, val: 5.0, cost: 0, aoe: true, ult: true, cd: 6 }
        ],
        himejima: [ 
            { name: "è›‡ç´‹å²©Â·é›™æ¥µ", reqLv: 1, range: 2, val: 2.5, cost: 0, aoe: false },
            { name: "å¤©é¢ç¢", reqLv: 3, range: 1, val: 3.0, cost: 0, aoe: true },
            { name: "å²©è»€ä¹‹è†š", reqLv: 6, range: 3, val: 3.5, cost: 0, aoe: false },
            { name: "å¥§ç¾©Â·æµç´‹å²©Â·é€Ÿå¾", reqLv: 9, range: 3, val: 5.0, cost: 0, aoe: true, ult: true },
            { name: "æ–‘ç´‹è¦ºé†’Â·å²©ä¹‹å‘¼å¸Â·ä¸å‹•", reqLv: 12, range: 4, val: 5.0, cost: 0, aoe: true, ult: true, cd: 6 }
        ]
    };

    // --- é¡åˆ¥ ---
    class Unit {
        constructor(id, name, type, role, x, y, stats) {
            this.id = id; this.name = name; this.type = type; this.role = role; this.x = x; this.y = y;
            this.level = stats.level || 1;
            this.maxHp = stats.hp; this.hp = stats.hp; this.atk = stats.atk; this.def = stats.def;
            
            // ç§»å‹•åŠ›é‚è¼¯ (åŸºç¤2, Lv5->3, Lv9->4, Lv12->5, å¤©å…ƒ+1)
            let baseMove = 2;
            if (this.level >= 12) baseMove = 5;
            else if (this.level >= 9) baseMove = 4;
            else if (this.level >= 5) baseMove = 3;
            
            if (this.role === 'uzui') baseMove += 1;
            this.moveRange = baseMove;
            
            this.range = stats.range || 1; 
            this.aoeRange = stats.aoeRange || 0; 
            this.awakened = stats.awakened || false; 
            this.turnCount = stats.turnCount || 0; 
            
            this.hasActed = false; this.xp = stats.xp || 0; this.maxXp = stats.maxXp || (100 * this.level);
            this.prevX = x; this.prevY = y;
            this.cooldowns = {}; 
        }
        getSkills() { if (this.type === 'demon') return []; return SKILL_DB[this.role].filter(s => this.level >= s.reqLv); }
        gainXp(amount) { if (this.type !== 'slayer') return; this.xp += amount; if (this.xp >= this.maxXp) this.levelUp(); }
        levelUp() {
            if (this.level >= MAX_LEVEL) return;
            this.level++; this.xp = 0;
            this.maxXp = Math.floor(this.maxXp * 1.25); this.maxHp = Math.floor(this.maxHp * 1.15);
            this.atk = Math.floor(this.atk * 1.12); this.def = Math.floor(this.def * 1.12);
            this.hp = this.maxHp;
            
            // æ›´æ–°ç§»å‹•åŠ›
            let newMove = 2;
            if (this.level >= 12) newMove = 5; else if (this.level >= 9) newMove = 4; else if (this.level >= 5) newMove = 3;
            if (this.role === 'uzui') newMove += 1;
            this.moveRange = newMove;

            let msg = `âœ¨ ${this.name} å‡ç´š Lv.${this.level}ï¼`;
            if (this.level === 12) msg += " æ–‘ç´‹è¦ºé†’ï¼ç²å¾—æœ€çµ‚å¥§ç¾©ï¼";
            log(msg, 'log-sys'); renderMap();
        }
        tickCooldowns() {
            for (let s in this.cooldowns) {
                if (this.cooldowns[s] > 0) this.cooldowns[s]--;
            }
        }
    }

    // --- å…¨å±€ ---
    let gridElements = [], gridMap = [], allies = [], enemies = [], currentLevel = 1, phase = 'PLAYER';
    let selectedUnit = null, selectionState = 'NONE', activeSkill = null;
    let nextEnemyId = 1000; 

    // --- åˆå§‹åŒ– ---
    function initGame() {
        const container = document.getElementById('grid-container');
        container.style.gridTemplateColumns = `repeat(${COLS}, ${TILE_SIZE}px)`;
        container.style.gridTemplateRows = `repeat(${ROWS}, ${TILE_SIZE}px)`;
        
        document.getElementById('btn-end-turn').onclick = endPlayerPhase;
        document.getElementById('btn-attack').onclick = () => prepAttack(false);
        document.getElementById('btn-skill-menu').onclick = toggleSkillMenu;
        document.getElementById('btn-recover').onclick = executeRecover;
        document.getElementById('btn-wait').onclick = () => finalizeAction(true);
        document.getElementById('btn-cancel-move').onclick = cancelMovement;
        document.getElementById('btn-save-local').onclick = saveGameLocal;
        document.getElementById('btn-load-local').onclick = loadGameLocal;
        document.getElementById('btn-save-file').onclick = saveGameFile;
        document.getElementById('file-input').addEventListener('change', loadGameFile, false);
        document.getElementById('btn-reset').onclick = () => { if(confirm("ç¢ºå®šé‡ç½®ï¼Ÿ")) location.reload(); };

        startNewGame();
    }

    function startNewGame() {
        allies = [
            new Unit(1, 'ç‚­æ²»éƒ', 'slayer', 'tanjiro', 0, 0, { hp: 120, atk: 33, def: 15 }),
            new Unit(2, 'å–„é€¸', 'slayer', 'zenitsu', 0, 0, { hp: 90, atk: 35, def: 6 }),
            new Unit(3, 'ä¼Šä¹‹åŠ©', 'slayer', 'inosuke', 0, 0, { hp: 130, atk: 25, def: 17 }),
            new Unit(4, 'ç¦°è±†å­', 'slayer', 'nezuko', 0, 0, { hp: 140, atk: 20, def: 15 })
        ];
        startLevel(1);
    }

    // --- åœ°åœ–èˆ‡é—œå¡ ---
    function createMap() {
        const container = document.getElementById('grid-container'); container.innerHTML = '';
        gridElements = []; gridMap = [];
        for (let y = 0; y < ROWS; y++) {
            let rowEl = []; let rowMap = [];
            for (let x = 0; x < COLS; x++) {
                let div = document.createElement('div'); div.className = 'tile'; div.onclick = () => onTileClick(x, y);
                let isObstacle = false; 
                if (x > 3 && x < COLS - 3) { if (Math.random() < 0.15) { isObstacle = true; div.classList.add('obstacle'); div.innerText = 'ğŸª¨'; } }
                container.appendChild(div); rowEl.push(div); rowMap.push(isObstacle ? 1 : 0);
            }
            gridElements.push(rowEl); gridMap.push(rowMap);
        }
    }

    function startLevel(lvl) {
        currentLevel = lvl;
        document.getElementById('phase-banner').innerText = `ç¬¬ ${lvl} é—œ - ç„¡é™åŸæ·±è™•`;
        log(`=== ç¬¬ ${lvl} é—œ é–‹å§‹ ===`, 'log-sys');
        createMap();

        if (lvl === 3 && !allies.find(u => u.role === 'giyu')) {
            allies.push(new Unit(5, 'å¯Œå²¡ç¾©å‹‡', 'slayer', 'giyu', 0, 0, { hp: 220, atk: 50, def: 25, level: 3 }));
            log("ğŸŒŠ æ°´æŸ±ãƒ»å¯Œå²¡ç¾©å‹‡ (å¼·åŒ–ç‹€æ…‹) åŠ å…¥æˆ°å ´ï¼", 'log-join');
        }
        if (lvl === 5 && !allies.find(u => u.role === 'rengoku')) {
            allies.push(new Unit(6, 'ç…‰ç„æå£½éƒ', 'slayer', 'rengoku', 0, 0, { hp: 240, atk: 65, def: 20, level: 5 }));
            log("ğŸ”¥ ç‚æŸ±ãƒ»ç…‰ç„æå£½éƒ åŠ å…¥æˆ°å ´ï¼", 'log-join');
        }
        if (lvl === 7 && !allies.find(u => u.role === 'uzui')) {
            // å®‡éš¨å¼·åŒ– (HP 260->290, ATK 58->64, DEF 22->26)
            allies.push(new Unit(7, 'å®‡éš¨å¤©å…ƒ', 'slayer', 'uzui', 0, 0, { hp: 290, atk: 64, def: 26, level: 7 }));
            log("ğŸµ éŸ³æŸ±ãƒ»å®‡éš¨å¤©å…ƒ è¯éº—ç™»å ´ï¼", 'log-join');
        }
        if (lvl === 9 && !allies.find(u => u.role === 'himejima')) {
            allies.push(new Unit(8, 'æ‚²é³´å¶¼è¡Œå†¥', 'slayer', 'himejima', 0, 0, { hp: 420, atk: 85, def: 40, level: 9 }));
            log("ğŸ“¿ å²©æŸ±ãƒ»æ‚²é³´å¶¼è¡Œå†¥ åƒæˆ°ï¼", 'log-join');
        }

        allies.forEach((u, i) => {
            u.x = 1; u.y = 4 + i;
            if (u.y >= ROWS) { u.x = 2; u.y = u.y - ROWS + 4; } 
            u.hasActed = false; u.prevX = u.x; u.prevY = u.y;
            u.cooldowns = {};
        });

        enemies = [];
        let difficulty = 1 + (lvl * 0.25);
        let gruntCount = 10 + Math.floor(lvl * 1.5); 
        let currentId = 100;

        for(let i=0; i<gruntCount; i++) {
            let ex = 5 + Math.floor(Math.random() * (COLS - 5)); let ey = Math.floor(Math.random() * ROWS);
            if (gridMap[ey][ex] === 1 || isOccupied(ex, ey)) continue; 
            let typeRand = Math.random();
            let role = 'demon'; let name = 'é›œé­šé¬¼'; let range = 1;
            if (typeRand < 0.1) { role = 'demon-clone'; name = 'åˆ†èº«é¬¼'; range = 1; } 
            else if (typeRand < 0.4) { role = 'demon-range'; name = 'èœ˜è››é¬¼'; range = 3; }
            enemies.push(new Unit(currentId++, name, role, 'grunt', ex, ey, {
                hp: Math.floor(40 * difficulty), atk: Math.floor(12 * difficulty), def: Math.floor(2 * difficulty), level: lvl, range: range
            }));
        }

        let healerCount = 3 + Math.floor(Math.random() * 4); 
        for(let i=0; i<healerCount; i++) {
            let ex = 8 + Math.floor(Math.random() * (COLS - 8)); let ey = Math.floor(Math.random() * ROWS);
            if (gridMap[ey][ex] === 1 || isOccupied(ex, ey)) continue;
            enemies.push(new Unit(currentId++, "å†ç”Ÿé¬¼", "demon-healer", 'grunt', ex, ey, {
                hp: Math.floor(60 * difficulty), atk: Math.floor(20 * difficulty), def: Math.floor(5 * difficulty), level: lvl, range: 6 
            }));
        }
        
        const doubleBossLevels = [2, 4, 6, 8, 9];
        let bosses = [getBossName(lvl, 1)];
        if (doubleBossLevels.includes(lvl)) bosses.push(getBossName(lvl, 2));

        bosses.forEach((bName, idx) => {
            let bx = COLS - 3 - idx; let by = Math.floor(ROWS / 2) + (idx===0?-2:2);
            while (gridMap[by][bx] === 1) bx--; 
            enemies.push(new Unit(200+idx, bName, 'demon', 'boss', bx, by, {
                hp: Math.floor(200 * difficulty * 3), atk: Math.floor(35 * difficulty), def: Math.floor(10 * difficulty), 
                level: lvl+2, range: 3, move: 3, aoeRange: (lvl>=7?3:2)
            }));
        });

        startPlayerPhase();
    }

    // --- è¼”åŠ©å‡½æ•¸ ---
    function isOccupied(x, y) { return [...allies, ...enemies].some(u => u.x === x && u.y === y && u.hp > 0); }
    function getUnitAt(x, y) { return [...allies, ...enemies].find(u => u.x === x && u.y === y && u.hp > 0); }
    function isWalkable(x, y) { return x >= 0 && x < COLS && y >= 0 && y < ROWS && gridMap[y][x] === 0; }
    
    // --- éŠæˆ²æµç¨‹ ---
    function startPlayerPhase() {
        phase = 'PLAYER'; document.getElementById('phase-banner').className = 'phase-player'; document.getElementById('btn-end-turn').disabled = false;
        document.getElementById('phase-banner').innerText = `ç¬¬ ${currentLevel} é—œ - æˆ‘æ–¹å›åˆ`;
        allies.forEach(u => { 
            u.hasActed = false; u.prevX = u.x; u.prevY = u.y; 
            u.tickCooldowns();
        });
        resetSelection(); renderMap();
    }
    function endPlayerPhase() { if (phase !== 'PLAYER') return; resetSelection(); startEnemyPhase(); }

    async function startEnemyPhase() {
        phase = 'ENEMY'; document.getElementById('phase-banner').innerText = "æ•µæ–¹è¡Œå‹•ä¸­..."; document.getElementById('phase-banner').className = 'phase-enemy'; document.getElementById('btn-end-turn').disabled = true;
        renderMap();
        for (const demon of enemies) {
            if (demon.hp > 0) {
                await new Promise(r => setTimeout(r, 30)); 
                await runEnemyAI(demon); 
                renderMap();
            }
        }
        if (checkWinLose()) return;
        startPlayerPhase();
    }

    // --- æ¨™æº– UI/æ“ä½œå‡½æ•¸ ---
    function getMovableTiles(unit) {
        let moves = [], range = unit.moveRange, queue = [{x: unit.x, y: unit.y, steps: 0}], visited = new Set([`${unit.x},${unit.y}`]);
        while(queue.length > 0) {
            let curr = queue.shift();
            if (curr.steps > 0) moves.push({x: curr.x, y: curr.y}); 
            if (curr.steps < range) {
                [[0,1], [0,-1], [1,0], [-1,0]].forEach(([dx, dy]) => {
                    let nx = curr.x + dx, ny = curr.y + dy;
                    if (isWalkable(nx, ny) && !isOccupied(nx, ny) && !visited.has(`${nx},${ny}`)) { visited.add(`${nx},${ny}`); queue.push({x: nx, y: ny, steps: curr.steps + 1}); }
                });
            }
        }
        return moves;
    }
    function onTileClick(x, y) {
        if (phase !== 'PLAYER') return;
        const targetUnit = getUnitAt(x, y);
        if (selectionState === 'NONE') { if (targetUnit && targetUnit.type === 'slayer' && !targetUnit.hasActed) selectUnit(targetUnit); else if (targetUnit) showUnitInfo(targetUnit); return; }
        if (selectionState === 'MOVING') {
            if (gridElements[y][x].classList.contains('movable')) executeMove(selectedUnit, x, y);
            else if (x === selectedUnit.x && y === selectedUnit.y) executeMove(selectedUnit, x, y);
            else { resetSelection(); if (targetUnit && targetUnit.type === 'slayer' && !targetUnit.hasActed) selectUnit(targetUnit); } return;
        }
        if (selectionState === 'TARGETING') {
            if (gridElements[y][x].classList.contains('attackable') || gridElements[y][x].classList.contains('healable')) {
                const hitUnit = getUnitAt(x, y);
                if (activeSkill && activeSkill.global) executeSkillAction(selectedUnit, null, activeSkill);
                else if (hitUnit) executeSkillAction(selectedUnit, hitUnit, activeSkill);
                else if (activeSkill && activeSkill.aoe) executeSkillAction(selectedUnit, {x:x, y:y, name:"åœ°é¢"}, activeSkill);
            } else openActionMenu();
        }
    }
    function selectUnit(unit) { selectedUnit = unit; selectionState = 'MOVING'; showUnitInfo(unit); renderMap(); getMovableTiles(unit).forEach(pos => gridElements[pos.y][pos.x].classList.add('movable')); }
    function executeMove(unit, x, y) { unit.x = x; unit.y = y; renderMap(); openActionMenu(); }
    function cancelMovement() { if (!selectedUnit) return; unit = selectedUnit; unit.x = unit.prevX; unit.y = unit.prevY; resetSelection(); renderMap(); }
    function openActionMenu() { selectionState = 'MENU'; document.getElementById('action-panel').style.display = 'block'; document.getElementById('skill-list').style.display = 'none'; }
    
    function toggleSkillMenu() {
        const list = document.getElementById('skill-list'); list.style.display = (list.style.display === 'flex') ? 'none' : 'flex'; list.innerHTML = '';
        selectedUnit.getSkills().forEach(skill => {
            let btn = document.createElement('button'); btn.className = 'skill-item'; 
            if(skill.isHeal) btn.classList.add('skill-heal'); 
            if(skill.ult) btn.classList.add('skill-ult');
            
            let rangeTxt = skill.global ? "å…¨é«”" : `è·${skill.range}`; if(skill.aoe && !skill.global) rangeTxt += "/ç¯„åœ";
            
            // CD æª¢æŸ¥
            let cd = selectedUnit.cooldowns[skill.name] || 0;
            if (cd > 0) {
                btn.innerHTML = `${skill.name} (CD:${cd})`;
                btn.disabled = true;
                btn.style.opacity = 0.5;
            } else {
                btn.innerHTML = `${skill.name} <small>(${rangeTxt})</small>`;
                btn.onclick = () => { activeSkill = skill; prepAttack(true); }; 
            }
            list.appendChild(btn);
        });
    }

    function prepAttack(isSkill) {
        if (!isSkill) activeSkill = null; selectionState = 'TARGETING'; document.getElementById('action-panel').style.display = 'none'; renderMap();
        const range = isSkill ? activeSkill.range : 1; const isHeal = isSkill && activeSkill.isHeal; const isGlobal = isSkill && activeSkill.global;
        if (isGlobal) { allies.forEach(a => { if(a.hp > 0) gridElements[a.y][a.x].classList.add('healable'); }); log("é¸æ“‡å…¨é«”...", 'log-sys'); return; }
        for(let y=0; y<ROWS; y++) { for(let x=0; x<COLS; x++) {
            const dist = Math.abs(x - selectedUnit.x) + Math.abs(y - selectedUnit.y);
            if (dist <= range && (dist > 0 || isHeal)) {
                const unitHere = getUnitAt(x, y);
                if (isHeal) { if (unitHere && unitHere.type === 'slayer') gridElements[y][x].classList.add('healable'); } else gridElements[y][x].classList.add('attackable');
            }
        }}
    }

    function executeRecover() {
        if (!selectedUnit) return;
        let healAmt = Math.floor(selectedUnit.maxHp * 0.3); // 30%
        selectedUnit.hp = Math.min(selectedUnit.maxHp, selectedUnit.hp + healAmt);
        log(`${selectedUnit.name} é€²è¡Œç™‚å‚·ï¼Œå›å¾© ${healAmt} HP`, 'log-heal');
        playSound('heal');
        finalizeAction(true);
    }

    function executeSkillAction(attacker, targetObj, skill) {
        let targets = []; const isHeal = skill && skill.isHeal; let totalXp = 0;
        
        // è¨­å®š CD (å¢åŠ 1å›åˆ)
        if (skill) {
            let cdTurns = 0;
            if (skill.cd) cdTurns = skill.cd; // ç‰¹æ®ŠæŒ‡å®šCD (å¦‚Lv12æ‹›å¼)
            else if (skill.ult) cdTurns = 3; // å¥§ç¾© 3
            else cdTurns = 2; // æ™®é€šæˆ°æŠ€ 2
            
            if (attacker.role === 'nezuko' && skill.isHeal) cdTurns = 0; // ç¦°è±†å­è£œè¡€ 0
            
            if (cdTurns > 0) attacker.cooldowns[skill.name] = cdTurns;
        }

        if (skill && skill.global && isHeal) targets = allies.filter(a => a.hp > 0);
        else if (skill && skill.aoe && !isHeal) {
            let cx = targetObj.x; let cy = targetObj.y;
            for(let dy=-1; dy<=1; dy++){ for(let dx=-1; dx<=1; dx++){ let u = getUnitAt(cx+dx, cy+dy); if (u && u.type === 'demon') targets.push(u); } }
        } else { if (targetObj) targets.push(targetObj); }
        if (targets.length > 0) playSound(isHeal ? 'heal' : 'attack');
        targets.forEach(t => {
            let val = 0;
            if (isHeal) { val = Math.floor(skill.val + attacker.atk * 0.5); t.hp = Math.min(t.maxHp, t.hp + val); log(`${t.name} +${val}`, 'log-heal'); totalXp += 15; }
            else {
                let mult = skill ? skill.val : 1.0; 
                val = Math.max(1, Math.floor(attacker.atk * mult - (t.def * 0.5)));
                t.hp -= val; log(`${t.name} -${val}`, 'log-dmg'); totalXp += 10;
                if (t.hp <= 0) { playSound('damage'); if (t.role === 'boss' && !t.awakened && Math.random() < 0.4) { t.awakened = true; t.maxHp *= 2; t.hp = t.maxHp; t.atk *= 2; t.name = "è¦ºé†’Â·" + t.name; log(`âš ï¸è¦ºé†’ï¼`, 'log-danger'); } else { t.hp = 0; log(`æ“Šæ®º ${t.name}`, 'log-sys'); totalXp += 50; } }
            }
        });
        if (totalXp > 0) attacker.gainXp(totalXp); finalizeAction(false);
    }
    function finalizeAction(isWait) { if (selectedUnit) { selectedUnit.hasActed = true; if(isWait) log("å¾…æ©Ÿ", 'log-sys'); } resetSelection(); renderMap(); }
    function resetSelection() { selectedUnit = null; selectionState = 'NONE'; activeSkill = null; document.getElementById('action-panel').style.display = 'none'; document.querySelectorAll('.tile').forEach(t => {t.classList.remove('movable', 'attackable', 'healable', 'danger-zone');}); }
    function renderMap() {
        document.querySelectorAll('.unit').forEach(e => e.remove());
        [...enemies, ...allies].forEach(u => {
            if (u.hp <= 0) return;
            let div = document.createElement('div'); div.className = `unit ${u.role}`;
            if (u.awakened) div.classList.add('boss-awakened');
            if (u.hasActed && u.type === 'slayer') div.classList.add('done');
            if (u === selectedUnit) div.classList.add('selected');
            div.innerText = u.name[0];
            let hpBg = document.createElement('div'); hpBg.className = 'hp-bar-bg';
            let hpFill = document.createElement('div'); hpFill.className = 'hp-bar-fill';
            hpFill.style.width = (u.hp / u.maxHp * 100) + '%'; hpBg.appendChild(hpFill); div.appendChild(hpBg);
            let lvl = document.createElement('div'); lvl.className = 'lvl-tag'; lvl.innerText = u.level; div.appendChild(lvl);
            gridElements[u.y][u.x].appendChild(div);
        });
    }
    function showUnitInfo(u) {
        let skills = u.getSkills ? u.getSkills().map(s=>s.name).join(', ') : "ç„¡";
        let html = `<strong style="color:${u.type==='slayer'?'#4da6ff':'#ff4d4d'}">${u.name} (Lv.${u.level})</strong><br>HP: ${u.hp}/${u.maxHp} | ATK: ${u.atk} | DEF: ${u.def}<br>MOVE: ${u.moveRange} | RANGE: ${u.range}<br>${u.type==='slayer' ? `EXP: ${u.xp}/${u.maxXp}` : ''}`;
        document.getElementById('unit-info').innerHTML = html;
    }
    function log(msg, type) { const box = document.getElementById('log-box'); box.innerHTML += `<div class="${type}">${msg}</div>`; box.scrollTop = box.scrollHeight; }
    
    function checkWinLose() { 
        if (allies.every(u => u.hp <= 0)) { alert("å…¨è»è¦†æ²’..."); location.reload(); return true; } 
        if (enemies.every(u => u.hp <= 0)) { 
            document.getElementById('modal-overlay').style.display = 'flex'; // é¡¯ç¤ºé¸å–®
            return true; 
        } 
        return false; 
    }
    
    // é—œå¡é‡ç©èˆ‡ä¸‹ä¸€é—œ
    function replayLevel() {
        document.getElementById('modal-overlay').style.display = 'none';
        // å…¨å“¡è£œè¡€
        allies.forEach(u => { u.hp = u.maxHp; u.cooldowns = {}; });
        startLevel(currentLevel);
    }
    function nextLevel() {
        document.getElementById('modal-overlay').style.display = 'none';
        if (currentLevel >= MAX_LEVEL) { alert("æ­å–œé€šé—œï¼ç„¡é™åŸå´©å¡Œï¼"); location.reload(); return; }
        // å…¨å“¡è£œè¡€
        allies.forEach(u => { u.hp = u.maxHp; u.cooldowns = {}; });
        startLevel(currentLevel + 1);
    }

    function getBossName(l, index) { const bossMap = { 1: ["ä¸‹å¼¦ä¹‹é™¸"], 2: ["ä¸‹å¼¦ä¹‹ä¼", "ä¸‹å¼¦ä¹‹å£¹"], 3: ["å¢®å§¬"], 4: ["å¢®å§¬", "å¦“å¤«å¤ªéƒ"], 5: ["ç‰å£º"], 6: ["åŠå¤©ç‹—", "æ†ç€å¤©"], 7: ["çŒ—çª©åº§"], 8: ["ç«¥ç£¨", "çŒ—çª©åº§"], 9: ["é»‘æ­»ç‰Ÿ", "é¬¼èˆè¾»ç„¡æ…˜"] }; const list = bossMap[l] || ["ç„¡æ…˜"]; return list[index - 1] || list[0]; }
    
    // å­˜æª”åŠŸèƒ½ä¿ç•™
    function getGameState() { return { level: currentLevel, allies: allies, enemies: enemies, gridMap: gridMap }; }
    function restoreGameState(data) { 
        currentLevel = data.level; gridMap = data.gridMap;
        const container = document.getElementById('grid-container'); container.innerHTML = ''; gridElements = [];
        for (let y = 0; y < ROWS; y++) {
            let rowEl = []; for (let x = 0; x < COLS; x++) {
                let div = document.createElement('div'); div.className = 'tile'; div.onclick = () => onTileClick(x, y);
                if (gridMap[y][x] === 1) { div.classList.add('obstacle'); div.innerText = 'ğŸª¨'; }
                container.appendChild(div); rowEl.push(div);
            }
            gridElements.push(rowEl);
        }
        allies = data.allies.map(d => { let u = new Unit(d.id, d.name, d.type, d.role, d.x, d.y, {}); Object.assign(u, d); return u; });
        enemies = data.enemies.map(d => { let u = new Unit(d.id, d.name, d.type, d.role, d.x, d.y, {}); Object.assign(u, d); return u; });
        startPlayerPhase(); log("ğŸ“‚ éŠæˆ²è®€å–æˆåŠŸï¼", 'log-sys');
    }
    function saveGameLocal() { localStorage.setItem('demonSlayerSave_v3', JSON.stringify(getGameState())); alert("å·²ä¿å­˜"); }
    function loadGameLocal() { const data = localStorage.getItem('demonSlayerSave_v3'); if(data && confirm("è®€å–?")) restoreGameState(JSON.parse(data)); }
    function saveGameFile() { const a = document.createElement('a'); a.href = URL.createObjectURL(new Blob([JSON.stringify(getGameState(), null, 2)], {type: "application/json"})); a.download = `demon_slayer_lv${currentLevel}.json`; a.click(); }
    function loadGameFile(e) { const reader = new FileReader(); reader.onload = (e) => restoreGameState(JSON.parse(e.target.result)); if(e.target.files[0]) reader.readAsText(e.target.files[0]); }

    // AI Part
    async function runEnemyAI(demon) {
        demon.turnCount++; 
        // 1. å¬å–š
        if (demon.role === 'boss') {
            let summonNow = false; let summonType = 'grunt'; let spawnCount = 3;
            if (demon.name.includes("ç„¡æ…˜")) {
                if (demon.turnCount % 6 === 0) { summonNow = true; summonType = 'boss'; spawnCount = 1; }
                else if (demon.turnCount % 3 === 0) { summonNow = true; summonType = 'grunt'; spawnCount = 3; }
            } else { if (demon.turnCount % 3 === 0) { summonNow = true; summonType = 'grunt'; spawnCount = 3; } }

            if (summonNow) {
                log(`ğŸŸ£ ${demon.name} æ­£åœ¨å¬å–š...`, 'log-summon');
                for(let dy=-1; dy<=1; dy++) { for(let dx=-1; dx<=1; dx++) { let sx = demon.x+dx, sy = demon.y+dy; if(isWalkable(sx, sy)) gridElements[sy][sx].classList.add('summon-zone'); } }
                await new Promise(r => setTimeout(r, 400));
                document.querySelectorAll('.summon-zone').forEach(el => el.classList.remove('summon-zone'));
                playSound('summon');
                let placed = 0; let difficulty = 1 + (currentLevel * 0.25);
                for (let r = 1; r <= 3; r++) { 
                    for (let dy = -r; dy <= r; dy++) { for (let dx = -r; dx <= r; dx++) {
                        if (placed >= spawnCount) break;
                        let sx = demon.x + dx, sy = demon.y + dy;
                        if (isWalkable(sx, sy) && !isOccupied(sx, sy)) {
                            if (summonType === 'boss') {
                                let randBoss = getBossName(Math.floor(Math.random()*8)+1, 1);
                                enemies.push(new Unit(nextEnemyId++, randBoss, 'demon', 'boss', sx, sy, {
                                    hp: Math.floor(150 * difficulty), atk: Math.floor(30 * difficulty), def: Math.floor(8 * difficulty), 
                                    level: currentLevel+2, range: 3, move: 3, aoeRange: 2
                                }));
                                log(`ğŸ˜± å¬å–šäº† ${randBoss}ï¼`, 'log-danger');
                            } else {
                                enemies.push(new Unit(nextEnemyId++, "å¬å–šé¬¼", 'demon', 'grunt', sx, sy, {
                                    hp: Math.floor(30 * difficulty), atk: Math.floor(10 * difficulty), def: 2, level: currentLevel, range: 1
                                }));
                            }
                            placed++;
                        }
                    }}
                }
            }
        }
        // 2. åˆ†èº«
        if (demon.role === 'demon-clone' && demon.turnCount % 3 === 0) {
            log(`ğŸŸ£ åˆ†èº«é¬¼æ­£åœ¨åˆ†è£‚ï¼`, 'log-summon');
            let spawned = false;
            for (let dy = -1; dy <= 1; dy++) { for (let dx = -1; dx <= 1; dx++) {
                let sx = demon.x + dx, sy = demon.y + dy;
                if (isWalkable(sx, sy) && !isOccupied(sx, sy)) {
                    enemies.push(new Unit(nextEnemyId++, "åˆ†èº«é¬¼", "demon-clone", 'grunt', sx, sy, {
                        hp: demon.maxHp, atk: demon.atk, def: demon.def, level: demon.level, range: 1
                    })); spawned = true; break;
                }
            } if(spawned) break; }
        }
        // 3. è£œè¡€
        if (demon.role === 'demon-healer') {
            let healTarget = enemies.find(e => e.hp > 0 && e.hp < e.maxHp && (Math.abs(e.x-demon.x)+Math.abs(e.y-demon.y) <= demon.range));
            if (healTarget) {
                let healAmt = Math.floor(demon.atk * 1.5); healTarget.hp = Math.min(healTarget.maxHp, healTarget.hp + healAmt);
                log(`${demon.name} æ²»ç™‚ ${healTarget.name} +${healAmt}`, 'log-heal'); return;
            }
        }
        // 4. æ”»æ“Šç§»å‹•
        let target = null, minDist = 999;
        allies.forEach(a => { if (a.hp > 0) { let d = Math.abs(a.x - demon.x) + Math.abs(a.y - demon.y); if (d < minDist) { minDist = d; target = a; } } });
        if (!target) return;
        let dist = Math.abs(target.x - demon.x) + Math.abs(target.y - demon.y);
        if (dist > demon.range) {
            let moves = demon.moveRange; 
            for (let i=0; i<moves; i++) {
                let dx = Math.sign(target.x - demon.x), dy = Math.sign(target.y - demon.y);
                let tx = demon.x + dx, ty = demon.y;
                if (!isWalkable(tx, ty) || isOccupied(tx, ty)) { tx = demon.x; ty = demon.y + dy; } 
                if (isWalkable(tx, ty) && !isOccupied(tx, ty)) { demon.x = tx; demon.y = ty; }
                if (Math.abs(target.x - demon.x) + Math.abs(target.y - demon.y) <= demon.range) break;
            }
            dist = Math.abs(target.x - demon.x) + Math.abs(target.y - demon.y);
        }
        if (dist <= demon.range) {
            let dmg = Math.max(1, Math.floor(demon.atk - (target.def * 0.5)));
            if (demon.role === 'boss' && demon.aoeRange > 0) {
                log(`âš ï¸ ${demon.name} é–å®šæ”»æ“Šç¯„åœ...`, 'log-danger');
                allies.forEach(a => { if (a.hp > 0 && Math.abs(a.x - target.x) + Math.abs(a.y - target.y) <= demon.aoeRange) gridElements[a.y][a.x].classList.add('danger-zone'); });
                await new Promise(r => setTimeout(r, 400));
                document.querySelectorAll('.danger-zone').forEach(el => el.classList.remove('danger-zone'));
                playSound('attack');
                allies.forEach(a => {
                    if (a.hp > 0 && Math.abs(a.x - target.x) + Math.abs(a.y - target.y) <= demon.aoeRange) {
                        let aoeDmg = Math.max(1, Math.floor(demon.atk - (a.def * 0.5)));
                        a.hp -= aoeDmg; log(`${a.name} å—æ ${aoeDmg}`, 'log-dmg'); if (a.hp <= 0) playSound('damage');
                    }
                });
            } else {
                playSound('attack');
                target.hp -= dmg; log(`${demon.name} æ”»æ“Š ${target.name} ${dmg}`, 'log-dmg'); if (target.hp <= 0) playSound('damage');
            }
        }
    }

    initGame();
</script>
</body>
</html>
