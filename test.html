<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯¶å¯å¤¢å°æˆ° V2.1 (æ¨™æº–ä½ˆå±€)</title>
    <style>
        :root {
            --bg-color: #222;
            --field-monster: #2d4a3e; /* æ€ªç¸å€æ·±ç¶  */
            --field-st: #3a2a4a;      /* é­”é™·å€æ·±ç´« */
            --card-bg: #e0e0e0;
            --p1-color: #3b82f6;      /* è—æ–¹ */
            --p2-color: #ef4444;      /* ç´…æ–¹ */
            --text-color: #fff;
            --card-width: 80px;
            --card-height: 115px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- éŠæˆ²ä¸»ç›¤é¢ --- */
        .game-board {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* --- ç©å®¶å€åŸŸå®¹å™¨ --- */
        .player-zone {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 5px 10px;
            position: relative;
            justify-content: space-between; /* è®“æ‰‹ç‰Œè²¼é‚Šï¼Œå ´åœ°è²¼ä¸­ */
        }

        /* P2 (æ•µæ–¹) - ä¸ŠåŠéƒ¨ */
        .p2-zone {
            background: linear-gradient(to bottom, #1a1a1a, #2a1a1a);
            border-bottom: 2px solid #555; /* ä¸­ç·š */
        }
        
        /* P1 (æˆ‘æ–¹) - ä¸‹åŠéƒ¨ */
        .p1-zone {
            background: linear-gradient(to top, #1a1a1a, #1a2a3a);
        }

        .active-turn { box-shadow: inset 0 0 20px rgba(255, 255, 255, 0.1); }

        /* --- å¡ç‰‡è¡Œ (Row) --- */
        .field-container {
            display: flex;
            flex-direction: column;
            gap: 2px;
            justify-content: center;
        }

        .field-row {
            display: flex;
            justify-content: center;
            gap: 8px;
            height: var(--card-height);
            align-items: center;
            border-radius: 6px;
            padding: 2px;
            width: 100%;
        }

        .monster-zone { background-color: rgba(45, 74, 62, 0.6); border: 1px solid #3d5a4e; }
        .st-zone { background-color: rgba(58, 42, 74, 0.6); border: 1px solid #4a3a5a; height: 90px; } /* é­”é™·å€ç¨çŸ® */

        .hand-row {
            display: flex;
            justify-content: center;
            gap: -5px;
            height: 110px;
            align-items: center;
            z-index: 20;
            padding: 5px;
        }

        /* --- å¡ç‰‡æœ¬é«” --- */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: var(--card-bg);
            border-radius: 5px;
            border: 2px solid #666;
            color: #000;
            display: flex;
            flex-direction: column;
            font-size: 9px;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        /* æ‰‹ç‰Œæ¨£å¼ */
        .hand-row .card { 
            width: 70px; 
            height: 100px; 
            margin: 0 2px;
            border-color: #fff;
        }
        
        /* P1 æ‰‹ç‰Œäº’å‹• (ä¸‹æ–¹) */
        #p1-hand .card:hover { transform: translateY(-20px) scale(1.1); z-index: 50; }
        
        /* P2 æ‰‹ç‰Œäº’å‹• (ä¸Šæ–¹) - è¦–è¦ºä¸Šç¨å¾®ç¸®å°ä¸€é»è¡¨ç¤ºé è™• */
        #p2-hand .card { transform: scale(0.95); }
        #p2-hand .card:hover { transform: translateY(10px) scale(1.05); z-index: 50; }

        /* é¸ä¸­èˆ‡ç‰¹æ•ˆ */
        .card.selected { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; transform: scale(1.05); z-index: 40; }
        .card.tribute-target { border-color: #ff0000; box-shadow: 0 0 15px #ff0000; animation: pulse 1s infinite; }
        
        .card-header { background: #d4af37; padding: 2px; font-weight: bold; text-align: center; border-bottom: 1px solid #000; white-space: nowrap; overflow: hidden; }
        .card-level { text-align: center; background: #eee; color: #000; font-size: 10px; line-height: 10px;}
        .card-img { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 30px; background: #fff; position: relative; }
        .card-stats { background: #f0f0f0; padding: 2px; display: flex; justify-content: space-between; border-top: 1px solid #000; font-weight: bold; font-size: 10px; }

        /* å¡ç¨®é¡é¡è‰² */
        .card[data-cat="monster"] { border-color: #b8860b; }
        .card[data-cat="spell"] { border-color: #107c10; } 
        .card[data-cat="spell"] .card-header { background: #107c10; color: white;}
        .card[data-cat="trap"] { border-color: #c71585; }
        .card[data-cat="trap"] .card-header { background: #c71585; color: white;}

        .card.facedown { background: #4a3b2a; border-color: #5d4037; }
        .card.facedown > * { visibility: hidden; }
        .card.facedown::after { 
            content: ''; 
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: repeating-linear-gradient(45deg, #4a3b2a, #4a3b2a 10px, #3e3020 10px, #3e3020 20px);
            visibility: visible;
        }

        /* --- VFX --- */
        .slash-effect { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 99; display: none; }
        .slashing .slash-effect { display: block; animation: slashAnim 0.4s ease-out; background: linear-gradient(135deg, transparent 45%, red 50%, transparent 55%); background-size: 200% 200%; }
        @keyframes slashAnim { 0% { background-position: 200% 200%; opacity: 0; } 50% { opacity: 1; } 100% { background-position: -100% -100%; opacity: 0; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* --- UI é¢æ¿ --- */
        .info-panel { 
            position: absolute; top: 50%; left: 0; transform: translateY(-50%); 
            background: rgba(0,0,0,0.85); padding: 15px 10px; 
            border-radius: 0 10px 10px 0; z-index: 100; border-left: 5px solid #ffd700;
        }
        .lp-display { font-family: 'Courier New', monospace; font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        .p1-lp { color: var(--p1-color); text-shadow: 0 0 5px var(--p1-color); }
        .p2-lp { color: var(--p2-color); text-shadow: 0 0 5px var(--p2-color); }
        
        .phase-box { text-align: center; margin-top: 10px; padding: 5px; border: 1px solid #666; color: #aaa; font-size: 12px; }
        .phase-box.active { color: #ffd700; border-color: #ffd700; font-weight: bold; }

        .controls { 
            position: absolute; top: 50%; right: 0; transform: translateY(-50%); 
            display: flex; flex-direction: column; gap: 8px; z-index: 100; padding-right: 10px;
        }
        button { 
            padding: 10px; font-size: 13px; cursor: pointer; background: #333; color: white; 
            border: 1px solid #666; border-radius: 4px; width: 90px; transition: 0.2s;
        }
        button:hover { background: #555; border-color: #888; }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-battle { background: #8b0000; border-color: #ff4444; }
        .btn-end { background: #1e3a8a; border-color: #3b82f6; }

        .log-box { 
            position: absolute; bottom: 0; left: 0; width: 100%; height: 30px; 
            background: rgba(0,0,0,0.9); border-top: 1px solid #444; 
            color: #ddd; font-size: 12px; line-height: 30px; padding-left: 10px; 
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis; z-index: 150;
        }

        #winner-overlay { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.95); display: none; flex-direction: column; 
            align-items: center; justify-content: center; z-index: 999; 
        }
        #winner-text { font-size: 50px; color: #ffd700; margin-bottom: 20px; font-weight: bold;}
    </style>
</head>
<body>

    <div class="info-panel">
        <div class="lp-display p2-lp">P2: <span id="p2-lp">8000</span></div>
        <div class="lp-display p1-lp">P1: <span id="p1-lp">8000</span></div>
        
        <div id="phase-draw" class="phase-box">æŠ½ç‰Œ</div>
        <div id="phase-main1" class="phase-box">ä¸»è¦ 1</div>
        <div id="phase-battle" class="phase-box">æˆ°é¬¥</div>
        <div id="phase-main2" class="phase-box">ä¸»è¦ 2</div>
        <div style="font-size: 12px; text-align: center; margin-top:8px; color: #888;">å›åˆ: <span id="current-player">P1</span></div>
    </div>

    <div class="controls">
        <button id="btn-battle" class="btn-battle" onclick="game.enterBattlePhase()">âš”ï¸ æˆ°é¬¥éšæ®µ</button>
        <button id="btn-main2" onclick="game.enterMainPhase2()" disabled>ä¸»è¦éšæ®µ 2</button>
        <button id="btn-end" class="btn-end" onclick="game.endTurn()">çµæŸå›åˆ â</button>
    </div>

    <div class="game-board">
        <div class="player-zone p2-zone" id="p2-zone">
            <div class="hand-row" id="p2-hand"></div>
            
            <div class="field-container">
                <div class="field-row st-zone" id="p2-st"></div>
                <div class="field-row monster-zone" id="p2-field"></div>
            </div>
        </div>

        <div class="player-zone p1-zone" id="p1-zone">
            <div class="field-container">
                <div class="field-row monster-zone" id="p1-field"></div>
                <div class="field-row st-zone" id="p1-st"></div>
            </div>

            <div class="hand-row" id="p1-hand"></div>
        </div>
    </div>

    <div class="log-box" id="game-log">éŠæˆ²é–‹å§‹ï¼æº–å‚™æ±ºé¬¥ï¼</div>

    <div id="winner-overlay">
        <div id="winner-text">P1 ç²å‹!</div>
        <button onclick="location.reload()" style="font-size: 20px; padding: 10px 30px;">é‡æ–°é–‹å§‹</button>
    </div>

    <script>
        // --- ç°¡æ˜“è³‡æ–™åº« ---
        const CARD_DB = [
            // ä¸‹ç´šæ€ªç¸
            { id: 1, name: "å°ç«é¾", category: 'monster', level: 3, atk: 1200, def: 800, img: "ğŸ”¥" },
            { id: 2, name: "å‚‘å°¼é¾œ", category: 'monster', level: 3, atk: 1000, def: 1500, img: "ğŸ’§" },
            { id: 3, name: "å¦™è›™ç¨®å­", category: 'monster', level: 3, atk: 1100, def: 1100, img: "ğŸŒ¿" },
            { id: 4, name: "çš®å¡ä¸˜", category: 'monster', level: 4, atk: 1600, def: 800, img: "âš¡" },
            { id: 5, name: "ä¼Šå¸ƒ", category: 'monster', level: 3, atk: 1300, def: 1000, img: "ğŸ•" },
            { id: 6, name: "å°æ‹³çŸ³", category: 'monster', level: 3, atk: 1100, def: 1800, img: "ğŸª¨" },
            { id: 7, name: "é¬¼æ–¯", category: 'monster', level: 2, atk: 1000, def: 200, img: "ğŸ‘»" },
            { id: 8, name: "è…•åŠ›", category: 'monster', level: 4, atk: 1700, def: 600, img: "ğŸ’ª" },
            // ä¸Šç´šæ€ªç¸ (1ç¥­å“)
            { id: 20, name: "ç«æé¾", category: 'monster', level: 5, atk: 2000, def: 1400, img: "ğŸ”¥ğŸ”¥" },
            { id: 21, name: "é›·ä¸˜", category: 'monster', level: 6, atk: 2400, def: 1800, img: "âš¡âš¡" },
            { id: 22, name: "è€¿é¬¼", category: 'monster', level: 6, atk: 2300, def: 1500, img: "ğŸ˜ˆ" },
            { id: 23, name: "å¡æ¯”ç¸", category: 'monster', level: 6, atk: 2500, def: 2000, img: "ğŸ’¤" },
            // å‚³èªªæ€ªç¸ (2ç¥­å“)
            { id: 40, name: "å™´ç«é¾", category: 'monster', level: 7, atk: 2800, def: 2200, img: "ğŸ²" },
            { id: 41, name: "æ°´ç®­é¾œ", category: 'monster', level: 7, atk: 2600, def: 2800, img: "ğŸ¢" },
            { id: 42, name: "è¶…å¤¢", category: 'monster', level: 8, atk: 3200, def: 2000, img: "ğŸ‘½" },
            { id: 43, name: "çƒˆç©ºå", category: 'monster', level: 8, atk: 3500, def: 2800, img: "ğŸŸ¢" },
            // é­”æ³•
            { id: 100, name: "å‚·è—¥", category: 'spell', effect: 'heal_1000', img: "ğŸ’Š", desc: "HP+1000" },
            { id: 101, name: "æ”»æ“Šå¼·åŒ–", category: 'spell', effect: 'atk_up_500', img: "âš”ï¸", desc: "å…¨é«”ATK+500" },
            { id: 102, name: "é»‘æ´", category: 'spell', effect: 'destroy_all', img: "âš«", desc: "ç ´å£æ‰€æœ‰æ€ªç¸" }, // ç°¡åŒ–ç‰ˆ
            // é™·é˜±
            { id: 200, name: "éµå£", category: 'trap', effect: 'def_up', img: "ğŸ›¡ï¸", desc: "DEF+1500" },
            { id: 201, name: "ç¥è–é˜²è­·", category: 'trap', effect: 'destroy_atk', img: "âœ¨", desc: "ç ´å£æ”»æ“Šè€…" }
        ];

        class Card {
            constructor(data, owner) {
                this.uid = Math.random().toString(36).substr(2, 9);
                Object.assign(this, data);
                this.owner = owner;
                this.hasAttacked = false;
                this.isFacedown = false;
                this.tempAtkBuff = 0;
            }

            get currentAtk() { return (this.atk || 0) + this.tempAtkBuff; }

            render(location) {
                const el = document.createElement('div');
                el.className = `card`;
                el.dataset.uid = this.uid;
                el.dataset.cat = this.category;
                
                if (this.hasAttacked) el.classList.add('attacked');
                if (this.isFacedown && location !== 'hand') el.classList.add('facedown');

                let stars = '';
                if(this.category === 'monster') for(let i=0; i<this.level; i++) stars += 'â˜…';

                // å…§å®¹æ¸²æŸ“
                el.innerHTML = `
                    <div class="slash-effect"></div>
                    <div class="card-header">${this.name}</div>
                    ${this.category === 'monster' ? `<div class="card-level">${stars}</div>` : ''}
                    <div class="card-img">${this.img}</div>
                    <div class="card-stats">
                        ${this.category === 'monster' 
                            ? `<span>${this.currentAtk}</span><span>${this.def}</span>` 
                            : `<span style="text-align:center;width:100%;font-size:8px">${this.desc}</span>`}
                    </div>
                `;
                
                el.onclick = () => game.handleCardClick(this, location);
                return el;
            }
        }

        class Game {
            constructor() {
                this.turn = 'p1';
                this.phase = 'draw';
                this.players = {
                    p1: { lp: 8000, hand: [], field: [], st: [], deck: [] },
                    p2: { lp: 8000, hand: [], field: [], st: [], deck: [] }
                };
                this.selectedCard = null;
                this.summonState = { active: false, card: null, need: 0, tributes: [] };
                this.turnSummoned = false;
                
                this.initDeck('p1'); this.initDeck('p2');
                for(let i=0; i<5; i++) { this.draw('p1'); this.draw('p2'); }
                this.startTurn();
            }

            log(msg) {
                document.getElementById('game-log').innerText = `[${this.turn.toUpperCase()}] ${msg}`;
            }

            initDeck(p) {
                for(let i=0; i<25; i++) {
                    const r = Math.random();
                    let cardData;
                    if(r < 0.6) cardData = CARD_DB.filter(c=>c.category==='monster' && c.level<=4)[Math.floor(Math.random()*8)];
                    else if (r < 0.8) cardData = CARD_DB[Math.floor(Math.random()*CARD_DB.length)];
                    else cardData = CARD_DB.filter(c=>c.category!=='monster')[Math.floor(Math.random()*5)];
                    this.players[p].deck.push(cardData || CARD_DB[0]);
                }
            }

            draw(p) {
                if(this.players[p].deck.length === 0) { this.endGame(p==='p1'?'P2':'P1', "ç‰Œçµ„æŠ½ä¹¾"); return; }
                this.players[p].hand.push(new Card(this.players[p].deck.pop(), p));
                this.updateUI();
            }

            startTurn() {
                this.phase = 'draw';
                this.turnSummoned = false;
                this.selectedCard = null;
                this.summonState = { active: false, tributes: [] };
                ['p1','p2'].forEach(p => this.players[p].field.forEach(c => { c.hasAttacked=false; c.tempAtkBuff=0; }));
                
                this.updateUI();
                setTimeout(() => {
                    this.draw(this.turn);
                    this.phase = 'main1';
                    this.log("ä¸»è¦éšæ®µ 1");
                    this.updateUI();
                }, 800);
            }

            handleCardClick(card, loc) {
                // ç»ç¥­é¸æ“‡é‚è¼¯
                if (this.summonState.active && loc === 'field' && card.owner === this.turn) {
                    if(!this.summonState.tributes.find(c=>c.uid===card.uid)) {
                        this.summonState.tributes.push(card);
                        if(this.summonState.tributes.length === this.summonState.need) {
                            this.summonState.tributes.forEach(t => this.removeCard(t));
                            this.deployCard(this.summonState.card);
                            this.summonState = { active: false, tributes: [] };
                        }
                        this.updateUI();
                    }
                    return;
                }

                // å‡ºç‰Œé‚è¼¯
                if (loc === 'hand' && card.owner === this.turn && (this.phase === 'main1' || this.phase === 'main2')) {
                    if (card.category === 'monster') {
                        if (this.turnSummoned) { this.log("æœ¬å›åˆå·²å¬å–šé"); return; }
                        if (this.players[this.turn].field.length >= 5) { this.log("å ´åœ°å·²æ»¿"); return; }
                        
                        let need = (card.level >= 7) ? 2 : (card.level >= 5) ? 1 : 0;
                        if (need > 0) {
                            if (this.players[this.turn].field.length < need) { this.log("ç¥­å“ä¸è¶³"); return; }
                            this.summonState = { active: true, card: card, need: need, tributes: [] };
                            this.log(`è«‹é¸æ“‡ ${need} éš»ç¥­å“`);
                            this.updateUI();
                        } else {
                            this.deployCard(card);
                        }
                    } 
                    else if (card.category === 'spell') this.activateSpell(card);
                    else if (card.category === 'trap') this.setCard(card);
                }
                
                // æˆ°é¬¥é‚è¼¯
                if (this.phase === 'battle') {
                    if (loc === 'field') {
                        if (card.owner === this.turn && !card.hasAttacked) {
                            this.selectedCard = card;
                            this.log(`é¸æ“‡äº† ${card.name}ï¼Œè«‹é¸æ“‡æ”»æ“Šç›®æ¨™`);
                            this.updateUI();
                        } else if (card.owner !== this.turn && this.selectedCard) {
                            this.combat(this.selectedCard, card);
                        }
                    }
                }
            }

            deployCard(card) {
                const p = this.players[this.turn];
                p.hand = p.hand.filter(c => c.uid !== card.uid);
                p.field.push(card);
                this.turnSummoned = true;
                this.log(`å¬å–š ${card.name}`);
                this.updateUI();
            }

            setCard(card) {
                const p = this.players[this.turn];
                if(p.st.length >= 5) return;
                p.hand = p.hand.filter(c => c.uid !== card.uid);
                card.isFacedown = true;
                p.st.push(card);
                this.log("è¦†è“‹ä¸€å¼µå¡");
                this.updateUI();
            }

            activateSpell(card) {
                this.players[this.turn].hand = this.players[this.turn].hand.filter(c => c.uid !== card.uid);
                this.log(`é­”æ³•ç™¼å‹•: ${card.name}`);
                if(card.effect === 'heal_1000') this.damage(this.turn, -1000);
                if(card.effect === 'atk_up_500') this.players[this.turn].field.forEach(c=>c.tempAtkBuff+=500);
                if(card.effect === 'destroy_all') { // ç°¡å–®ç‰ˆé»‘æ´: ç ´å£å°æ–¹ä¸€éš»
                   const opp = this.turn==='p1'?'p2':'p1';
                   if(this.players[opp].field.length > 0) this.removeCard(this.players[opp].field[0]);
                }
                this.updateUI();
            }

            async combat(attacker, target) {
                attacker.hasAttacked = true;
                this.selectedCard = null;

                // é™·é˜±æª¢æ¸¬
                const opp = target.owner;
                const traps = this.players[opp].st.filter(c => c.category === 'trap' && c.isFacedown);
                if (traps.length > 0) {
                    const trap = traps[0];
                    trap.isFacedown = false;
                    this.log(`é™·é˜±ç™¼å‹•: ${trap.name}`);
                    await new Promise(r => setTimeout(r, 800));
                    this.removeCard(trap, 'st');
                    
                    if (trap.effect === 'destroy_atk') {
                        this.removeCard(attacker);
                        this.log("æ”»æ“Šæ€ªç¸è¢«ç ´å£ï¼");
                        this.updateUI();
                        return;
                    }
                    if (trap.effect === 'def_up') target.def += 1500;
                }

                // è¦–è¦ºç‰¹æ•ˆ
                const el = document.querySelector(`.card[data-uid="${target.uid}"]`);
                if(el) { el.classList.add('slashing'); await new Promise(r=>setTimeout(r,400)); el.classList.remove('slashing');}

                // å‚·å®³è¨ˆç®—
                if (attacker.currentAtk > target.def) {
                    const dmg = attacker.currentAtk - target.def;
                    this.damage(opp, dmg);
                    this.removeCard(target);
                    this.log(`æ“Šç ´ï¼çµ¦äºˆ ${dmg} å‚·å®³`);
                } else if (attacker.currentAtk < target.def) {
                    const dmg = target.def - attacker.currentAtk;
                    this.damage(attacker.owner, dmg);
                    this.log(`ç„¡æ³•æ“Šç©¿é˜²ç¦¦ï¼Œå—åˆ° ${dmg} åå‚·`);
                } else {
                    this.log("å¹³æ‰‹");
                }
                this.updateUI();
                this.checkWin();
            }

            directAttack() {
                if (this.phase !== 'battle' || !this.selectedCard) return;
                const opp = this.turn === 'p1' ? 'p2' : 'p1';
                if (this.players[opp].field.length === 0) {
                    const dmg = this.selectedCard.currentAtk;
                    this.selectedCard.hasAttacked = true;
                    this.damage(opp, dmg);
                    this.selectedCard = null;
                    this.log(`ç›´æ¥æ”»æ“Šï¼å‚·å®³ ${dmg}`);
                    this.updateUI();
                    this.checkWin();
                }
            }

            removeCard(card, zone='field') {
                const p = this.players[card.owner];
                if(zone === 'field') p.field = p.field.filter(c => c.uid !== card.uid);
                else p.st = p.st.filter(c => c.uid !== card.uid);
            }

            damage(p, amt) {
                this.players[p].lp = Math.max(0, this.players[p].lp - amt);
            }

            checkWin() {
                if (this.players.p1.lp <= 0) this.endGame('P2');
                else if (this.players.p2.lp <= 0) this.endGame('P1');
            }

            endGame(winner, reason='') {
                document.getElementById('winner-overlay').style.display = 'flex';
                document.getElementById('winner-text').innerHTML = `${winner} ç²å‹<br><small>${reason}</small>`;
            }

            enterBattlePhase() { if(this.phase==='main1') { this.phase='battle'; this.log("é€²å…¥æˆ°é¬¥éšæ®µ"); this.updateUI(); } }
            enterMainPhase2() { if(this.phase==='battle') { this.phase='main2'; this.log("é€²å…¥ä¸»è¦éšæ®µ 2"); this.updateUI(); } }
            endTurn() { this.turn = this.turn==='p1'?'p2':'p1'; this.startTurn(); }

            updateUI() {
                document.getElementById('p1-lp').innerText = this.players.p1.lp;
                document.getElementById('p2-lp').innerText = this.players.p2.lp;
                document.getElementById('current-player').innerText = this.turn.toUpperCase();

                // éšæ®µé«˜äº®
                document.querySelectorAll('.phase-box').forEach(el => el.classList.remove('active'));
                if(this.phase.includes('main')) document.getElementById('phase-main1').classList.add('active'); // ç°¡åŒ–é¡¯ç¤º
                else if(document.getElementById(`phase-${this.phase}`)) document.getElementById(`phase-${this.phase}`).classList.add('active');

                // æŒ‰éˆ•ç‹€æ…‹
                document.getElementById('btn-battle').disabled = (this.phase !== 'main1');
                document.getElementById('btn-main2').disabled = (this.phase !== 'battle');

                // å€åŸŸé«˜äº®
                document.getElementById('p1-zone').className = `player-zone p1-zone ${this.turn==='p1'?'active-turn':''}`;
                document.getElementById('p2-zone').className = `player-zone p2-zone ${this.turn==='p2'?'active-turn':''}`;

                const render = (id, list, loc) => {
                    const div = document.getElementById(id);
                    div.innerHTML = '';
                    list.forEach(c => {
                        const el = c.render(loc);
                        if(this.selectedCard?.uid === c.uid) el.classList.add('selected');
                        if(this.summonState.active && loc==='field' && c.owner===this.turn) {
                            if(this.summonState.tributes.find(t=>t.uid===c.uid)) el.classList.add('tribute-target');
                            else { el.style.borderColor='#0f0'; el.style.boxShadow='0 0 5px #0f0'; }
                        }
                        div.appendChild(el);
                    });
                };

                render('p1-hand', this.players.p1.hand, 'hand');
                render('p1-field', this.players.p1.field, 'field');
                render('p1-st', this.players.p1.st, 'st');
                render('p2-hand', this.players.p2.hand, 'hand');
                render('p2-field', this.players.p2.field, 'field');
                render('p2-st', this.players.p2.st, 'st');
            }
        }

        const game = new Game();
        
        // é»æ“ŠèƒŒæ™¯ç›´æ¥æ”»æ“Š
        document.getElementById('p2-zone').onclick = (e) => {
            if((e.target.id==='p2-zone'||e.target.classList.contains('field-row')) && game.turn==='p1') game.directAttack();
        };
        document.getElementById('p1-zone').onclick = (e) => {
            if((e.target.id==='p1-zone'||e.target.classList.contains('field-row')) && game.turn==='p2') game.directAttack();
        };
    </script>
</body>
</html>
