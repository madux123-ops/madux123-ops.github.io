<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é¬¼æ»…ä¹‹åˆƒï¼šç„¡é™åŸæ±ºæˆ° RPG (è‡ªç”±å›åˆç‰ˆ)</title>
    <style>
        /* --- å…¨å±€èˆ‡èƒŒæ™¯ --- */
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background-color: #050505;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            /* æ¦»æ¦»ç±³é¢¨æ ¼æš—ç´‹ */
            background-image: repeating-linear-gradient(45deg, #1a1a1a 0, #1a1a1a 1px, transparent 0, transparent 50%);
            background-size: 20px 20px;
        }

        h1 { margin: 5px 0; color: #ffcc00; text-shadow: 0 0 5px #ff4d4d; }

        /* --- é ‚éƒ¨ç‹€æ…‹åˆ— --- */
        #phase-banner {
            width: 100%;
            text-align: center;
            padding: 10px 0;
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 10px;
            background: linear-gradient(90deg, transparent, #00bfff, transparent);
            text-shadow: 2px 2px 0 #000;
            transition: all 0.5s;
        }
        .phase-player { background: linear-gradient(90deg, transparent, #0056b3, transparent) !important; color: #fff; }
        .phase-enemy { background: linear-gradient(90deg, transparent, #8b0000, transparent) !important; color: #ff9999; }

        /* --- éŠæˆ²å®¹å™¨ --- */
        #game-wrapper {
            display: flex;
            gap: 20px;
            align-items: flex-start;
            justify-content: center;
        }

        /* --- åœ°åœ–å€åŸŸ --- */
        #grid-container {
            display: grid;
            grid-template-columns: repeat(10, 50px);
            grid-template-rows: repeat(10, 50px);
            gap: 1px;
            background-color: #333;
            border: 4px solid #666;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            user-select: none;
        }

        .tile {
            width: 50px; height: 50px;
            background-color: #2b2b2b;
            position: relative;
            cursor: pointer;
            display: flex; justify-content: center; align-items: center;
        }
        
        .tile.movable { background-color: rgba(0, 191, 255, 0.3); box-shadow: inset 0 0 10px #00bfff; animation: pulse 1.5s infinite; }
        .tile.attackable { background-color: rgba(255, 69, 0, 0.4); box-shadow: inset 0 0 10px #ff4500; }
        
        @keyframes pulse { 0% {opacity: 0.6;} 50% {opacity: 1;} 100% {opacity: 0.6;} }

        /* --- å–®ä½æ¨£å¼ --- */
        .unit {
            width: 42px; height: 42px;
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 18px;
            z-index: 5; position: relative;
            box-shadow: 2px 2px 5px #000;
            transition: transform 0.2s;
        }
        
        .unit.tanjiro { background: radial-gradient(#2e8b57, #111); border: 2px solid #00bfff; }
        .unit.zenitsu { background: radial-gradient(#ffd700, #b8860b); border: 2px solid #fff; color: #000; }
        .unit.inosuke { background: radial-gradient(#708090, #2f4f4f); border: 2px solid #dcdcdc; }
        .unit.demon { background: radial-gradient(#555, #222); border: 2px solid #f00; color: #ccc; font-size: 14px; }
        .unit.boss { background: radial-gradient(#a00, #300); border: 2px solid #f00; color: #fff; font-size: 20px; box-shadow: 0 0 10px #f00; }

        .unit.done { filter: grayscale(100%) brightness(0.6); transform: scale(0.9); }
        .unit.selected { box-shadow: 0 0 15px 5px #fff; z-index: 10; transform: scale(1.15); }

        /* è¡€æ¢èˆ‡ç­‰ç´š */
        .hp-bar-bg { position: absolute; bottom: -5px; width: 100%; height: 5px; background: #000; }
        .hp-bar-fill { height: 100%; background: #0f0; transition: width 0.3s; }
        .unit.demon .hp-bar-fill { background: #f00; }
        .lvl-tag { position: absolute; top: -5px; right: -8px; font-size: 10px; background: #000; padding: 1px 3px; border-radius: 3px; }

        /* --- UI é¢æ¿ --- */
        #ui-panel { width: 280px; display: flex; flex-direction: column; gap: 10px; }
        
        .panel { background: #1f1f1f; padding: 10px; border: 1px solid #444; border-radius: 5px; }
        .panel-header { color: #d4af37; border-bottom: 1px solid #444; margin-bottom: 8px; font-weight: bold; }

        /* æŒ‰éˆ•ç¾¤çµ„ */
        .btn-group { display: flex; flex-direction: column; gap: 5px; }
        button {
            padding: 10px; cursor: pointer; background: #333; color: #fff; border: 1px solid #555;
            border-radius: 4px; font-size: 1em; text-align: left; transition: 0.2s;
        }
        button:hover { background: #444; border-color: #888; }
        button:disabled { opacity: 0.3; cursor: default; }
        .btn-skill { border-left: 4px solid #00bfff; }
        .btn-cancel { background: #331111; border-color: #552222; text-align: center; }

        /* æŠ€èƒ½å­é¸å–® */
        #skill-list { display: none; flex-direction: column; gap: 5px; margin-top: 5px; }
        .skill-item { font-size: 0.9em; padding: 8px; background: #253545; }

        /* æˆ°é¬¥ç´€éŒ„ */
        #log-box { height: 150px; overflow-y: auto; font-size: 0.85em; color: #bbb; line-height: 1.4; }
        .log-turn { color: #aaa; font-style: italic; border-top: 1px solid #333; margin-top: 5px; padding-top: 2px; }
        .log-dmg { color: #ff6b6b; font-weight: bold; }
        .log-heal { color: #4cd137; font-weight: bold; }
        
        /* çµæŸå›åˆæŒ‰éˆ• */
        #btn-end-turn {
            width: 100%; padding: 15px; background: #8b0000; color: #fff; font-weight: bold; 
            border: none; cursor: pointer; margin-top: 10px; font-size: 1.1em;
        }
        #btn-end-turn:hover { background: #a00000; }
        #btn-end-turn:disabled { background: #333; color: #555; }

    </style>
</head>
<body>

    <div id="phase-banner" class="phase-player">æˆ‘æ–¹å›åˆ (Player Phase)</div>

    <div id="game-wrapper">
        <div id="grid-container"></div>

        <div id="ui-panel">
            <div class="panel">
                <div class="panel-header">å–®ä½è³‡è¨Š</div>
                <div id="unit-info">è«‹é¸æ“‡å–®ä½...</div>
            </div>

            <div class="panel" id="action-panel" style="display:none;">
                <div class="panel-header">è¡Œå‹•æŒ‡ä»¤</div>
                <div class="btn-group">
                    <button id="btn-attack">âš”ï¸ æ”»æ“Š</button>
                    <button id="btn-skill-menu">âš¡ æˆ°æŠ€</button>
                    <div id="skill-list">
                        </div>
                    <button id="btn-wait">âœ‹ å¾…æ©Ÿ</button>
                    <button id="btn-cancel-move" class="btn-cancel">â†© å–æ¶ˆç§»å‹•</button>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">æˆ°é¬¥ç´€éŒ„</div>
                <div id="log-box"></div>
            </div>
            
            <button id="btn-end-turn">çµæŸå›åˆ (End Turn)</button>
        </div>
    </div>

<script>
    // --- éŠæˆ²å¸¸æ•¸ ---
    const GRID_SIZE = 10;
    const MAX_LEVEL = 9;
    
    // --- æŠ€èƒ½è³‡æ–™åº« ---
    const SKILL_DB = {
        tanjiro: [
            { name: "æ°´ä¹‹å‘¼å¸Â·å£¹ä¹‹å‹", reqLv: 1, range: 1, dmg: 1.2, cost: 0, aoe: false },
            { name: "ç«ä¹‹ç¥ç¥æ¨‚", reqLv: 3, range: 1, dmg: 1.6, cost: 0, aoe: false },
            { name: "æ—¥ä¹‹å‘¼å¸Â·é™½è¯çª", reqLv: 6, range: 2, dmg: 2.2, cost: 0, aoe: false }
        ],
        zenitsu: [
            { name: "éœ¹é‚ä¸€é–ƒ", reqLv: 1, range: 3, dmg: 1.1, cost: 0, aoe: false },
            { name: "éœ¹é‚ä¸€é–ƒÂ·å…­é€£", reqLv: 3, range: 4, dmg: 1.4, cost: 0, aoe: false },
            { name: "éœ¹é‚ä¸€é–ƒÂ·ç¥é€Ÿ", reqLv: 6, range: 5, dmg: 2.0, cost: 0, aoe: false }
        ],
        inosuke: [
            { name: "ç¸ä¹‹å‘¼å¸Â·ç ç‰™", reqLv: 1, range: 1, dmg: 1.0, cost: 0, aoe: true }, // ç¯„åœ
            { name: "ç©ºé–“æ„ŸçŸ¥Â·æ®º", reqLv: 3, range: 1, dmg: 1.5, cost: 0, aoe: true },
            { name: "çˆ†è£‚çŒ›é€²", reqLv: 6, range: 1, dmg: 2.5, cost: 0, aoe: true } // å¼·åŠ›ç¯„åœ
        ]
    };

    // --- é¡åˆ¥å®šç¾© ---
    class Unit {
        constructor(id, name, type, role, x, y, stats) {
            this.id = id;
            this.name = name;
            this.type = type; // 'slayer' or 'demon'
            this.role = role;
            this.x = x;
            this.y = y;
            
            // åŸºç¤æ•¸å€¼
            this.level = stats.level || 1;
            this.maxHp = stats.hp;
            this.hp = stats.hp;
            this.atk = stats.atk;
            this.def = stats.def;
            this.moveRange = 2; // å›ºå®š 2 æ ¼
            
            // ç‹€æ…‹
            this.hasActed = false;
            
            // æˆé•·èˆ‡å¿«ç…§ (ç”¨æ–¼å–æ¶ˆç§»å‹•)
            this.xp = 0;
            this.maxXp = 100 * this.level;
            this.prevX = x; // ç´€éŒ„ç§»å‹•å‰ä½ç½®
            this.prevY = y;
        }

        getSkills() {
            if (this.type === 'demon') return [];
            return SKILL_DB[this.role].filter(s => this.level >= s.reqLv);
        }

        gainXp(amount) {
            if (this.type !== 'slayer') return;
            this.xp += amount;
            log(`${this.name} ç²å¾— ${amount} EXP`, 'normal');
            if (this.xp >= this.maxXp) this.levelUp();
        }

        levelUp() {
            this.level++;
            this.xp = 0;
            this.maxXp = Math.floor(this.maxXp * 1.2);
            this.maxHp = Math.floor(this.maxHp * 1.2);
            this.atk = Math.floor(this.atk * 1.15);
            this.def = Math.floor(this.def * 1.15);
            this.hp = this.maxHp; // å›æ»¿è¡€
            
            let newSkill = SKILL_DB[this.role].find(s => s.reqLv === this.level);
            let skillMsg = newSkill ? `<br>ğŸ’¡ ç¿’å¾—æ–°æ‹›å¼ï¼š${newSkill.name}ï¼` : "";
            
            log(`âœ¨ ${this.name} å‡ç´šåˆ° Lv.${this.level}ï¼é«”åŠ›å…¨æ»¿ï¼${skillMsg}`, 'heal');
            renderMap();
        }
    }

    // --- å…¨å±€è®Šæ•¸ ---
    let grid = [];
    let allies = [];
    let enemies = [];
    let currentLevel = 1;
    let phase = 'PLAYER'; // 'PLAYER' or 'ENEMY'
    
    // äº’å‹•ç‹€æ…‹æ©Ÿ
    let selectedUnit = null; // ç•¶å‰é¸ä¸­çš„æˆ‘æ–¹å–®ä½
    let selectionState = 'NONE'; // 'NONE', 'MOVING', 'MENU', 'TARGETING'
    let activeSkill = null; // ç•¶å‰é¸æ“‡ä½¿ç”¨çš„æŠ€èƒ½

    // --- åˆå§‹åŒ– ---
    function initGame() {
        createGrid();
        // å»ºç«‹ä¸»è§’ç¾¤ (æ°¸ä¹…èƒ½åŠ›)
        allies = [
            new Unit(1, 'ç‚­æ²»éƒ', 'slayer', 'tanjiro', 1, 4, { hp: 100, atk: 25, def: 8 }),
            new Unit(2, 'å–„é€¸', 'slayer', 'zenitsu', 0, 3, { hp: 80, atk: 30, def: 5 }),
            new Unit(3, 'ä¼Šä¹‹åŠ©', 'slayer', 'inosuke', 0, 5, { hp: 110, atk: 22, def: 10 })
        ];
        startLevel(1);
        
        // ç¶å®šçµæŸå›åˆæŒ‰éˆ•
        document.getElementById('btn-end-turn').onclick = endPlayerPhase;
        // ç¶å®šæŒ‡ä»¤æŒ‰éˆ•
        document.getElementById('btn-attack').onclick = () => prepAttack(false);
        document.getElementById('btn-skill-menu').onclick = toggleSkillMenu;
        document.getElementById('btn-wait').onclick = () => finalizeAction(true); // å¾…æ©Ÿ
        document.getElementById('btn-cancel-move').onclick = cancelMovement;
    }

    function createGrid() {
        const container = document.getElementById('grid-container');
        container.innerHTML = '';
        for (let y = 0; y < GRID_SIZE; y++) {
            let row = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                let div = document.createElement('div');
                div.className = 'tile';
                div.onclick = () => onTileClick(x, y);
                container.appendChild(div);
                row.push(div);
            }
            grid.push(row);
        }
    }

    function startLevel(lvl) {
        currentLevel = lvl;
        document.getElementById('phase-banner').innerText = `ç¬¬ ${lvl} é—œ - é–‹å§‹`;
        log(`=== ç¬¬ ${lvl} é—œ é–‹å§‹ ===`, 'normal');
        
        // é‡ç½®ä½ç½®
        allies[0].x=1; allies[0].y=4;
        allies[1].x=0; allies[1].y=3;
        allies[2].x=0; allies[2].y=5;
        allies.forEach(u => { u.hasActed = false; u.prevX = u.x; u.prevY = u.y; });

        // ç”Ÿæˆæ•µäºº
        enemies = [];
        let difficulty = 1 + (lvl * 0.15);
        let count = 3 + Math.floor(Math.random()*3); // 3-5éš»
        
        for(let i=0; i<count; i++) {
            let ex = 6 + Math.floor(Math.random()*4);
            let ey = Math.floor(Math.random()*10);
            if(!isOccupied(ex, ey)) {
                enemies.push(new Unit(100+i, 'é›œé­šé¬¼', 'demon', 'grunt', ex, ey, {
                    hp: Math.floor(40*difficulty), atk: Math.floor(12*difficulty), def: Math.floor(2*difficulty), level: lvl
                }));
            }
        }
        // Boss
        let by = 4;
        if(isOccupied(9, 4)) by = 5;
        enemies.push(new Unit(200, getBossName(lvl), 'demon', 'boss', 9, by, {
            hp: Math.floor(150*difficulty), atk: Math.floor(25*difficulty), def: Math.floor(8*difficulty), level: lvl+2
        }));

        startPlayerPhase();
    }

    function isOccupied(x, y) {
        return [...allies, ...enemies].some(u => u.x === x && u.y === y && u.hp > 0);
    }
    
    function getUnitAt(x, y) {
        return [...allies, ...enemies].find(u => u.x === x && u.y === y && u.hp > 0);
    }

    // --- æ ¸å¿ƒæµç¨‹æ§åˆ¶ ---

    function startPlayerPhase() {
        phase = 'PLAYER';
        const banner = document.getElementById('phase-banner');
        banner.className = 'phase-player';
        banner.innerText = "æˆ‘æ–¹å›åˆ (Player Phase)";
        document.getElementById('btn-end-turn').disabled = false;
        
        // é‡ç½®æ‰€æœ‰æˆ‘æ–¹ç‹€æ…‹
        allies.forEach(u => {
            u.hasActed = false;
            u.prevX = u.x; // æ›´æ–°å›åˆèµ·å§‹é»
            u.prevY = u.y;
        });
        
        resetSelection();
        renderMap();
    }

    function endPlayerPhase() {
        if (phase !== 'PLAYER') return;
        resetSelection();
        startEnemyPhase();
    }

    async function startEnemyPhase() {
        phase = 'ENEMY';
        const banner = document.getElementById('phase-banner');
        banner.className = 'phase-enemy';
        banner.innerText = "æ•µæ–¹è¡Œå‹•ä¸­ (Enemy Phase)";
        document.getElementById('btn-end-turn').disabled = true;
        
        renderMap();

        // ä¾åºåŸ·è¡Œæ•µäºº AI
        for (const demon of enemies) {
            if (demon.hp > 0) {
                await new Promise(r => setTimeout(r, 600)); // æ¯å€‹æ•µäººè¡Œå‹•é–“éš”
                runEnemyAI(demon);
                renderMap();
            }
        }

        // æª¢æŸ¥å‹åˆ©/å¤±æ•—
        if (checkWinLose()) return;

        // å›åˆ°æˆ‘æ–¹å›åˆ
        startPlayerPhase();
    }

    // --- ç©å®¶äº’å‹•é‚è¼¯ (è¤‡é›œç‹€æ…‹æ©Ÿ) ---

    function onTileClick(x, y) {
        if (phase !== 'PLAYER') return; // æ•µæ–¹å›åˆé–å®šé»æ“Š

        const targetUnit = getUnitAt(x, y);

        // ç‹€æ…‹ 1: æœªé¸æ“‡ä»»ä½•å–®ä½
        if (selectionState === 'NONE') {
            if (targetUnit && targetUnit.type === 'slayer' && !targetUnit.hasActed) {
                selectUnit(targetUnit);
            } else if (targetUnit) {
                // åƒ…æŸ¥çœ‹
                showUnitInfo(targetUnit);
            }
            return;
        }

        // ç‹€æ…‹ 2: ç§»å‹•é¸æ“‡ä¸­ (MOVING)
        if (selectionState === 'MOVING') {
            // é»æ“Šè—è‰²æ ¼å­ -> ç§»å‹•
            if (grid[y][x].classList.contains('movable')) {
                executeMove(selectedUnit, x, y);
            } 
            // é»æ“Šè‡ªå·± -> å–æ¶ˆç§»å‹•/ä¸åšäº‹
            else if (x === selectedUnit.x && y === selectedUnit.y) {
                 executeMove(selectedUnit, x, y); // åŸåœ°ç§»å‹•ï¼Œé€²å…¥é¸å–®
            }
            // é»æ“Šå…¶ä»–åœ°æ–¹ -> å–æ¶ˆé¸æ“‡
            else {
                resetSelection();
                if (targetUnit && targetUnit.type === 'slayer' && !targetUnit.hasActed) selectUnit(targetUnit);
            }
            return;
        }

        // ç‹€æ…‹ 3: é¸å–®é–‹å•Ÿä¸­ (MENU) -> é»æ“Šåœ°åœ–è¦–ç‚ºå–æ¶ˆç§»å‹•
        if (selectionState === 'MENU') {
            cancelMovement(); // å¾Œæ‚”äº†ï¼Œé€€å›åŸä½
            return;
        }

        // ç‹€æ…‹ 4: é¸æ“‡æ”»æ“Šç›®æ¨™ (TARGETING)
        if (selectionState === 'TARGETING') {
            if (grid[y][x].classList.contains('attackable')) {
                // åˆ¤æ–·æ˜¯å¦é»æ“Šäº†æ•µäºº (æˆ–è€…ç¯„åœæŠ€é»æ“Šäº†ç©ºåœ°)
                // é€™è£¡ç°¡åŒ–ï¼šå¦‚æœæœ‰æ•µäººï¼Œæ‰“æ•µäººï¼›å¦‚æœæ˜¯ AOEï¼Œä»¥æ ¼å­ç‚ºä¸­å¿ƒ
                const hitEnemy = getUnitAt(x, y);
                if (hitEnemy && hitEnemy.type === 'demon') {
                    executeAttack(selectedUnit, hitEnemy, activeSkill);
                } else if (activeSkill && activeSkill.aoe) {
                     // ç¯„åœæŠ€æ‰“æ“Šç©ºåœ°
                     executeAttack(selectedUnit, {x:x, y:y, name:"åœ°é¢"}, activeSkill);
                }
            } else {
                // é»éŒ¯åœ°æ–¹ï¼Œå›åˆ°é¸å–®
                openActionMenu();
            }
        }
    }

    function selectUnit(unit) {
        selectedUnit = unit;
        selectionState = 'MOVING';
        showUnitInfo(unit);
        
        // é¡¯ç¤ºç§»å‹•ç¯„åœ
        renderMap();
        highlightMoveRange(unit);
    }

    function highlightMoveRange(unit) {
        const range = unit.moveRange;
        for(let y=0; y<GRID_SIZE; y++) {
            for(let x=0; x<GRID_SIZE; x++) {
                const dist = Math.abs(x - unit.x) + Math.abs(y - unit.y);
                const occupied = isOccupied(x, y) && (x !== unit.x || y !== unit.y); // ä¸èƒ½ç©¿é
                if (dist <= range && !occupied) {
                    grid[y][x].classList.add('movable');
                }
            }
        }
    }

    function executeMove(unit, x, y) {
        unit.x = x;
        unit.y = y;
        renderMap();
        openActionMenu();
    }

    function cancelMovement() {
        if (!selectedUnit) return;
        // å›æº¯ä½ç½®
        selectedUnit.x = selectedUnit.prevX;
        selectedUnit.y = selectedUnit.prevY;
        resetSelection();
        renderMap();
    }

    function openActionMenu() {
        selectionState = 'MENU';
        const panel = document.getElementById('action-panel');
        panel.style.display = 'block';
        document.getElementById('skill-list').style.display = 'none'; // éš±è—å­é¸å–®
        
        // æª¢æŸ¥æ”»æ“Šç¯„åœå…§æ˜¯å¦æœ‰æ•µäººï¼Œæ±ºå®šæŒ‰éˆ•æ˜¯å¦ç¦ç”¨
        // é€™è£¡ç‚ºäº†æµæš¢ï¼Œä¸ç¦ç”¨æ”»æ“ŠæŒ‰éˆ•ï¼Œé»äº†æ²’æ•µäººå†æç¤ºå³å¯
    }

    function toggleSkillMenu() {
        const list = document.getElementById('skill-list');
        if (list.style.display === 'flex') {
            list.style.display = 'none';
        } else {
            list.style.display = 'flex';
            list.innerHTML = '';
            const skills = selectedUnit.getSkills();
            skills.forEach(skill => {
                let btn = document.createElement('button');
                btn.className = 'skill-item';
                btn.innerHTML = `${skill.name} <small>(è·${skill.range}/${skill.aoe?'ç¯„åœ':'å–®é«”'})</small>`;
                btn.onclick = () => {
                    activeSkill = skill;
                    prepAttack(true);
                };
                list.appendChild(btn);
            });
            if(skills.length === 0) {
                list.innerHTML = '<div style="font-size:0.8em; color:#888; padding:5px;">ç„¡å¯ç”¨æ‹›å¼</div>';
            }
        }
    }

    function prepAttack(isSkill) {
        if (!isSkill) activeSkill = null;
        selectionState = 'TARGETING';
        document.getElementById('action-panel').style.display = 'none';
        
        renderMap();
        // é¡¯ç¤ºæ”»æ“Šç´…æ ¼å­
        const range = isSkill ? activeSkill.range : 1; // æ™®æ”»è·é›¢1
        
        // å–„é€¸æ™®æ”»è·é›¢ä¿®æ­£? éœ€æ±‚èªªå–„é€¸é æ”»ï¼Œå‡è¨­æ™®æ”»ä¹Ÿæ˜¯ 1ï¼Œä½†æŠ€èƒ½é 
        // ä¸ï¼Œéœ€æ±‚èªª "æˆ‘æ–¹å¢åŠ å–„é€¸ï¼ˆé æ”»ï¼‰" -> å–„é€¸æ™®æ”»å¯ä»¥è¨­ç‚º 3? 
        // ç‚ºäº†å¹³è¡¡ï¼Œè®“å–„é€¸åªæœ‰æŠ€èƒ½é æ”»ï¼Œæˆ–è€…æ™®æ”»è¨­ç‚º 1ã€‚
        // é€™è£¡ä¾ç…§ä¸Šä¸€ç‰ˆï¼Œå–„é€¸æ™®æ”»å¦‚æœæ²’ç‰¹åˆ¥å®šç¾©å°± 1ï¼Œä½†ç‚ºäº†ç¬¦åˆã€Œé æ”»ã€æè¿°ï¼š
        // æˆ‘å€‘è®“å–„é€¸æ™®æ”» Range 3 å§ï¼Ÿä½† Unit class æ²’å­˜ rangeã€‚
        // ç°¡å–®è™•ç†ï¼šå¦‚æœæ²’ç”¨æŠ€èƒ½ï¼Œç¯„åœå›ºå®š 1 (é™¤äº†å–„é€¸)ã€‚
        // é€™è£¡ç‚ºäº†æŠ€èƒ½ç³»çµ±æ¸…æ™°ï¼Œæ™®æ”»çµ±ä¸€ 1 æ ¼ï¼Œé æŠ€èƒ½æ‰“é ã€‚
        
        for(let y=0; y<GRID_SIZE; y++) {
            for(let x=0; x<GRID_SIZE; x++) {
                const dist = Math.abs(x - selectedUnit.x) + Math.abs(y - selectedUnit.y);
                if (dist <= range && dist > 0) {
                    grid[y][x].classList.add('attackable');
                }
            }
        }
        log(isSkill ? `ä½¿ç”¨ [${activeSkill.name}] é¸æ“‡ç›®æ¨™...` : "é¸æ“‡æ”»æ“Šç›®æ¨™...", 'normal');
    }

    function executeAttack(attacker, targetObj, skill) {
        let targets = [];
        
        if (skill && skill.aoe) {
            // ç¯„åœæ”»æ“Šï¼šç›®æ¨™é»å‘¨åœ 3x3
            for(let dy=-1; dy<=1; dy++){
                for(let dx=-1; dx<=1; dx++){
                    let tx = targetObj.x !== undefined ? targetObj.x + dx : targetObj.x; // Handle target object structure
                    let ty = targetObj.y !== undefined ? targetObj.y + dy : targetObj.y;
                    // å¦‚æœ targetObj æ˜¯å–®ä½ï¼Œç”¨å®ƒçš„ x,yã€‚å¦‚æœæ˜¯ {x,y} çµæ§‹ï¼Œç›´æ¥ç”¨
                    if (targetObj.x === undefined) { tx=targetObj.x; ty=targetObj.y; } // Fallback logic
                    
                    // å¯¦éš›æŠ“å–è©²æ ¼çš„æ•µäºº
                    let u = getUnitAt(tx, ty);
                    if (u && u.type === 'demon') targets.push(u);
                }
            }
            log(`${attacker.name} æ–½æ”¾ç¯„åœæˆ°æŠ€ï¼`, 'normal');
        } else {
            // å–®é«”
            if (targetObj.type === 'demon') targets.push(targetObj);
        }

        if (targets.length === 0) {
            log("æ²’æœ‰æ“Šä¸­ä»»ä½•æ•µäººï¼", 'normal');
        } else {
            targets.forEach(def => {
                let dmgMult = skill ? skill.dmg : 1.0;
                let raw = attacker.atk * dmgMult - (def.def * 0.5);
                let dmg = Math.max(1, Math.floor(raw * (0.9 + Math.random()*0.2)));
                
                def.hp -= dmg;
                log(`${attacker.name} å° ${def.name} é€ æˆ <span class="log-dmg">${dmg}</span> å‚·å®³`, 'dmg');
                
                if (def.hp <= 0) {
                    def.hp = 0;
                    log(`${def.name} è¢«æ¶ˆæ»…ï¼`, 'normal');
                    attacker.gainXp(35 + def.level*5 + (def.role==='boss'?50:0));
                }
            });
        }

        finalizeAction(false);
    }

    function finalizeAction(isWait) {
        if (selectedUnit) {
            selectedUnit.hasActed = true;
            if (isWait) log(`${selectedUnit.name} å¾…æ©Ÿ`, 'normal');
        }
        resetSelection();
        renderMap();
        
        // è‡ªå‹•æª¢æŸ¥æ˜¯å¦æ‰€æœ‰äººéƒ½å‹•å®Œäº†
        if (allies.every(u => u.hasActed)) {
            setTimeout(() => {
                if (confirm("æ‰€æœ‰äººå“¡å·²è¡Œå‹•ï¼ŒçµæŸå›åˆï¼Ÿ")) endPlayerPhase();
            }, 200);
        }
    }

    function resetSelection() {
        selectedUnit = null;
        selectionState = 'NONE';
        activeSkill = null;
        document.getElementById('action-panel').style.display = 'none';
        document.getElementById('unit-info').innerHTML = "è«‹é¸æ“‡å–®ä½...";
        
        // æ¸…é™¤æ ¼å­æ¨£å¼
        document.querySelectorAll('.tile').forEach(t => t.classList.remove('movable', 'attackable'));
    }

    // --- æ•µæ–¹ AI ---
    function runEnemyAI(demon) {
        // 1. æ‰¾æœ€è¿‘ç›®æ¨™
        let target = null;
        let minDist = 999;
        allies.forEach(a => {
            if (a.hp > 0) {
                let d = Math.abs(a.x - demon.x) + Math.abs(a.y - demon.y);
                if (d < minDist) { minDist = d; target = a; }
            }
        });

        if (!target) return;

        // 2. ç§»å‹• (å˜—è©¦æ¥è¿‘ï¼Œç¯„åœ 2)
        let moves = 2; // AI ç§»å‹•åŠ›
        let bestX = demon.x, bestY = demon.y;
        
        // ç°¡å–®é‚è¼¯ï¼šæ¯ä¸€æ­¥éƒ½å¾€ç›®æ¨™é è¿‘
        for(let m=0; m<moves; m++) {
            let dx = target.x - bestX;
            let dy = target.y - bestY;
            if (Math.abs(dx) + Math.abs(dy) <= 1) break; // å·²ç›¸é„°ï¼Œä¸å‹•

            let tryX = bestX + Math.sign(dx);
            let tryY = bestY + (dx === 0 ? Math.sign(dy) : 0); 
            // å¦‚æœ X è»¸èµ°ä¸å‹•æˆ–å·²å°é½Šï¼Œèµ° Y
            
            if (!isOccupied(tryX, tryY)) {
                bestX = tryX; bestY = tryY;
            } else if (!isOccupied(bestX, bestY + Math.sign(dy))) {
                bestY += Math.sign(dy); // å˜—è©¦ç¹è·¯
            }
        }
        demon.x = bestX; demon.y = bestY;

        // 3. æ”»æ“Š
        let d = Math.abs(target.x - demon.x) + Math.abs(target.y - demon.y);
        if (d === 1) {
            let dmg = Math.max(1, Math.floor((demon.atk - target.def*0.5) * 0.9));
            target.hp -= dmg;
            log(`${demon.name} æ”»æ“Š ${target.name}ï¼Œé€ æˆ <span class="log-dmg">${dmg}</span> å‚·å®³`, 'dmg');
            if (target.hp <= 0) {
                target.hp = 0;
                log(`${target.name} å€’ä¸‹äº†...`, 'dmg');
            }
        }
    }

    // --- è¼”åŠ©åŠŸèƒ½ ---

    function renderMap() {
        // æ¸…é™¤ DOM å…§å®¹
        for(let y=0; y<GRID_SIZE; y++) {
            for(let x=0; x<GRID_SIZE; x++) {
                let cell = grid[y][x];
                cell.innerHTML = '';
                cell.className = 'tile';
            }
        }

        // ç¹ªè£½å–®ä½
        [...enemies, ...allies].forEach(u => {
            if (u.hp <= 0) return;
            let div = document.createElement('div');
            div.className = `unit ${u.role} ${u.type}`;
            if (u.hasActed && u.type === 'slayer') div.classList.add('done');
            if (u === selectedUnit) div.classList.add('selected');

            div.innerText = u.name[0];

            let hpBg = document.createElement('div');
            hpBg.className = 'hp-bar-bg';
            let hpFill = document.createElement('div');
            hpFill.className = 'hp-bar-fill';
            hpFill.style.width = (u.hp / u.maxHp * 100) + '%';
            hpBg.appendChild(hpFill);
            div.appendChild(hpBg);

            let lvl = document.createElement('div');
            lvl.className = 'lvl-tag';
            lvl.innerText = u.level;
            div.appendChild(lvl);

            grid[u.y][u.x].appendChild(div);
        });
    }

    function showUnitInfo(u) {
        let skills = u.getSkills ? u.getSkills().map(s=>s.name).join(', ') : "ç„¡";
        let html = `
            <strong style="color:${u.type==='slayer'?'#00bfff':'#ff4d4d'}">${u.name} (Lv.${u.level})</strong><br>
            HP: ${u.hp} / ${u.maxHp}<br>
            ATK: ${u.atk} | DEF: ${u.def}<br>
        `;
        if(u.type === 'slayer') {
            html += `EXP: ${u.xp} / ${u.maxXp}<br>æ‹›å¼: ${skills || "å°šæœªç¿’å¾—"}`;
        }
        document.getElementById('unit-info').innerHTML = html;
    }

    function log(msg, type) {
        const box = document.getElementById('log-box');
        if (type === 'turn') msg = `<div class="log-turn">${msg}</div>`;
        else msg = `<div>${msg}</div>`;
        box.innerHTML += msg;
        box.scrollTop = box.scrollHeight;
    }

    function checkWinLose() {
        if (allies.every(u => u.hp <= 0)) {
            alert("å…¨è»è¦†æ²’... éŠæˆ²çµæŸã€‚");
            location.reload();
            return true;
        }
        if (enemies.every(u => u.hp <= 0)) {
            setTimeout(() => {
                if (currentLevel >= MAX_LEVEL) {
                    alert("æ­å–œé€šé—œï¼ç„¡é™åŸå´©å¡Œï¼Œé¬¼æ®ºéšŠå‹åˆ©ï¼");
                } else {
                    alert(`ç¬¬ ${currentLevel} é—œé€šéï¼å…¨å“¡å›å¾©ç‹€æ…‹ã€‚`);
                    startLevel(currentLevel + 1);
                }
            }, 500);
            return true;
        }
        return false;
    }

    function getBossName(l) {
        const n = ["ä¸‹å¼¦ä¹‹é™¸", "ä¸‹å¼¦ä¹‹ä¼", "ä¸‹å¼¦ä¹‹å£¹", "å¢®å§¬", "ç‰å£º", "åŠå¤©ç‹—", "çŒ—çª©åº§", "ç«¥ç£¨", "é»‘æ­»ç‰Ÿ"];
        return n[l-1] || "ç„¡æ…˜";
    }

    // å•Ÿå‹•
    initGame();

</script>
</body>
</html>
