<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>武士決戰 (Samurai Showdown)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            font-family: 'Helvetica', sans-serif;
        }
        #gameCanvas {
            border: 4px solid #555;
            background-color: #87CEEB; /* 天空藍背景 */
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #instructions {
            position: absolute;
            top: 10px;
            color: white;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h2>武士決戰</h2>
        <p>移動: 方向鍵 (← →) | 攻擊: 空白鍵 (Space)</p>
    </div>
    <canvas id="gameCanvas"></canvas>

<script>
// ===========================
// 遊戲設定與變數
// ===========================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 設定畫布大小 (固定寬高比)
const GAME_WIDTH = 800;
const GAME_HEIGHT = 450;
canvas.width = GAME_WIDTH;
canvas.height = GAME_HEIGHT;

let gameState = 'playing'; // playing, gameover
let score = 0;
let worldOffsetX = 0; // 用於背景捲動

// 按鍵狀態追蹤
const keys = {
    ArrowRight: false,
    ArrowLeft: false,
    Space: false
};

// ===========================
// 遊戲物件類別
// ===========================

// 主角：武士
class Samurai {
    constructor() {
        this.width = 40;
        this.height = 60;
        this.x = 100; // 初始位置
        this.y = GAME_HEIGHT - this.height - 50; // 地板高度
        this.speed = 5;
        this.color = '#004488'; // 深藍色盔甲
        this.health = 100;
        
        // 攻擊相關
        this.isAttacking = false;
        this.attackDuration = 0;
        this.attackCooldown = 0;
        this.attackHitbox = { x: 0, y: 0, width: 60, height: 20 };
    }

    update() {
        // 移動邏輯
        if (keys.ArrowRight) {
            // 如果主角在螢幕中間左側，移動主角
            if (this.x < GAME_WIDTH / 2) {
                this.x += this.speed;
            } else {
                // 如果主角在中間，移動世界(背景和敵人)
                worldOffsetX += this.speed;
            }
        }
        if (keys.ArrowLeft && this.x > 0) {
            this.x -= this.speed;
        }

        // 攻擊邏輯
        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.attackDuration > 0) this.attackDuration--;

        if (keys.Space && this.attackCooldown === 0 && !this.isAttacking) {
            this.isAttacking = true;
            this.attackDuration = 15; // 攻擊動畫持續幀數
            this.attackCooldown = 30; // 攻擊冷卻幀數
        }

        if (this.attackDuration === 0) {
            this.isAttacking = false;
        }

        // 更新攻擊判定框位置
        this.attackHitbox.x = this.x + this.width;
        this.attackHitbox.y = this.y + 20;
    }

    draw(ctx) {
        // 繪製身體 (簡化盔甲)
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // 繪製頭部/頭盔
        ctx.fillStyle = '#111';
        ctx.fillRect(this.x + 5, this.y - 15, this.width - 10, 15);

        // 繪製武士刀斬擊效果
        if (this.isAttacking && this.attackDuration > 5) {
            ctx.fillStyle = '#E5E4E2'; // 銀色刀光
            // 畫一個向右延伸的刀光矩形
            ctx.fillRect(this.x + this.width - 10, this.y + 10, this.attackHitbox.width, 10);
            
            // 刀光閃爍效果
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(this.x + this.width, this.y + 15);
            ctx.lineTo(this.x + this.width + this.attackHitbox.width + 10, this.y + 15 - (15 - this.attackDuration)*2);
            ctx.stroke();
        }
    }
}

// 敵人：浪人
class Enemy {
    constructor(x) {
        this.width = 40;
        this.height = 60;
        this.x = x; // 生成在螢幕外
        this.y = GAME_HEIGHT - this.height - 50;
        this.speed = Math.random() * 2 + 2; // 隨機速度
        this.color = '#880000'; // 紅色敵人
        this.markedForDeletion = false;
    }

    update(playerSpeedX) {
        // 敵人向左移動
        this.x -= this.speed;
        
        // 如果玩家在捲動世界，敵人需要額外向左移動
        if (keys.ArrowRight && player.x >= GAME_WIDTH / 2) {
            this.x -= playerSpeedX;
        }

        // 如果移出螢幕左側，標記刪除
        if (this.x + this.width < 0) {
            this.markedForDeletion = true;
        }
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        // 繪製敵人身體
        ctx.fillRect(this.x, this.y, this.width, this.height);
        // 繪製簡單的頭帶
        ctx.fillStyle = '#FF0000';
        ctx.fillRect(this.x, this.y + 5, this.width, 5);
    }
}

// ===========================
// 遊戲核心功能
// ===========================

const player = new Samurai();
let enemies = [];
let enemySpawnTimer = 0;

// 碰撞偵測 (矩形與矩形)
function checkCollision(rect1, rect2) {
    return (
        rect1.x < rect2.x + rect2.width &&
        rect1.x + rect1.width > rect2.x &&
        rect1.y < rect2.y + rect2.height &&
        rect1.y + rect1.height > rect2.y
    );
}

function handleEnemies() {
    // 生成敵人
    enemySpawnTimer++;
    if (enemySpawnTimer > 60 - Math.min(score / 2, 40)) { // 隨著分數增加，生成速度變快
        // 生成在螢幕右側邊緣外
        enemies.push(new Enemy(GAME_WIDTH + Math.random() * 200));
        enemySpawnTimer = 0;
    }

    enemies.forEach(enemy => {
        enemy.update(player.speed);
        enemy.draw(ctx);

        // 檢查玩家攻擊是否擊中敵人
        if (player.isAttacking && player.attackDuration > 5) {
            if (checkCollision(player.attackHitbox, enemy)) {
                enemy.markedForDeletion = true;
                score += 10;
                // 擊中效果 (簡單閃爍)
                ctx.fillStyle = 'rgba(255, 255, 0, 0.5)';
                ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
            }
        }

        // 檢查敵人是否撞到玩家 (簡單的遊戲結束條件)
        if (checkCollision(player, enemy)) {
            // 在這個簡單原型中，碰到敵人就扣血，這裡簡化為碰觸多次後結束
             player.health -= 1;
             if(player.health <= 0) {
                 gameState = 'gameover';
             }
             ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
             ctx.fillRect(player.x, player.y, player.width, player.height);
        }
    });

    // 移除標記的敵人
    enemies = enemies.filter(enemy => !enemy.markedForDeletion);
}

function drawBackground() {
    // 簡單的視差滾動背景
    
    // 遠景 (天空與山) - 移動較慢
    let bg1Offset = (worldOffsetX * 0.1) % GAME_WIDTH;
    ctx.fillStyle = '#87CEEB'; // 天空
    ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
    ctx.fillStyle = '#6E7B8B'; // 遠山
    ctx.beginPath();
    ctx.moveTo(0, 250);
    ctx.lineTo(200, 150);
    ctx.lineTo(400, 250);
    ctx.lineTo(600, 180);
    ctx.lineTo(800, 250);
    ctx.lineTo(800, GAME_HEIGHT);
    ctx.lineTo(0, GAME_HEIGHT);
    ctx.fill();

    // 中景 (竹林) - 移動中等
    let bg2Offset = (worldOffsetX * 0.5) % GAME_WIDTH;
    ctx.fillStyle = '#228B22';
    for(let i = -1; i < 5; i++) {
        let xPos = i * 200 - bg2Offset + 50;
        ctx.fillRect(xPos, 200, 20, GAME_HEIGHT - 200);
        ctx.fillRect(xPos + 30, 180, 15, GAME_HEIGHT - 180);
    }

    // 地板 - 移動最快 (與玩家同步)
    ctx.fillStyle = '#4b3c2a'; // 泥土顏色
    ctx.fillRect(0, GAME_HEIGHT - 50, GAME_WIDTH, 50);
    // 地板紋理
    ctx.strokeStyle = '#3b2c1a';
    ctx.beginPath();
    for(let i=0; i < GAME_WIDTH + worldOffsetX % 50; i+=50) {
         let lineX = i - (worldOffsetX % 50);
         ctx.moveTo(lineX, GAME_HEIGHT-50);
         ctx.lineTo(lineX, GAME_HEIGHT);
    }
    ctx.stroke();
}

function drawUI() {
    ctx.fillStyle = 'black';
    ctx.font = '24px Arial';
    ctx.fillText('得分: ' + score, 20, 40);
    
    // 血條
    ctx.fillStyle = 'red';
    ctx.fillRect(20, 50, 100, 10);
    ctx.fillStyle = 'lime';
    ctx.fillRect(20, 50, player.health, 10);
    ctx.strokeStyle = 'black';
    ctx.strokeRect(20, 50, 100, 10);

    if (gameState === 'gameover') {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
        ctx.fillStyle = 'white';
        ctx.font = '48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('遊戲結束', GAME_WIDTH / 2, GAME_HEIGHT / 2);
        ctx.font = '24px Arial';
        ctx.fillText('最終得分: ' + score, GAME_WIDTH / 2, GAME_HEIGHT / 2 + 40);
        ctx.fillText('重新整理頁面再試一次', GAME_WIDTH / 2, GAME_HEIGHT / 2 + 80);
    }
}

// ===========================
// 主遊戲迴圈
// ===========================

function gameLoop() {
    ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

    if (gameState === 'playing') {
        drawBackground();
        player.update();
        player.draw(ctx);
        handleEnemies();
    }
    
    drawUI();
    requestAnimationFrame(gameLoop);
}

// ===========================
// 事件監聽器 (輸入控制)
// ===========================

window.addEventListener('keydown', (e) => {
    if (e.code === 'ArrowRight') keys.ArrowRight = true;
    if (e.code === 'ArrowLeft') keys.ArrowLeft = true;
    if (e.code === 'Space') {
        keys.Space = true;
        e.preventDefault(); // 防止空白鍵捲動網頁
    }
});

window.addEventListener('keyup', (e) => {
    if (e.code === 'ArrowRight') keys.ArrowRight = false;
    if (e.code === 'ArrowLeft') keys.ArrowLeft = false;
    if (e.code === 'Space') keys.Space = false;
});

// 開始遊戲
gameLoop();

</script>
</body>
</html>
