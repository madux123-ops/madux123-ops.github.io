<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>忍者卷軸：影之戰</title>
    <style>
        body {
            background-color: #222;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        canvas {
            background-color: #000;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 480px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }
        #instructions {
            margin-top: 10px;
            font-size: 0.9em;
            color: #aaa;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score">分數: 0</div>
        <div id="lives">生命: 3</div>
        <div id="bombs">炸彈(X): 5</div>
    </div>

    <canvas id="gameCanvas" width="480" height="640"></canvas>

    <div id="instructions">
        方向鍵: 移動 | Z: 飛鏢攻擊 | X: 忍術爆炸 (抵銷子彈)
    </div>

<script>
/** 遊戲核心設定 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 遊戲狀態
let gameState = 'MENU'; // MENU, PLAYING, GAMEOVER, LEVEL_CLEAR
let frameCount = 0;
let score = 0;
let level = 1;
let killCount = 0;
const KILLS_TO_BOSS = 30;

// 輸入控制
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    z: false, x: false
};

// 實體列表
let player;
let bullets = [];
let enemyBullets = [];
let enemies = [];
let items = [];
let particles = [];
let boss = null;
let warningZones = []; // Boss 攻擊預警區域

// 鍵盤監聽
window.addEventListener('keydown', e => {
    if(keys.hasOwnProperty(e.key) || e.key === 'z' || e.key === 'x') keys[e.key] = true;
    
    // 遊戲開始/重來
    if (gameState === 'MENU' && e.key === 'z') {
        initGame();
    } else if (gameState === 'GAMEOVER') {
        if (e.key === 'z') { // 繼續 (扣分或重置分數，這裡簡單處理為重置當前關卡)
             player.lives = 3; 
             player.hp = 100;
             score = 0; // 簡單處理
             resetLevel();
        } else if (e.key === 'x') { // 重新開始
             initGame();
        }
    } else if (gameState === 'LEVEL_CLEAR' && e.key === 'z') {
        nextLevel();
    }
});

window.addEventListener('keyup', e => {
    if(keys.hasOwnProperty(e.key) || e.key === 'z' || e.key === 'x') keys[e.key] = false;
    if (e.key === 'z') player.canShoot = true; // 放開重置射擊
    if (e.key === 'x') player.canBomb = true;
});

/** 類別定義 */

// 玩家類別
class Player {
    constructor() {
        this.w = 30;
        this.h = 30;
        this.x = canvas.width / 2 - this.w / 2;
        this.y = canvas.height - 100;
        this.speed = 5;
        this.color = '#00ff00';
        this.lives = 3;
        this.hp = 100; // 單條命的血量
        this.weaponLevel = 1;
        this.bombs = 5;
        this.canShoot = true;
        this.canBomb = true;
        this.invincibleTimer = 0;
    }

    update() {
        // 移動
        if (keys.ArrowUp && this.y > 0) this.y -= this.speed;
        if (keys.ArrowDown && this.y < canvas.height - this.h) this.y += this.speed;
        if (keys.ArrowLeft && this.x > 0) this.x -= this.speed;
        if (keys.ArrowRight && this.x < canvas.width - this.w) this.x += this.speed;

        // 射擊 (Z)
        if (keys.z && this.canShoot) {
            this.shoot();
            // 根據等級調整射速，這裡簡單用 frameCount 限制
            if (this.weaponLevel < 2) this.canShoot = false; // 等級1需連點
            // 等級2以上可以按住，但有間隔
            if (this.weaponLevel >= 2 && frameCount % 8 !== 0) return; 
        }

        // 炸彈 (X)
        if (keys.x && this.canBomb && this.bombs > 0) {
            this.useBomb();
            this.canBomb = false;
        }

        // 無敵時間閃爍
        if (this.invincibleTimer > 0) this.invincibleTimer--;
    }

    draw() {
        if (this.invincibleTimer > 0 && Math.floor(frameCount / 4) % 2 === 0) return;
        
        ctx.fillStyle = this.color;
        // 畫一個簡單的忍者造型 (身體)
        ctx.fillRect(this.x, this.y, this.w, this.h);
        // 頭帶
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y + 5, this.w, 5);
        
        // 繪製血條 (在角色下方)
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y + this.h + 5, this.w, 4);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(this.x, this.y + this.h + 5, this.w * (this.hp / 100), 4);
    }

    shoot() {
        // 飛鏢樣式
        let speed = 10;
        // 等級 1: 單發
        if (this.weaponLevel === 1) {
            bullets.push(new Bullet(this.x + this.w/2, this.y, 0, -speed, 'player'));
        }
        // 等級 2: 加速連射 (在 update 控制頻率，這裡還是單發結構，但視覺快)
        else if (this.weaponLevel === 2) {
             bullets.push(new Bullet(this.x + this.w/2, this.y, 0, -12, 'player'));
        }
        // 等級 3: 二連並排
        else if (this.weaponLevel === 3) {
            bullets.push(new Bullet(this.x + 5, this.y, 0, -speed, 'player'));
            bullets.push(new Bullet(this.x + this.w - 5, this.y, 0, -speed, 'player'));
        }
        // 等級 4+: 散射
        else {
            bullets.push(new Bullet(this.x + this.w/2, this.y, 0, -speed, 'player'));
            bullets.push(new Bullet(this.x + this.w/2, this.y, -3, -speed * 0.9, 'player'));
            bullets.push(new Bullet(this.x + this.w/2, this.y, 3, -speed * 0.9, 'player'));
        }
    }

    useBomb() {
        this.bombs--;
        updateUI();
        // 視覺特效：全屏閃白
        createExplosion(canvas.width/2, canvas.height/2, 500, '#FFF', 20);
        
        // 消除所有敵方子彈
        enemyBullets = [];
        
        // 對所有敵人造成大傷害
        enemies.forEach(e => {
            e.takeDamage(50);
            createExplosion(e.x + e.w/2, e.y + e.h/2, 50, '#FFA500', 10);
        });
        
        if(boss) {
            boss.takeDamage(100);
            createExplosion(boss.x + boss.w/2, boss.y + boss.h/2, 100, '#FFA500', 20);
        }
    }

    takeDamage(amount) {
        if (this.invincibleTimer > 0) return;
        
        this.hp -= amount;
        if (this.hp <= 0) {
            this.lives--;
            updateUI();
            createExplosion(this.x + this.w/2, this.y + this.h/2, 50, '#0f0', 20);
            
            if (this.lives < 0) {
                gameState = 'GAMEOVER';
            } else {
                // 復活重置位置
                this.hp = 100;
                this.x = canvas.width / 2 - this.w / 2;
                this.y = canvas.height - 100;
                this.invincibleTimer = 120; // 2秒無敵
                // 武器降級懲罰? 這裡暫時保留
                this.weaponLevel = Math.max(1, this.weaponLevel - 1);
            }
        } else {
            this.invincibleTimer = 30; // 受傷短暫無敵
        }
    }
}

// 子彈類別
class Bullet {
    constructor(x, y, vx, vy, owner) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.owner = owner; // 'player' or 'enemy'
        this.r = 4;
        this.markedForDeletion = false;
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;
        
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) {
            this.markedForDeletion = true;
        }
    }

    draw() {
        ctx.beginPath();
        if (this.owner === 'player') {
            ctx.fillStyle = '#FFFF00'; // 黃色飛鏢
            // 畫菱形模擬飛鏢
            ctx.moveTo(this.x, this.y - 5);
            ctx.lineTo(this.x + 5, this.y);
            ctx.lineTo(this.x, this.y + 5);
            ctx.lineTo(this.x - 5, this.y);
        } else {
            ctx.fillStyle = '#FF4444'; // 紅色敵彈
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        }
        ctx.fill();
    }
}

// 敵人類別
class Enemy {
    constructor(type) {
        this.w = 30;
        this.h = 30;
        this.x = Math.random() * (canvas.width - this.w);
        this.y = -40;
        this.hp = 3;
        this.type = type || 'normal'; // normal, shooter, dasher
        this.vy = 2 + Math.random() * 2;
        this.vx = (Math.random() - 0.5) * 1;
        this.markedForDeletion = false;
        this.shootTimer = Math.random() * 60;
    }

    update() {
        this.y += this.vy;
        this.x += this.vx;

        // 邊界反彈
        if (this.x <= 0 || this.x >= canvas.width - this.w) this.vx *= -1;

        if (this.y > canvas.height) this.markedForDeletion = true;

        // 射擊邏輯
        this.shootTimer--;
        if (this.shootTimer <= 0) {
            if (this.type === 'shooter') {
                enemyBullets.push(new Bullet(this.x + this.w/2, this.y + this.h, 0, 5, 'enemy'));
                this.shootTimer = 100;
            } else if (this.type === 'normal' && Math.random() < 0.3) {
                // 普通敵人偶爾射擊
                enemyBullets.push(new Bullet(this.x + this.w/2, this.y + this.h, 0, 4, 'enemy'));
                this.shootTimer = 150;
            }
        }
    }

    draw() {
        ctx.fillStyle = this.type === 'shooter' ? '#c0392b' : '#d35400';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        // 眼睛
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x + 5, this.y + 10, 8, 5);
        ctx.fillRect(this.x + 18, this.y + 10, 8, 5);
    }

    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            this.markedForDeletion = true;
            score += 100;
            killCount++;
            
            // 掉落物機率
            if (Math.random() < 0.1) {
                let itemType = Math.random() < 0.7 ? 'power' : 'bomb';
                items.push(new Item(this.x, this.y, itemType));
            }
            createExplosion(this.x + this.w/2, this.y + this.h/2, 20, '#FFA500', 5);
            updateUI();
        }
    }
}

// Boss 類別
class Boss {
    constructor() {
        this.w = 80;
        this.h = 60;
        this.x = canvas.width / 2 - this.w / 2;
        this.y = -100;
        this.maxHp = 500 * level;
        this.hp = this.maxHp;
        this.state = 'enter'; // enter, idle, attack, summon
        this.timer = 0;
        this.moveDir = 1;
    }

    update() {
        this.timer++;

        // 狀態機
        if (this.state === 'enter') {
            this.y += 2;
            if (this.y >= 50) this.state = 'idle';
        } 
        else if (this.state === 'idle') {
            // 左右移動
            this.x += 2 * this.moveDir;
            if (this.x <= 0 || this.x >= canvas.width - this.w) this.moveDir *= -1;

            if (this.timer % 120 === 0) {
                // 切換攻擊模式
                let rand = Math.random();
                if (rand < 0.4) this.state = 'prepare_laser'; // 範圍攻擊
                else if (rand < 0.7) this.state = 'summon';   // 召喚
                else this.state = 'spread_shot';              // 散彈
            }
        }
        else if (this.state === 'prepare_laser') {
            // 預警：在玩家當前位置產生紅色警告區
            warningZones.push(new WarningZone(player.x - 20, 0, 70, canvas.height, 60)); // 60 frames delay
            this.state = 'idle';
        }
        else if (this.state === 'summon') {
            enemies.push(new Enemy('shooter'));
            enemies.push(new Enemy('normal'));
            this.state = 'idle';
        }
        else if (this.state === 'spread_shot') {
            for(let i=-2; i<=2; i++) {
                enemyBullets.push(new Bullet(this.x + this.w/2, this.y + this.h, i, 4, 'enemy'));
            }
            this.state = 'idle';
        }
    }

    draw() {
        ctx.fillStyle = '#8e44ad'; // 紫色 Boss
        ctx.fillRect(this.x, this.y, this.w, this.h);
        // 裝飾
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(this.x + 10, this.y + 10, this.w - 20, 10);
        
        // 血條
        ctx.fillStyle = '#555';
        ctx.fillRect(0, 0, canvas.width, 10);
        ctx.fillStyle = '#e74c3c';
        ctx.fillRect(0, 0, canvas.width * (this.hp / this.maxHp), 10);
    }

    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            score += 5000;
            createExplosion(this.x + this.w/2, this.y + this.h/2, 200, '#FFF', 50);
            boss = null;
            gameState = 'LEVEL_CLEAR';
        }
    }
}

// 預警與範圍傷害區域
class WarningZone {
    constructor(x, y, w, h, duration) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.timer = duration;
        this.maxTimer = duration;
        this.active = true;
    }

    update() {
        this.timer--;
        if (this.timer <= 0) {
            // 造成傷害
            if (rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
                player.takeDamage(30);
            }
            // 產生爆炸特效
            createExplosion(this.x + this.w/2, player.y, 50, '#FF4444', 10);
            this.active = false;
        }
    }

    draw() {
        ctx.save();
        // 閃爍透明度
        let alpha = (this.timer / this.maxTimer) * 0.5 + 0.2;
        ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.strokeStyle = 'red';
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        ctx.restore();
    }
}

// 掉落道具
class Item {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'power' or 'bomb'
        this.w = 20;
        this.h = 20;
        this.vy = 2;
        this.markedForDeletion = false;
    }

    update() {
        this.y += this.vy;
        if (this.y > canvas.height) this.markedForDeletion = true;
        
        // 玩家吃到
        if (rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
            if (this.type === 'power') {
                player.weaponLevel = Math.min(player.weaponLevel + 1, 4);
                score += 200;
            } else if (this.type === 'bomb') {
                player.bombs++;
            }
            updateUI();
            this.markedForDeletion = true;
        }
    }

    draw() {
        ctx.font = '20px Arial';
        if (this.type === 'power') {
            ctx.fillStyle = 'red';
            ctx.fillText('P', this.x, this.y + 20);
        } else {
            ctx.fillStyle = 'blue';
            ctx.fillText('B', this.x, this.y + 20);
        }
    }
}

// 簡單粒子特效
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 6;
        this.vy = (Math.random() - 0.5) * 6;
        this.life = 30;
        this.color = color;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life--;
    }
    draw() {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        ctx.fillRect(this.x, this.y, 4, 4);
        ctx.globalAlpha = 1;
    }
}

function createExplosion(x, y, count, color, range) {
    for(let i=0; i<count; i++) {
        let p = new Particle(x + (Math.random()-0.5)*range, y + (Math.random()-0.5)*range, color);
        particles.push(p);
    }
}

/** 輔助函式 */
function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

function updateUI() {
    document.getElementById('score').innerText = `分數: ${score}`;
    document.getElementById('lives').innerText = `生命: ${player.lives}`;
    document.getElementById('bombs').innerText = `炸彈(X): ${player.bombs}`;
}

function initGame() {
    score = 0;
    level = 1;
    killCount = 0;
    player = new Player();
    resetLevel();
}

function resetLevel() {
    bullets = [];
    enemyBullets = [];
    enemies = [];
    items = [];
    particles = [];
    warningZones = [];
    boss = null;
    gameState = 'PLAYING';
    updateUI();
}

function nextLevel() {
    level++;
    killCount = 0;
    // 玩家補血
    player.hp = 100;
    // 重置場景但保留武器
    resetLevel();
}

/** 遊戲主迴圈 */
function gameLoop() {
    // 清空畫面
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'MENU') {
        ctx.fillStyle = 'white';
        ctx.font = '30px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('忍者卷軸：影之戰', canvas.width/2, canvas.height/2 - 40);
        ctx.font = '20px sans-serif';
        ctx.fillText('按 Z 鍵開始遊戲', canvas.width/2, canvas.height/2 + 20);
    } 
    else if (gameState === 'PLAYING') {
        frameCount++;

        // 產生敵人
        if (!boss && enemies.length < 5 + level && Math.random() < 0.02) {
            let type = Math.random() > 0.8 ? 'shooter' : 'normal';
            enemies.push(new Enemy(type));
        }

        // 產生Boss
        if (!boss && killCount >= KILLS_TO_BOSS * level) {
            boss = new Boss();
        }

        // 更新實體
        player.update();
        player.draw();

        if (boss) {
            boss.update();
            boss.draw();
        }

        // 處理預警區域
        warningZones.forEach((z, i) => {
            z.update();
            z.draw();
            if (!z.active) warningZones.splice(i, 1);
        });

        bullets.forEach((b, i) => {
            b.update();
            b.draw();
            if (b.markedForDeletion) bullets.splice(i, 1);
        });

        enemyBullets.forEach((b, i) => {
            b.update();
            b.draw();
            if (b.markedForDeletion) enemyBullets.splice(i, 1);
            else if (rectIntersect(b.x, b.y, b.r*2, b.r*2, player.x, player.y, player.w, player.h)) {
                player.takeDamage(10);
                b.markedForDeletion = true;
            }
        });

        enemies.forEach((e, i) => {
            e.update();
            e.draw();
            if (e.markedForDeletion) enemies.splice(i, 1);
            
            // 撞擊玩家
            if (rectIntersect(e.x, e.y, e.w, e.h, player.x, player.y, player.w, player.h)) {
                player.takeDamage(20);
                e.takeDamage(10); // 敵人也受傷
            }
        });

        items.forEach((item, i) => {
            item.update();
            item.draw();
            if (item.markedForDeletion) items.splice(i, 1);
        });

        particles.forEach((p, i) => {
            p.update();
            p.draw();
            if (p.life <= 0) particles.splice(i, 1);
        });

        // 子彈與敵人碰撞
        bullets.forEach(b => {
            enemies.forEach(e => {
                if (rectIntersect(b.x, b.y, 4, 10, e.x, e.y, e.w, e.h)) {
                    e.takeDamage(1); // 傷害
                    b.markedForDeletion = true;
                    createExplosion(b.x, b.y, 2, '#fff', 5);
                }
            });
            if (boss && rectIntersect(b.x, b.y, 4, 10, boss.x, boss.y, boss.w, boss.h)) {
                 boss.takeDamage(1);
                 b.markedForDeletion = true;
                 createExplosion(b.x, b.y, 2, '#fff', 5);
            }
        });

    } 
    else if (gameState === 'GAMEOVER') {
        ctx.fillStyle = 'red';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('勝敗乃兵家常事', canvas.width/2, canvas.height/2 - 20);
        
        ctx.fillStyle = 'white';
        ctx.font = '20px sans-serif';
        ctx.fillText('按 Z 接關 (消耗分數)', canvas.width/2, canvas.height/2 + 40);
        ctx.fillText('按 X 重新開始', canvas.width/2, canvas.height/2 + 70);
    }
    else if (gameState === 'LEVEL_CLEAR') {
        ctx.fillStyle = '#2ecc71';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`第 ${level} 關 通過!`, canvas.width/2, canvas.height/2 - 20);
        ctx.font = '20px sans-serif';
        ctx.fillText('武器等級保留，HP已恢復', canvas.width/2, canvas.height/2 + 30);
        ctx.fillText('按 Z 進入下一關', canvas.width/2, canvas.height/2 + 70);
    }

    requestAnimationFrame(gameLoop);
}

// 啟動
requestAnimationFrame(gameLoop);

</script>
</body>
</html>
