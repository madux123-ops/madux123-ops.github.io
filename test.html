<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>忍者卷軸：雙鬼之亂</title>
    <style>
        body {
            background-color: #222;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none;
            padding-top: 10px;
        }

        canvas {
            background-color: #000;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%; 
            max-height: 65vh;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        #ui-layer {
            width: 100%;
            max-width: 480px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 5px;
            padding: 0 10px;
            box-sizing: border-box;
        }

        #controls-area {
            position: fixed;
            bottom: 10px;
            left: 0;
            width: 100%;
            height: 160px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
        }

        .action-pad {
            pointer-events: auto;
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .d-pad {
            pointer-events: auto;
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 50px 50px 50px;
            gap: 5px;
            margin-bottom: 10px;
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            user-select: none;
            cursor: pointer;
            transition: background 0.1s;
        }
        
        .btn:active, .btn.active {
            background: rgba(255, 255, 255, 0.5);
            color: #000;
        }

        .btn-action {
            width: 70px;
            height: 70px;
            background: rgba(255, 50, 50, 0.2);
        }

        .btn-arrow {
            width: 60px;
            height: 50px;
            border-radius: 10px;
            background: rgba(50, 150, 255, 0.2);
        }
        
        .up { grid-column: 2; grid-row: 1; }
        .left { grid-column: 1; grid-row: 2; }
        .down { grid-column: 2; grid-row: 3; }
        .right { grid-column: 3; grid-row: 2; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score">分數: 0</div>
        <div id="lives">生命: 3</div>
        <div id="bombs">炸彈: 5</div>
    </div>

    <canvas id="gameCanvas" width="480" height="640"></canvas>

    <div id="controls-area">
        <div class="action-pad">
            <div class="btn btn-action" id="btn-x" data-key="x">X<br><span style="font-size:10px">炸彈</span></div>
            <div class="btn btn-action" id="btn-z" data-key="z">Z<br><span style="font-size:10px">攻擊</span></div>
        </div>

        <div class="d-pad">
            <div class="btn btn-arrow up" id="btn-up" data-key="ArrowUp">▲</div>
            <div class="btn btn-arrow left" id="btn-left" data-key="ArrowLeft">◀</div>
            <div class="btn btn-arrow right" id="btn-right" data-key="ArrowRight">▶</div>
            <div class="btn btn-arrow down" id="btn-down" data-key="ArrowDown">▼</div>
        </div>
    </div>

<script>
/** 遊戲核心設定 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 遊戲狀態
let gameState = 'MENU';
let frameCount = 0;
let score = 0;
let level = 1;
let killCount = 0;
const KILLS_TO_BOSS = 30;

// 輸入控制
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    z: false, x: false
};

// 實體列表
let player;
let bullets = [];
let enemyBullets = [];
let enemies = [];
let items = [];
let particles = [];
let bosses = []; // 修改：改為陣列支援多Boss
let warningZones = [];

// --- 輸入處理 ---
function handleKey(key, isPressed) {
    if (keys.hasOwnProperty(key)) keys[key] = isPressed;

    if (isPressed) {
        if (gameState === 'MENU' && key === 'z') {
            initGame();
        } else if (gameState === 'GAMEOVER') {
            if (key === 'z') { 
                 player.lives = 3; 
                 player.hp = 100;
                 score = 0; 
                 resetLevel();
            } else if (key === 'x') { 
                 initGame();
            }
        } else if (gameState === 'LEVEL_CLEAR' && key === 'z') {
            nextLevel();
        }
    }

    if (!isPressed) {
        if (key === 'z' && player) player.canShoot = true;
        if (key === 'x' && player) player.canBomb = true;
    }
}

window.addEventListener('keydown', e => handleKey(e.key, true));
window.addEventListener('keyup', e => handleKey(e.key, false));

const touchButtons = document.querySelectorAll('.btn');
touchButtons.forEach(btn => {
    const key = btn.dataset.key;
    const pressHandler = (e) => { e.preventDefault(); handleKey(key, true); btn.classList.add('active'); };
    const releaseHandler = (e) => { e.preventDefault(); handleKey(key, false); btn.classList.remove('active'); };
    btn.addEventListener('mousedown', pressHandler);
    btn.addEventListener('touchstart', pressHandler);
    btn.addEventListener('mouseup', releaseHandler);
    btn.addEventListener('touchend', releaseHandler);
    btn.addEventListener('mouseleave', releaseHandler);
});

/** 類別定義 */

class Player {
    constructor() {
        this.w = 30;
        this.h = 30;
        this.x = canvas.width / 2 - this.w / 2;
        this.y = canvas.height - 100;
        this.speed = 5;
        this.color = '#00ff00';
        this.lives = 3;
        this.hp = 100;
        this.weaponLevel = 1;
        this.bombs = 5;
        this.canShoot = true;
        this.canBomb = true;
        this.invincibleTimer = 0;
    }

    update() {
        if (keys.ArrowUp && this.y > 0) this.y -= this.speed;
        if (keys.ArrowDown && this.y < canvas.height - this.h) this.y += this.speed;
        if (keys.ArrowLeft && this.x > 0) this.x -= this.speed;
        if (keys.ArrowRight && this.x < canvas.width - this.w) this.x += this.speed;

        if (keys.z && this.canShoot) {
            this.shoot();
            if (this.weaponLevel < 2) this.canShoot = false; 
            if (this.weaponLevel >= 2 && frameCount % 8 !== 0) return; 
        }

        if (keys.x && this.canBomb && this.bombs > 0) {
            this.useBomb();
            this.canBomb = false;
        }

        if (this.invincibleTimer > 0) this.invincibleTimer--;
    }

    draw() {
        if (this.invincibleTimer > 0 && Math.floor(frameCount / 4) % 2 === 0) return;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y + 5, this.w, 5);
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y + this.h + 5, this.w, 4);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(this.x, this.y + this.h + 5, this.w * (this.hp / 100), 4);
    }

    shoot() {
        let speed = 10;
        // Lv 1: 單發
        if (this.weaponLevel === 1) {
            bullets.push(new Bullet(this.x + this.w/2, this.y, 0, -speed, 'player'));
        }
        // Lv 2: 加速
        else if (this.weaponLevel === 2) {
             bullets.push(new Bullet(this.x + this.w/2, this.y, 0, -12, 'player'));
        }
        // Lv 3: 二連並排
        else if (this.weaponLevel === 3) {
            bullets.push(new Bullet(this.x + 5, this.y, 0, -speed, 'player'));
            bullets.push(new Bullet(this.x + this.w - 5, this.y, 0, -speed, 'player'));
        }
        // Lv 4: 三向散射
        else if (this.weaponLevel === 4) {
            bullets.push(new Bullet(this.x + this.w/2, this.y, 0, -speed, 'player'));
            bullets.push(new Bullet(this.x + this.w/2, this.y, -3, -speed * 0.9, 'player'));
            bullets.push(new Bullet(this.x + this.w/2, this.y, 3, -speed * 0.9, 'player'));
        }
        // Lv 5: 五向廣角散射 (新增)
        else {
            let cx = this.x + this.w/2;
            bullets.push(new Bullet(cx, this.y, 0, -speed, 'player'));
            bullets.push(new Bullet(cx, this.y, -2.5, -speed * 0.95, 'player'));
            bullets.push(new Bullet(cx, this.y, 2.5, -speed * 0.95, 'player'));
            bullets.push(new Bullet(cx, this.y, -5, -speed * 0.85, 'player'));
            bullets.push(new Bullet(cx, this.y, 5, -speed * 0.85, 'player'));
        }
    }

    useBomb() {
        this.bombs--;
        updateUI();
        createExplosion(canvas.width/2, canvas.height/2, 500, '#FFF', 20);
        enemyBullets = [];
        enemies.forEach(e => {
            e.takeDamage(50);
            createExplosion(e.x + e.w/2, e.y + e.h/2, 50, '#FFA500', 10);
        });
        // 對所有 Boss 造成傷害
        bosses.forEach(b => {
            b.takeDamage(100);
            createExplosion(b.x + b.w/2, b.y + b.h/2, 100, '#FFA500', 20);
        });
    }

    takeDamage(amount) {
        if (this.invincibleTimer > 0) return;
        this.hp -= amount;
        if (this.hp <= 0) {
            this.lives--;
            updateUI();
            createExplosion(this.x + this.w/2, this.y + this.h/2, 50, '#0f0', 20);
            
            if (this.lives < 0) {
                gameState = 'GAMEOVER';
            } else {
                this.hp = 100;
                this.x = canvas.width / 2 - this.w / 2;
                this.y = canvas.height - 100;
                this.invincibleTimer = 120;
                this.weaponLevel = Math.max(1, this.weaponLevel - 1);
            }
        } else {
            this.invincibleTimer = 30;
        }
    }
}

class Bullet {
    constructor(x, y, vx, vy, owner) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.owner = owner;
        this.r = 4; this.markedForDeletion = false;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.markedForDeletion = true;
    }
    draw() {
        ctx.beginPath();
        if (this.owner === 'player') {
            ctx.fillStyle = this.vx === 0 ? '#FFFF00' : '#FFAA00'; // 散射飛鏢變色
            ctx.moveTo(this.x, this.y - 5);
            ctx.lineTo(this.x + 5, this.y);
            ctx.lineTo(this.x, this.y + 5);
            ctx.lineTo(this.x - 5, this.y);
        } else {
            ctx.fillStyle = '#FF4444';
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        }
        ctx.fill();
    }
}

class Enemy {
    constructor(spawnType) {
        this.w = 30; this.h = 30;
        this.hp = 3;
        this.type = Math.random() > 0.7 ? 'shooter' : 'normal';
        this.markedForDeletion = false;
        this.shootTimer = Math.random() * 60;

        // 設定出生點與移動方向 (新增左右生成)
        if (spawnType === 'left') {
            this.x = -this.w;
            this.y = Math.random() * (canvas.height / 2); // 上半部
            this.vx = 2 + Math.random() * 2;
            this.vy = 1 + Math.random(); 
        } else if (spawnType === 'right') {
            this.x = canvas.width;
            this.y = Math.random() * (canvas.height / 2);
            this.vx = -(2 + Math.random() * 2);
            this.vy = 1 + Math.random();
        } else {
            // Top (預設)
            this.x = Math.random() * (canvas.width - this.w);
            this.y = -40;
            this.vx = (Math.random() - 0.5) * 1.5;
            this.vy = 2 + Math.random() * 3;
        }
    }
    update() {
        this.y += this.vy; this.x += this.vx;
        
        // 只有從上方出現的需要左右反彈，側面的就讓它飛過去
        if (this.vy > 0 && this.x > 0 && this.x < canvas.width - this.w) {
             // 進入畫面後才考慮邊界反彈
             if (this.x <= 0 || this.x >= canvas.width - this.w) this.vx *= -1;
        }

        if (this.y > canvas.height || this.x < -100 || this.x > canvas.width + 100) this.markedForDeletion = true;

        this.shootTimer--;
        if (this.shootTimer <= 0) {
            if (this.type === 'shooter') {
                // 瞄準玩家射擊
                let dx = player.x - this.x;
                let dy = player.y - this.y;
                let angle = Math.atan2(dy, dx);
                let speed = 5;
                enemyBullets.push(new Bullet(this.x + this.w/2, this.y + this.h, Math.cos(angle)*speed, Math.sin(angle)*speed, 'enemy'));
                this.shootTimer = 100;
            } else if (this.type === 'normal' && Math.random() < 0.2) {
                enemyBullets.push(new Bullet(this.x + this.w/2, this.y + this.h, 0, 4, 'enemy'));
                this.shootTimer = 150;
            }
        }
    }
    draw() {
        ctx.fillStyle = this.type === 'shooter' ? '#c0392b' : '#d35400';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = '#fff';
        // 根據移動方向畫眼睛
        let dir = this.vx > 0 ? 4 : -4;
        ctx.fillRect(this.x + 5 + dir, this.y + 10, 8, 5);
        ctx.fillRect(this.x + 18 + dir, this.y + 10, 8, 5);
    }
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            this.markedForDeletion = true;
            score += 100;
            killCount++;
            if (Math.random() < 0.15) { // 稍微提高掉寶率
                let itemType = Math.random() < 0.8 ? 'power' : 'bomb';
                items.push(new Item(this.x, this.y, itemType));
            }
            createExplosion(this.x + this.w/2, this.y + this.h/2, 20, '#FFA500', 5);
            updateUI();
        }
    }
}

class Boss {
    constructor(startX) {
        this.w = 80; this.h = 60;
        this.x = startX - 40; // 根據傳入的中心點位置調整
        this.y = -100;
        this.maxHp = 400 * level; // 因為有兩隻，血量稍微調低一點
        this.hp = this.maxHp;
        this.state = 'enter';
        this.timer = Math.floor(Math.random() * 100); // 讓兩隻 Boss 動作錯開
        this.moveDir = Math.random() > 0.5 ? 1 : -1;
        this.markedForDeletion = false;
    }
    update() {
        this.timer++;
        if (this.state === 'enter') {
            this.y += 2;
            if (this.y >= 50) this.state = 'idle';
        } else if (this.state === 'idle') {
            this.x += 1.5 * this.moveDir;
            if (this.x <= 0 || this.x >= canvas.width - this.w) this.moveDir *= -1;
            
            // 隨機移動反轉，避免太單調
            if (this.timer % 100 === 0 && Math.random() < 0.5) this.moveDir *= -1;

            if (this.timer % 150 === 0) {
                let rand = Math.random();
                if (rand < 0.4) this.state = 'prepare_laser';
                else if (rand < 0.7) this.state = 'summon';
                else this.state = 'spread_shot';
            }
        } else if (this.state === 'prepare_laser') {
            // 兩隻 Boss 可能同時放雷射，非常危險
            warningZones.push(new WarningZone(player.x - 25, 0, 80, canvas.height, 70));
            this.state = 'idle';
        } else if (this.state === 'summon') {
            // 召喚從旁邊衝出來的小兵
            enemies.push(new Enemy(Math.random() > 0.5 ? 'left' : 'right'));
            this.state = 'idle';
        } else if (this.state === 'spread_shot') {
            for(let i=-2; i<=2; i++) {
                enemyBullets.push(new Bullet(this.x + this.w/2, this.y + this.h, i*1.5, 4, 'enemy'));
            }
            this.state = 'idle';
        }
    }
    draw() {
        ctx.fillStyle = '#8e44ad';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(this.x + 10, this.y + 10, this.w - 20, 10);
        ctx.fillStyle = '#555';
        ctx.fillRect(this.x, this.y - 10, this.w, 5);
        ctx.fillStyle = '#e74c3c';
        ctx.fillRect(this.x, this.y - 10, this.w * (this.hp / this.maxHp), 5);
    }
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            score += 5000;
            createExplosion(this.x + this.w/2, this.y + this.h/2, 200, '#FFF', 50);
            this.markedForDeletion = true;
        }
    }
}

class WarningZone {
    constructor(x, y, w, h, duration) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.timer = duration; this.maxTimer = duration; this.active = true;
    }
    update() {
        this.timer--;
        if (this.timer <= 0) {
            if (rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
                player.takeDamage(30);
            }
            createExplosion(this.x + this.w/2, player.y, 50, '#FF4444', 10);
            this.active = false;
        }
    }
    draw() {
        ctx.save();
        let alpha = (this.timer / this.maxTimer) * 0.5 + 0.2;
        ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.strokeStyle = 'red';
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        ctx.restore();
    }
}

class Item {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
        this.w = 20; this.h = 20; this.vy = 2; this.markedForDeletion = false;
    }
    update() {
        this.y += this.vy;
        if (this.y > canvas.height) this.markedForDeletion = true;
        if (rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
            if (this.type === 'power') {
                // 修改：最高等級改為 5
                player.weaponLevel = Math.min(player.weaponLevel + 1, 5);
                score += 200;
            } else if (this.type === 'bomb') {
                player.bombs++;
            }
            updateUI();
            this.markedForDeletion = true;
        }
    }
    draw() {
        ctx.font = '20px Arial';
        if (this.type === 'power') {
            ctx.fillStyle = 'red';
            ctx.fillText('P', this.x, this.y + 20);
        } else {
            ctx.fillStyle = 'blue';
            ctx.fillText('B', this.x, this.y + 20);
        }
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 6; this.vy = (Math.random() - 0.5) * 6;
        this.life = 30; this.color = color;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw() { ctx.fillStyle = this.color; ctx.globalAlpha = this.life / 30; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha = 1; }
}

function createExplosion(x, y, count, color, range) {
    for(let i=0; i<count; i++) particles.push(new Particle(x + (Math.random()-0.5)*range, y + (Math.random()-0.5)*range, color));
}
function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}
function updateUI() {
    document.getElementById('score').innerText = `分數: ${score}`;
    document.getElementById('lives').innerText = `生命: ${player.lives}`;
    document.getElementById('bombs').innerText = `炸彈: ${player.bombs}`;
}
function initGame() {
    score = 0; level = 1; killCount = 0;
    player = new Player();
    resetLevel();
}
function resetLevel() {
    bullets = []; enemyBullets = []; enemies = []; items = []; particles = []; warningZones = [];
    bosses = []; // 重置 Boss 陣列
    gameState = 'PLAYING';
    updateUI();
}
function nextLevel() {
    level++; killCount = 0; player.hp = 100; resetLevel();
}

function gameLoop() {
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'MENU') {
        ctx.fillStyle = 'white';
        ctx.font = '30px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('忍者卷軸：雙鬼之亂', canvas.width/2, canvas.height/2 - 40);
        ctx.font = '20px sans-serif';
        ctx.fillText('點擊下方 Z 鍵開始', canvas.width/2, canvas.height/2 + 20);
    } 
    else if (gameState === 'PLAYING') {
        frameCount++;
        
        // 敵人生成邏輯：機率提高 (0.02 -> 0.04)，並加入側邊生成
        if (bosses.length === 0 && enemies.length < 8 + level && Math.random() < 0.04) {
            let spawnType = 'top';
            let r = Math.random();
            if (r < 0.15) spawnType = 'left';
            else if (r < 0.3) spawnType = 'right';
            
            enemies.push(new Enemy(spawnType));
        }

        // Boss 生成邏輯：同時生成兩隻
        if (bosses.length === 0 && killCount >= KILLS_TO_BOSS * level) {
            bosses.push(new Boss(canvas.width * 0.25)); // 左邊那隻
            bosses.push(new Boss(canvas.width * 0.75)); // 右邊那隻
        }

        player.update(); player.draw();

        // 更新 Bosses
        bosses.forEach((boss, i) => {
            boss.update();
            boss.draw();
            if (boss.markedForDeletion) {
                bosses.splice(i, 1);
                // 檢查是否全部 Boss 都死了
                if (bosses.length === 0) {
                    gameState = 'LEVEL_CLEAR';
                }
            }
        });

        warningZones.forEach((z, i) => { z.update(); z.draw(); if (!z.active) warningZones.splice(i, 1); });
        bullets.forEach((b, i) => { b.update(); b.draw(); if (b.markedForDeletion) bullets.splice(i, 1); });
        
        enemyBullets.forEach((b, i) => { 
            b.update(); b.draw(); 
            if (b.markedForDeletion) enemyBullets.splice(i, 1);
            else if (rectIntersect(b.x, b.y, b.r*2, b.r*2, player.x, player.y, player.w, player.h)) {
                player.takeDamage(10); b.markedForDeletion = true;
            }
        });
        
        enemies.forEach((e, i) => {
            e.update(); e.draw();
            if (e.markedForDeletion) enemies.splice(i, 1);
            else if (rectIntersect(e.x, e.y, e.w, e.h, player.x, player.y, player.w, player.h)) {
                player.takeDamage(20); e.takeDamage(10);
            }
        });
        
        items.forEach((item, i) => { item.update(); item.draw(); if (item.markedForDeletion) items.splice(i, 1); });
        particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });

        // 碰撞檢測：子彈 vs 敵人
        bullets.forEach(b => {
            enemies.forEach(e => {
                if (rectIntersect(b.x, b.y, 4, 10, e.x, e.y, e.w, e.h)) {
                    e.takeDamage(1); b.markedForDeletion = true;
                    createExplosion(b.x, b.y, 2, '#fff', 5);
                }
            });
            // 子彈 vs 所有 Boss
            bosses.forEach(boss => {
                if (rectIntersect(b.x, b.y, 4, 10, boss.x, boss.y, boss.w, boss.h)) {
                     boss.takeDamage(1); b.markedForDeletion = true;
                     createExplosion(b.x, b.y, 2, '#fff', 5);
                }
            });
        });
    } 
    else if (gameState === 'GAMEOVER') {
        ctx.fillStyle = 'red';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('勝敗乃兵家常事', canvas.width/2, canvas.height/2 - 20);
        ctx.fillStyle = 'white';
        ctx.font = '20px sans-serif';
        ctx.fillText('Z: 接關  |  X: 重來', canvas.width/2, canvas.height/2 + 40);
    }
    else if (gameState === 'LEVEL_CLEAR') {
        ctx.fillStyle = '#2ecc71';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`第 ${level} 關 鬼退治!`, canvas.width/2, canvas.height/2 - 20);
        ctx.font = '20px sans-serif';
        ctx.fillText('按 Z 進入下一關', canvas.width/2, canvas.height/2 + 40);
    }

    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

</script>
</body>
</html>
