<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯¶å¯å¤¢å°æˆ° V3.1: ç›´æ¥æ”»æ“Šå„ªåŒ–</title>
    <style>
        :root {
            --bg-color: #222;
            --p1-color: #3b82f6;
            --p2-color: #ef4444;
            --card-width: 80px;
            --card-height: 115px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- é–‹å§‹ç•«é¢ --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 2000;
        }
        .difficulty-btn {
            background: #333; color: #fff; border: 2px solid #555;
            padding: 15px 40px; margin: 10px; font-size: 18px;
            cursor: pointer; border-radius: 8px; width: 220px; transition: 0.2s;
        }
        .difficulty-btn:hover { transform: scale(1.05); }
        .diff-easy { border-color: #4caf50; } .diff-easy:hover { background: #4caf50; }
        .diff-mid { border-color: #ff9800; } .diff-mid:hover { background: #ff9800; }
        .diff-hard { border-color: #f44336; } .diff-hard:hover { background: #f44336; }

        /* --- éŠæˆ²ä¸»ç›¤é¢ --- */
        .game-board { flex: 1; display: flex; flex-direction: column; position: relative; }
        .player-zone { flex: 1; display: flex; flex-direction: column; padding: 5px 10px; position: relative; justify-content: space-between; transition: 0.3s;}
        
        .p2-zone { background: linear-gradient(to bottom, #1a1a1a, #2a1a1a); border-bottom: 2px solid #555; }
        .p1-zone { background: linear-gradient(to top, #1a1a1a, #1a2a3a); }
        .active-turn { box-shadow: inset 0 0 30px rgba(255, 255, 255, 0.15); }
        
        /* ç›´æ¥æ”»æ“Šæç¤ºæ¨£å¼ */
        .can-direct-attack {
            box-shadow: inset 0 0 50px rgba(255, 0, 0, 0.3) !important;
            cursor: crosshair;
            animation: dangerPulse 1s infinite;
        }
        @keyframes dangerPulse { 0% { background-color: rgba(255,0,0,0.05); } 50% { background-color: rgba(255,0,0,0.15); } 100% { background-color: rgba(255,0,0,0.05); } }

        .field-container { display: flex; flex-direction: column; gap: 2px; justify-content: center; }
        .field-row { display: flex; justify-content: center; gap: 8px; min-height: var(--card-height); align-items: center; padding: 2px; width: 100%; }
        .monster-zone { background-color: rgba(45, 74, 62, 0.6); border: 1px solid #3d5a4e; border-radius: 6px; }
        .st-zone { background-color: rgba(58, 42, 74, 0.6); border: 1px solid #4a3a5a; height: 90px; min-height: 90px; border-radius: 6px;}
        .hand-row { display: flex; justify-content: center; height: 110px; align-items: center; z-index: 20; padding: 5px; }

        /* --- å¡ç‰‡ --- */
        .card {
            width: var(--card-width); height: var(--card-height);
            background: #e0e0e0; border-radius: 5px; border: 2px solid #666;
            color: #000; display: flex; flex-direction: column; font-size: 9px;
            position: relative; cursor: pointer; transition: 0.2s; overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .hand-row .card { width: 70px; height: 100px; margin: 0 2px; border-color: #fff; }
        #p1-hand .card:hover { transform: translateY(-20px) scale(1.1); z-index: 50; }
        #p2-hand .card { background: #222; border-color: #444; }
        #p2-hand .card * { display: none; }
        #p2-hand .card::after { content: ''; position: absolute; top:0; left:0; width:100%; height:100%; background: repeating-linear-gradient(45deg, #b71c1c, #b71c1c 10px, #880e4f 10px, #880e4f 20px); }

        .card.selected { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; transform: scale(1.05); z-index: 40; }
        .card.tribute-target { border-color: #ff0000; box-shadow: 0 0 15px #ff0000; animation: pulse 1s infinite; }
        .card.ai-highlight { border-color: #ef4444; box-shadow: 0 0 20px #ef4444; transform: scale(1.1); z-index: 60; }
        
        .card-header { background: #d4af37; padding: 2px; font-weight: bold; text-align: center; border-bottom: 1px solid #000; white-space: nowrap; overflow: hidden; }
        .card-level { text-align: center; background: #eee; color: #000; font-size: 10px; line-height: 10px; letter-spacing: -1px;}
        .card-img { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 32px; background: #fff; }
        .card-stats { background: #f0f0f0; padding: 2px; display: flex; justify-content: space-between; border-top: 1px solid #000; font-weight: bold; font-size: 10px; }

        .card[data-cat="monster"] { border-color: #b8860b; }
        .card[data-cat="spell"] { border-color: #107c10; } .card[data-cat="spell"] .card-header { background: #107c10; color: white;}
        .card[data-cat="trap"] { border-color: #c71585; } .card[data-cat="trap"] .card-header { background: #c71585; color: white;}
        
        .card.facedown { background: #4a3b2a; border-color: #5d4037; }
        .card.facedown > * { visibility: hidden; }
        .card.facedown::after { content: ''; position: absolute; top:0; left:0; width:100%; height:100%; background: repeating-linear-gradient(45deg, #4a3b2a, #4a3b2a 10px, #3e3020 10px, #3e3020 20px); visibility: visible; }

        /* VFX */
        .slash-effect { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 99; display: none; }
        .slashing .slash-effect { display: block; animation: slashAnim 0.4s ease-out; background: linear-gradient(135deg, transparent 45%, red 50%, transparent 55%); background-size: 200% 200%; }
        
        .player-hit-effect { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 150; display: none; background: rgba(255,0,0,0.3); }
        .hit-anim { display: block !important; animation: hitFlash 0.3s; }
        @keyframes hitFlash { 0% { opacity: 0; } 50% { opacity: 1; background: rgba(255,0,0,0.5); } 100% { opacity: 0; } }
        
        @keyframes slashAnim { 0% { background-position: 200% 200%; opacity: 0; } 50% { opacity: 1; } 100% { background-position: -100% -100%; opacity: 0; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* UI */
        .info-panel { position: absolute; top: 50%; left: 0; transform: translateY(-50%); background: rgba(0,0,0,0.85); padding: 15px 10px; border-radius: 0 10px 10px 0; z-index: 100; border-left: 5px solid #ffd700; width: 120px;}
        .lp-display { font-family: 'Courier New', monospace; font-size: 18px; font-weight: bold; margin-bottom: 5px; position: relative;}
        .p1-lp { color: var(--p1-color); } .p2-lp { color: var(--p2-color); }
        .phase-box { text-align: center; margin-top: 5px; padding: 2px; border: 1px solid #666; color: #aaa; font-size: 10px; }
        .phase-box.active { color: #ffd700; border-color: #ffd700; font-weight: bold; background: #333; }
        
        .controls { position: absolute; top: 50%; right: 0; transform: translateY(-50%); display: flex; flex-direction: column; gap: 8px; z-index: 100; padding-right: 10px; }
        button { padding: 10px; font-size: 13px; cursor: pointer; background: #333; color: white; border: 1px solid #666; border-radius: 4px; width: 90px; }
        button:hover { background: #555; } button:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-battle { background: #8b0000; border-color: #ff4444; }
        .btn-end { background: #1e3a8a; border-color: #3b82f6; }

        .log-box { position: absolute; bottom: 0; left: 0; width: 100%; height: 30px; background: rgba(0,0,0,0.9); border-top: 1px solid #444; color: #ddd; font-size: 14px; line-height: 30px; padding-left: 10px; white-space: nowrap; overflow: hidden; z-index: 150; }
        #winner-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 999; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color: #ffd700; font-size: 40px; margin-bottom: 30px;">å¯¶å¯å¤¢æ±ºé¬¥ - å‚³èªªé™è‡¨</h1>
        <button class="difficulty-btn diff-easy" onclick="startGame('easy')">ç°¡å–® AI (æ²™åŒ…)</button>
        <button class="difficulty-btn diff-mid" onclick="startGame('medium')">æ™®é€š AI (è¨“ç·´å®¶)</button>
        <button class="difficulty-btn diff-hard" onclick="startGame('hard')">å›°é›£ AI (å† è»)</button>
    </div>

    <div class="info-panel">
        <div class="lp-display p2-lp">CPU: <span id="p2-lp">8000</span></div>
        <div class="lp-display p1-lp">YOU: <span id="p1-lp">8000</span></div>
        <div id="phase-draw" class="phase-box">æŠ½ç‰Œéšæ®µ</div>
        <div id="phase-main" class="phase-box">ä¸»è¦éšæ®µ</div>
        <div id="phase-battle" class="phase-box">æˆ°é¬¥éšæ®µ</div>
        <div style="font-size: 12px; margin-top:10px; color: #888;">é›£åº¦: <span id="diff-label"></span></div>
    </div>

    <div class="controls">
        <button id="btn-battle" class="btn-battle" onclick="game.enterBattlePhase()">âš”ï¸ æˆ°é¬¥</button>
        <button id="btn-end" class="btn-end" onclick="game.endTurn()">çµæŸå›åˆ â</button>
    </div>

    <div class="game-board">
        <div class="player-zone p2-zone" id="p2-zone">
            <div class="player-hit-effect" id="p2-hit-effect"></div>
            <div class="hand-row" id="p2-hand"></div>
            <div class="field-container">
                <div class="field-row st-zone" id="p2-st"></div>
                <div class="field-row monster-zone" id="p2-field"></div>
            </div>
        </div>

        <div class="player-zone p1-zone" id="p1-zone">
            <div class="player-hit-effect" id="p1-hit-effect"></div>
            <div class="field-container">
                <div class="field-row monster-zone" id="p1-field"></div>
                <div class="field-row st-zone" id="p1-st"></div>
            </div>
            <div class="hand-row" id="p1-hand"></div>
        </div>
    </div>

    <div class="log-box" id="game-log">è«‹é¸æ“‡é›£åº¦é–‹å§‹éŠæˆ²...</div>

    <div id="winner-overlay">
        <div id="winner-text" style="font-size:50px; color:#ffd700; margin-bottom:20px;"></div>
        <button onclick="location.reload()" style="font-size:20px; width:200px;">é‡æ–°é–‹å§‹</button>
    </div>

    <script>
        const CARD_DB = [
            // ä¸‹ç´š
            { id: 1, name: "å°ç«é¾", category: 'monster', level: 3, atk: 1200, def: 800, img: "ğŸ”¥" },
            { id: 2, name: "å‚‘å°¼é¾œ", category: 'monster', level: 3, atk: 1000, def: 1500, img: "ğŸ’§" },
            { id: 3, name: "å¦™è›™ç¨®å­", category: 'monster', level: 3, atk: 1100, def: 1100, img: "ğŸŒ¿" },
            { id: 4, name: "çš®å¡ä¸˜", category: 'monster', level: 4, atk: 1600, def: 800, img: "âš¡" },
            { id: 5, name: "å°æ‹³çŸ³", category: 'monster', level: 3, atk: 1100, def: 1800, img: "ğŸª¨" },
            { id: 6, name: "é¬¼æ–¯", category: 'monster', level: 2, atk: 1200, def: 200, img: "ğŸ‘»" },
            { id: 7, name: "è…•åŠ›", category: 'monster', level: 4, atk: 1700, def: 600, img: "ğŸ’ª" },
            { id: 8, name: "é¯‰é­šç‹", category: 'monster', level: 1, atk: 0, def: 0, img: "ğŸŸ" },
            // ä¸Šç´š
            { id: 20, name: "ç«æé¾", category: 'monster', level: 5, atk: 2100, def: 1400, img: "ğŸ”¥ğŸ”¥" },
            { id: 21, name: "å¡å’ªé¾œ", category: 'monster', level: 5, atk: 1900, def: 2000, img: "ğŸ’§ğŸ’§" },
            { id: 22, name: "é›·ä¸˜", category: 'monster', level: 6, atk: 2400, def: 1600, img: "âš¡âš¡" },
            { id: 23, name: "å¡æ¯”ç¸", category: 'monster', level: 6, atk: 2500, def: 2200, img: "ğŸ’¤" },
            // å‚³èªª
            { id: 40, name: "å™´ç«é¾", category: 'monster', level: 7, atk: 2800, def: 2000, img: "ğŸ²ğŸ”¥" },
            { id: 41, name: "æ°´ç®­é¾œ", category: 'monster', level: 7, atk: 2600, def: 3000, img: "ğŸ¢ğŸ’§" },
            { id: 42, name: "è¶…å¤¢", category: 'monster', level: 8, atk: 3300, def: 2000, img: "ğŸ‘½" },
            { id: 43, name: "çƒˆç©ºå", category: 'monster', level: 9, atk: 3500, def: 3000, img: "ğŸ‰ğŸŸ¢" },
            { id: 44, name: "å›ºæ‹‰å¤š", category: 'monster', level: 8, atk: 3400, def: 2500, img: "ğŸŒ‹" },
            // é­”æ³•é™·é˜±
            { id: 100, name: "å‚·è—¥", category: 'spell', effect: 'heal_1500', img: "ğŸ’Š", desc: "HP+1500" },
            { id: 101, name: "åŠ›é‡å¼·åŒ–", category: 'spell', effect: 'atk_up_600', img: "âš”ï¸", desc: "ATK+600" },
            { id: 102, name: "é›·æ“Š", category: 'spell', effect: 'destroy_one', img: "âš¡", desc: "ç ´å£å°æ‰‹ä¸€éš»æ€ªç¸" },
            { id: 200, name: "è®Šç¡¬", category: 'trap', effect: 'def_up', img: "ğŸ›¡ï¸", desc: "DEF+2000" },
            { id: 201, name: "é¡å£", category: 'trap', effect: 'destroy_atk', img: "âœ¨", desc: "ç ´å£æ”»æ“Šè€…" }
        ];

        class Card {
            constructor(data, owner) {
                this.uid = Math.random().toString(36).substr(2, 9);
                Object.assign(this, data);
                this.owner = owner;
                this.hasAttacked = false;
                this.isFacedown = false;
                this.tempAtkBuff = 0;
            }
            get currentAtk() { return (this.atk || 0) + this.tempAtkBuff; }
            
            render(location) {
                const el = document.createElement('div');
                el.className = 'card';
                el.dataset.uid = this.uid;
                el.dataset.cat = this.category;
                if(this.hasAttacked) el.classList.add('attacked');
                if(this.isFacedown && location !== 'hand') el.classList.add('facedown');
                
                let stars = '';
                if(this.category === 'monster') for(let i=0; i<this.level; i++) stars += 'â˜…';

                el.innerHTML = `
                    <div class="slash-effect"></div>
                    <div class="card-header">${this.name}</div>
                    ${this.category === 'monster' ? `<div class="card-level">${stars}</div>` : ''}
                    <div class="card-img">${this.img}</div>
                    <div class="card-stats">
                        ${this.category === 'monster' ? `<span>${this.currentAtk}</span><span>${this.def}</span>` : `<span style="width:100%;text-align:center">${this.desc}</span>`}
                    </div>
                `;
                el.onclick = (e) => {
                    e.stopPropagation(); // é˜²æ­¢é»æ“Šå¡ç‰‡æ™‚è§¸ç™¼å ´åœ°èƒŒæ™¯é»æ“Š
                    game.handleCardClick(this, location);
                };
                return el;
            }
        }

        class Game {
            constructor(difficulty) {
                this.difficulty = difficulty;
                this.turn = 'p1';
                this.phase = 'draw';
                this.players = {
                    p1: { lp: 8000, hand: [], field: [], st: [], deck: [] },
                    p2: { lp: 8000, hand: [], field: [], st: [], deck: [] }
                };
                this.selectedCard = null;
                this.summonState = { active: false, card: null, mode: null, need: 0, tributes: [] };
                this.turnSummoned = false;
                
                this.initDeck('p1'); this.initDeck('p2');
                for(let i=0; i<5; i++) { this.draw('p1'); this.draw('p2'); }
                
                document.getElementById('diff-label').innerText = difficulty.toUpperCase();
                this.startTurnP1();
            }

            log(msg) {
                const box = document.getElementById('game-log');
                box.innerText = msg;
                box.style.color = this.turn === 'p1' ? '#aaf' : '#faa';
            }

            initDeck(p) {
                for(let i=0; i<25; i++) {
                    const r = Math.random();
                    let cardData;
                    let legendChance = (p==='p2' && this.difficulty==='hard') ? 0.15 : 0.05;
                    let upperChance = 0.25;

                    if(r < legendChance) cardData = CARD_DB.filter(c=>c.level>=7)[Math.floor(Math.random()*5)];
                    else if (r < legendChance + upperChance) cardData = CARD_DB.filter(c=>c.level>=5 && c.level<=6)[Math.floor(Math.random()*4)];
                    else if (r < 0.8) cardData = CARD_DB.filter(c=>c.level<=4 && c.category==='monster')[Math.floor(Math.random()*8)];
                    else cardData = CARD_DB.filter(c=>c.category!=='monster')[Math.floor(Math.random()*5)];
                    
                    this.players[p].deck.push(cardData || CARD_DB[0]);
                }
            }

            draw(p) {
                if(this.players[p].deck.length === 0) return this.endGame(p==='p1'?'CPU':'YOU', "ç‰Œçµ„æŠ½ä¹¾");
                this.players[p].hand.push(new Card(this.players[p].deck.pop(), p));
                this.updateUI();
            }

            startTurnP1() {
                this.turn = 'p1';
                this.phase = 'draw';
                this.turnSummoned = false;
                this.selectedCard = null;
                this.summonState = { active: false, tributes: [] };
                this.resetBuffs();
                this.updateUI();
                
                this.log("[YOU] ä½ çš„å›åˆï¼ŒæŠ½ç‰Œï¼");
                setTimeout(() => {
                    this.draw('p1');
                    this.phase = 'main';
                    this.updateUI();
                }, 800);
            }

            async startTurnAI() {
                this.turn = 'p2';
                this.phase = 'draw';
                this.turnSummoned = false;
                this.selectedCard = null;
                this.resetBuffs();
                this.updateUI();
                this.log("[CPU] å°æ‰‹å›åˆï¼ŒæŠ½ç‰Œã€‚");
                
                await this.delay(1000);
                this.draw('p2');
                this.phase = 'main';
                this.updateUI();
                
                await this.delay(800);
                await this.aiMainPhase();
                
                await this.delay(800);
                this.phase = 'battle';
                this.updateUI();
                await this.aiBattlePhase();

                await this.delay(1000);
                this.endTurn();
            }

            async aiMainPhase() {
                const p2 = this.players.p2;
                if (!this.turnSummoned && p2.field.length < 5) {
                    const monsters = p2.hand.filter(c => c.category === 'monster');
                    if (this.difficulty === 'hard') monsters.sort((a,b) => b.level - a.level || b.atk - a.atk);
                    else monsters.sort((a,b) => 0.5 - Math.random());

                    for (let m of monsters) {
                        let canSummon = false;
                        let tributes = [];

                        if (m.level <= 4) {
                            canSummon = true;
                        } else if (m.level >= 5 && m.level <= 6) {
                            if (p2.field.length >= 1) {
                                canSummon = true;
                                tributes = [p2.field[0]];
                            }
                        } else if (m.level >= 7 && this.difficulty !== 'easy') {
                            const currentStars = p2.field.reduce((acc, c) => acc + c.level, 0);
                            if (currentStars > 9) {
                                canSummon = true;
                                let sum = 0;
                                for(let f of p2.field) { tributes.push(f); sum += f.level; if(sum > 9) break; }
                            }
                        }

                        if (canSummon) {
                            await this.highlightCard(m);
                            if (tributes.length > 0) tributes.forEach(t => this.removeCard(t));
                            this.deployCard(m, 'p2');
                            break; 
                        }
                    }
                }
                
                if (this.difficulty !== 'easy') {
                    const spells = p2.hand.filter(c => c.category === 'spell');
                    for (let s of spells) {
                        if (Math.random() > 0.5) { 
                            await this.highlightCard(s);
                            this.activateSpell(s, 'p2');
                            await this.delay(500);
                        }
                    }
                }
            }

            async aiBattlePhase() {
                const p2 = this.players.p2;
                const p1 = this.players.p1;
                
                for (let attacker of p2.field) {
                    if (attacker.hasAttacked) continue;
                    let target = null;
                    
                    if (p1.field.length === 0) {
                        target = 'direct';
                    } else {
                        if (this.difficulty === 'easy') target = p1.field[Math.floor(Math.random() * p1.field.length)];
                        else {
                            const killable = p1.field.filter(def => attacker.currentAtk > def.def);
                            if (killable.length > 0) target = killable.sort((a,b) => b.atk - a.atk)[0];
                            else if (this.difficulty === 'hard') target = null;
                            else if(Math.random() > 0.7) target = p1.field[0];
                        }
                    }

                    if (target) {
                        await this.highlightCard(attacker);
                        if (target === 'direct') await this.directAttack(attacker);
                        else await this.combat(attacker, target);
                        await this.delay(800);
                        if (this.checkWin()) return;
                    }
                }
            }

            async highlightCard(card) {
                const el = document.querySelector(`.card[data-uid="${card.uid}"]`);
                if (el) {
                    el.classList.add('ai-highlight');
                    await this.delay(600);
                    el.classList.remove('ai-highlight');
                }
            }

            handleCardClick(card, loc) {
                if (this.turn !== 'p1') return;

                // ç»ç¥­è™•ç†
                if (this.summonState.active && loc === 'field' && card.owner === 'p1') {
                    if(!this.summonState.tributes.find(c=>c.uid===card.uid)) {
                        this.summonState.tributes.push(card);
                        let conditionMet = false;
                        if (this.summonState.mode === 'count') conditionMet = this.summonState.tributes.length >= this.summonState.need;
                        else if (this.summonState.mode === 'stars') conditionMet = this.summonState.tributes.reduce((a,b)=>a+b.level, 0) > 9;

                        if (conditionMet) {
                            this.summonState.tributes.forEach(t => this.removeCard(t));
                            this.deployCard(this.summonState.card, 'p1');
                            this.summonState = { active: false, tributes: [] };
                        }
                        this.updateUI();
                    }
                    return;
                }

                // å¬å–šè™•ç†
                if (loc === 'hand' && this.phase === 'main') {
                    if (card.category === 'monster') {
                        if (this.turnSummoned) { this.log("æœ¬å›åˆå·²å¬å–šé"); return; }
                        if (this.players.p1.field.length >= 5) { this.log("å ´åœ°å·²æ»¿"); return; }

                        let mode = null; let need = 0;
                        if (card.level >= 7) { mode = 'stars'; need = 9; }
                        else if (card.level >= 5) { mode = 'count'; need = 1; }

                        if (need > 0 || mode) {
                            if (mode === 'count' && this.players.p1.field.length < need) { this.log("ç¥­å“ä¸è¶³"); return; }
                            if (mode === 'stars' && this.players.p1.field.reduce((a,b)=>a+b.level, 0) <= 9) { this.log("å ´ä¸Šæ€ªç¸ç¸½æ˜Ÿæ•¸ä¸è¶³ 10ï¼"); return; }
                            this.summonState = { active: true, card: card, mode: mode, need: need, tributes: [] };
                            this.log(mode === 'stars' ? "è«‹é¸æ“‡ç¥­å“ç›´åˆ°ç¸½æ˜Ÿæ•¸è¶…é 9" : "è«‹é¸æ“‡ 1 éš»ç¥­å“");
                            this.updateUI();
                        } else this.deployCard(card, 'p1');
                    }
                    else if (card.category === 'spell') this.activateSpell(card, 'p1');
                    else if (card.category === 'trap') this.setCard(card, 'p1');
                }

                // æˆ°é¬¥è™•ç†
                if (this.phase === 'battle') {
                    if (loc === 'field') {
                        if (card.owner === 'p1' && !card.hasAttacked) {
                            this.selectedCard = card;
                            this.log("é¸æ“‡äº†æ”»æ“Šæ€ªç¸ï¼Œé»æ“Šç›®æ¨™ (è‹¥å°æ–¹ç„¡æ€ªç¸å¯é»æ“Šå°æ–¹èƒŒæ™¯ç›´æ¥æ”»æ“Š)");
                            this.updateUI();
                        } else if (card.owner === 'p2' && this.selectedCard) {
                            this.combat(this.selectedCard, card);
                        }
                    }
                }
            }

            deployCard(card, p) {
                const player = this.players[p];
                player.hand = player.hand.filter(c => c.uid !== card.uid);
                player.field.push(card);
                if(p === this.turn) this.turnSummoned = true;
                this.log(`[${p==='p1'?'YOU':'CPU'}] å¬å–š ${card.name}`);
                this.updateUI();
            }

            setCard(card, p) {
                const player = this.players[p];
                if(player.st.length >= 5) return;
                player.hand = player.hand.filter(c => c.uid !== card.uid);
                card.isFacedown = true;
                player.st.push(card);
                this.log(`[${p==='p1'?'YOU':'CPU'}] è¦†è“‹ä¸€å¼µå¡`);
                this.updateUI();
            }

            activateSpell(card, p) {
                this.players[p].hand = this.players[p].hand.filter(c => c.uid !== card.uid);
                this.log(`é­”æ³•ç™¼å‹•: ${card.name}`);
                if(card.effect === 'heal_1500') this.players[p].lp += 1500;
                if(card.effect === 'atk_up_600') this.players[p].field.forEach(c=>c.tempAtkBuff+=600);
                if(card.effect === 'destroy_one') {
                    const opp = p==='p1'?'p2':'p1';
                    if(this.players[opp].field.length > 0) this.removeCard(this.players[opp].field[0]);
                }
                this.updateUI();
            }

            async combat(attacker, target) {
                attacker.hasAttacked = true;
                this.selectedCard = null;
                this.updateUI();

                const opp = target.owner;
                const traps = this.players[opp].st.filter(c => c.category === 'trap' && c.isFacedown);
                if (traps.length > 0) {
                    if (Math.random() > 0.3) {
                        const trap = traps[0];
                        trap.isFacedown = false;
                        this.log(`é™·é˜±è§¸ç™¼: ${trap.name}`);
                        this.updateUI();
                        await this.delay(800);
                        this.removeCard(trap, 'st');
                        if (trap.effect === 'destroy_atk') {
                            this.removeCard(attacker);
                            this.log("æ”»æ“Šè€…è¢«ç ´å£ï¼");
                            return;
                        }
                        if (trap.effect === 'def_up') target.def += 2000;
                    }
                }

                const el = document.querySelector(`.card[data-uid="${target.uid}"]`);
                if(el) { el.classList.add('slashing'); await this.delay(400); el.classList.remove('slashing'); }

                if (attacker.currentAtk > target.def) {
                    const dmg = attacker.currentAtk - target.def;
                    this.players[opp].lp = Math.max(0, this.players[opp].lp - dmg);
                    this.removeCard(target);
                    this.log(`æ“Šç ´ï¼å‚·å®³ ${dmg}`);
                } else if (attacker.currentAtk < target.def) {
                    const dmg = target.def - attacker.currentAtk;
                    this.players[attacker.owner].lp = Math.max(0, this.players[attacker.owner].lp - dmg);
                    this.log(`ç„¡æ³•æ“Šç©¿ï¼åå‚· ${dmg}`);
                }
                this.updateUI();
                this.checkWin();
            }

            async directAttack(attacker) {
                const opp = attacker.owner === 'p1' ? 'p2' : 'p1';
                attacker.hasAttacked = true;
                this.selectedCard = null;
                const dmg = attacker.currentAtk;
                this.players[opp].lp = Math.max(0, this.players[opp].lp - dmg);
                
                // æ’­æ”¾ç©å®¶å—æ“Šç‰¹æ•ˆ
                const hitEffect = document.getElementById(`${opp}-hit-effect`);
                if(hitEffect) {
                    hitEffect.classList.add('hit-anim');
                    setTimeout(() => hitEffect.classList.remove('hit-anim'), 300);
                }

                this.log(`${attacker.name} ç›´æ¥æ”»æ“Šç©å®¶ï¼å‚·å®³ ${dmg}`);
                this.updateUI();
                this.checkWin();
            }

            removeCard(card, zone='field') {
                const p = this.players[card.owner];
                if(zone==='field') p.field = p.field.filter(c => c.uid !== card.uid);
                else p.st = p.st.filter(c => c.uid !== card.uid);
                this.updateUI();
            }

            resetBuffs() {
                ['p1','p2'].forEach(p => this.players[p].field.forEach(c => { c.hasAttacked=false; c.tempAtkBuff=0; }));
            }

            checkWin() {
                if (this.players.p1.lp <= 0) return this.endGame('CPU', 'ä½ è¼¸äº†ï¼');
                if (this.players.p2.lp <= 0) return this.endGame('YOU', 'ä½ è´äº†ï¼');
                return false;
            }

            endGame(winner, msg) {
                document.getElementById('winner-overlay').style.display = 'flex';
                document.getElementById('winner-text').innerHTML = `${winner} WIN<br><span style="font-size:24px">${msg}</span>`;
                return true;
            }

            endTurn() {
                if(this.turn === 'p1') this.startTurnAI();
                else this.startTurnP1();
            }

            enterBattlePhase() { 
                if(this.phase==='main' && this.turn==='p1') { 
                    this.phase='battle'; 
                    this.log("é€²å…¥æˆ°é¬¥éšæ®µï¼Œè«‹é»æ“Šæ€ªç¸é€²è¡Œæ”»æ“Š"); 
                    this.updateUI(); 
                } 
            }

            delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

            updateUI() {
                document.getElementById('p1-lp').innerText = this.players.p1.lp;
                document.getElementById('p2-lp').innerText = this.players.p2.lp;
                
                document.querySelectorAll('.phase-box').forEach(e => e.classList.remove('active'));
                if(document.getElementById(`phase-${this.phase}`)) document.getElementById(`phase-${this.phase}`).classList.add('active');
                if(this.phase === 'main' && this.turn === 'p1') document.getElementById('phase-main').classList.add('active'); 

                document.getElementById('p1-zone').className = `player-zone p1-zone ${this.turn==='p1'?'active-turn':''}`;
                document.getElementById('p2-zone').className = `player-zone p2-zone ${this.turn==='p2'?'active-turn':''}`;
                
                // ç›´æ¥æ”»æ“Šè¦–è¦ºæç¤º
                if (this.turn === 'p1' && this.phase === 'battle' && this.selectedCard && this.players.p2.field.length === 0) {
                    document.getElementById('p2-zone').classList.add('can-direct-attack');
                } else {
                    document.getElementById('p2-zone').classList.remove('can-direct-attack');
                }

                document.getElementById('btn-battle').disabled = (this.turn !== 'p1' || this.phase !== 'main');
                document.getElementById('btn-end').disabled = (this.turn !== 'p1');

                const render = (id, list, loc) => {
                    const div = document.getElementById(id);
                    div.innerHTML = '';
                    list.forEach(c => {
                        const el = c.render(loc);
                        if(this.selectedCard?.uid === c.uid) el.classList.add('selected');
                        if(this.summonState.active && loc==='field' && c.owner==='p1') {
                            if(this.summonState.tributes.find(t=>t.uid===c.uid)) el.classList.add('tribute-target');
                            else { el.style.borderColor='#0f0'; el.style.boxShadow='0 0 5px #0f0'; }
                        }
                        div.appendChild(el);
                    });
                };

                render('p1-hand', this.players.p1.hand, 'hand');
                render('p1-field', this.players.p1.field, 'field');
                render('p1-st', this.players.p1.st, 'st');
                render('p2-hand', this.players.p2.hand, 'hand');
                render('p2-field', this.players.p2.field, 'field');
                render('p2-st', this.players.p2.st, 'st');
            }
        }

        let game;
        function startGame(diff) {
            document.getElementById('start-screen').style.display = 'none';
            game = new Game(diff);
        }

        // P1 ç›´æ¥æ”»æ“Šè§¸ç™¼äº‹ä»¶ (é»æ“Š P2 å€åŸŸèƒŒæ™¯)
        document.getElementById('p2-zone').addEventListener('click', (e) => {
            // ç¢ºä¿ä¸æ˜¯é»åˆ°å¡ç‰‡ (å¡ç‰‡è‡ªå·±æœ‰ onclick)
            if (e.target.closest('.card')) return;

            if(game && game.turn==='p1' && game.phase==='battle' && game.selectedCard) {
                if(game.players.p2.field.length === 0) {
                    game.directAttack(game.selectedCard);
                } else {
                    game.log("å°æ–¹å ´ä¸Šé‚„æœ‰æ€ªç¸ï¼Œä¸èƒ½ç›´æ¥æ”»æ“Šï¼");
                }
            }
        });

    </script>
</body>
</html>
