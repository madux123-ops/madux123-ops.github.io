<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯¶å¯å¤¢å°æˆ° V4: ç™¾å¡äº‚é¬¥</title>
    <style>
        :root {
            --bg-color: #222;
            --p1-color: #3b82f6;
            --p2-color: #ef4444;
            --card-width: 80px;
            --card-height: 115px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- é–‹å§‹ç•«é¢ --- */
        #start-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 2000;
        }
        .difficulty-btn {
            background: #333; color: #fff; border: 2px solid #555;
            padding: 15px 40px; margin: 10px; font-size: 18px;
            cursor: pointer; border-radius: 8px; width: 250px; transition: 0.2s;
            display: flex; justify-content: space-between;
        }
        .difficulty-btn:hover { transform: scale(1.05); }
        .diff-easy { border-color: #4caf50; } .diff-easy:hover { background: #4caf50; }
        .diff-mid { border-color: #ff9800; } .diff-mid:hover { background: #ff9800; }
        .diff-hard { border-color: #f44336; } .diff-hard:hover { background: #f44336; }

        /* --- éŠæˆ²ä¸»ç›¤é¢ --- */
        .game-board { flex: 1; display: flex; flex-direction: column; position: relative; }
        .player-zone { flex: 1; display: flex; flex-direction: column; padding: 5px 10px; position: relative; justify-content: space-between; transition: 0.3s;}
        
        .p2-zone { background: linear-gradient(to bottom, #1a1a1a, #2a1a1a); border-bottom: 2px solid #555; }
        .p1-zone { background: linear-gradient(to top, #1a1a1a, #1a2a3a); }
        .active-turn { box-shadow: inset 0 0 30px rgba(255, 255, 255, 0.15); }
        
        /* ç›´æ¥æ”»æ“Šæç¤ºæ¨£å¼ */
        .can-direct-attack {
            box-shadow: inset 0 0 50px rgba(255, 0, 0, 0.3) !important;
            cursor: crosshair;
            animation: dangerPulse 1s infinite;
        }
        @keyframes dangerPulse { 0% { background-color: rgba(255,0,0,0.05); } 50% { background-color: rgba(255,0,0,0.15); } 100% { background-color: rgba(255,0,0,0.05); } }

        .field-container { display: flex; flex-direction: column; gap: 2px; justify-content: center; }
        .field-row { display: flex; justify-content: center; gap: 8px; min-height: var(--card-height); align-items: center; padding: 2px; width: 100%; }
        .monster-zone { background-color: rgba(45, 74, 62, 0.6); border: 1px solid #3d5a4e; border-radius: 6px; }
        .st-zone { background-color: rgba(58, 42, 74, 0.6); border: 1px solid #4a3a5a; height: 90px; min-height: 90px; border-radius: 6px;}
        .hand-row { display: flex; justify-content: center; height: 110px; align-items: center; z-index: 20; padding: 5px; }

        /* --- å¡ç‰‡ --- */
        .card {
            width: var(--card-width); height: var(--card-height);
            background: #e0e0e0; border-radius: 5px; border: 2px solid #666;
            color: #000; display: flex; flex-direction: column; font-size: 9px;
            position: relative; cursor: pointer; transition: 0.2s; overflow: hidden;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }
        .hand-row .card { width: 70px; height: 100px; margin: 0 2px; border-color: #fff; }
        #p1-hand .card:hover { transform: translateY(-20px) scale(1.1); z-index: 50; }
        #p2-hand .card { background: #222; border-color: #444; }
        #p2-hand .card * { display: none; }
        #p2-hand .card::after { content: ''; position: absolute; top:0; left:0; width:100%; height:100%; background: repeating-linear-gradient(45deg, #b71c1c, #b71c1c 10px, #880e4f 10px, #880e4f 20px); }

        .card.selected { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; transform: scale(1.05); z-index: 40; }
        .card.tribute-target { border-color: #ff0000; box-shadow: 0 0 15px #ff0000; animation: pulse 1s infinite; }
        .card.ai-highlight { border-color: #ef4444; box-shadow: 0 0 20px #ef4444; transform: scale(1.1); z-index: 60; }
        
        .card-header { background: #d4af37; padding: 2px; font-weight: bold; text-align: center; border-bottom: 1px solid #000; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .card-level { text-align: center; background: #eee; color: #000; font-size: 10px; line-height: 10px; letter-spacing: -1px;}
        .card-img { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 32px; background: #fff; }
        .card-stats { background: #f0f0f0; padding: 2px; display: flex; justify-content: space-between; border-top: 1px solid #000; font-weight: bold; font-size: 10px; }

        .card[data-cat="monster"] { border-color: #b8860b; }
        .card[data-cat="spell"] { border-color: #107c10; } .card[data-cat="spell"] .card-header { background: #107c10; color: white;}
        .card[data-cat="trap"] { border-color: #c71585; } .card[data-cat="trap"] .card-header { background: #c71585; color: white;}
        
        .card.facedown { background: #4a3b2a; border-color: #5d4037; }
        .card.facedown > * { visibility: hidden; }
        .card.facedown::after { content: ''; position: absolute; top:0; left:0; width:100%; height:100%; background: repeating-linear-gradient(45deg, #4a3b2a, #4a3b2a 10px, #3e3020 10px, #3e3020 20px); visibility: visible; }

        /* VFX */
        .slash-effect { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 99; display: none; }
        .slashing .slash-effect { display: block; animation: slashAnim 0.4s ease-out; background: linear-gradient(135deg, transparent 45%, red 50%, transparent 55%); background-size: 200% 200%; }
        
        .player-hit-effect { position: absolute; top:0; left:0; width:100%; height:100%; pointer-events: none; z-index: 150; display: none; background: rgba(255,0,0,0.3); }
        .hit-anim { display: block !important; animation: hitFlash 0.3s; }
        @keyframes hitFlash { 0% { opacity: 0; } 50% { opacity: 1; background: rgba(255,0,0,0.5); } 100% { opacity: 0; } }
        
        @keyframes slashAnim { 0% { background-position: 200% 200%; opacity: 0; } 50% { opacity: 1; } 100% { background-position: -100% -100%; opacity: 0; } }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* UI */
        .info-panel { position: absolute; top: 50%; left: 0; transform: translateY(-50%); background: rgba(0,0,0,0.85); padding: 15px 10px; border-radius: 0 10px 10px 0; z-index: 100; border-left: 5px solid #ffd700; width: 130px;}
        .lp-display { font-family: 'Courier New', monospace; font-size: 16px; font-weight: bold; margin-bottom: 5px; position: relative;}
        .p1-lp { color: var(--p1-color); } .p2-lp { color: var(--p2-color); }
        .phase-box { text-align: center; margin-top: 5px; padding: 2px; border: 1px solid #666; color: #aaa; font-size: 10px; }
        .phase-box.active { color: #ffd700; border-color: #ffd700; font-weight: bold; background: #333; }
        
        .controls { position: absolute; top: 50%; right: 0; transform: translateY(-50%); display: flex; flex-direction: column; gap: 8px; z-index: 100; padding-right: 10px; }
        button { padding: 10px; font-size: 13px; cursor: pointer; background: #333; color: white; border: 1px solid #666; border-radius: 4px; width: 90px; }
        button:hover { background: #555; } button:disabled { opacity: 0.4; cursor: not-allowed; }
        .btn-battle { background: #8b0000; border-color: #ff4444; }
        .btn-end { background: #1e3a8a; border-color: #3b82f6; }

        .log-box { position: absolute; bottom: 0; left: 0; width: 100%; height: 30px; background: rgba(0,0,0,0.9); border-top: 1px solid #444; color: #ddd; font-size: 14px; line-height: 30px; padding-left: 10px; white-space: nowrap; overflow: hidden; z-index: 150; }
        #winner-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 999; }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1 style="color: #ffd700; font-size: 40px; margin-bottom: 20px;">å¯¶å¯å¤¢æ±ºé¬¥ V4</h1>
        <p style="color: #ccc; margin-bottom: 30px;">å…¨éš¨æ©Ÿç™¾å¡å°æˆ°ãƒ»ç‰Œçµ„æ˜Ÿæ•¸å‹•æ…‹å¹³è¡¡ç³»çµ±</p>
        <div class="difficulty-btn diff-easy" onclick="startGame('easy')"><span>ç°¡å–® (æ²™åŒ…)</span><span>æ˜Ÿæ•¸: 1.0x</span></div>
        <div class="difficulty-btn diff-mid" onclick="startGame('medium')"><span>æ™®é€š (è¨“ç·´å®¶)</span><span>æ˜Ÿæ•¸: 1.2x</span></div>
        <div class="difficulty-btn diff-hard" onclick="startGame('hard')"><span>å›°é›£ (å† è»)</span><span>æ˜Ÿæ•¸: 1.5x</span></div>
    </div>

    <div class="info-panel">
        <div class="lp-display p2-lp">CPU: <span id="p2-lp">8000</span></div>
        <div class="lp-display p1-lp">YOU: <span id="p1-lp">8000</span></div>
        <div id="phase-draw" class="phase-box">æŠ½ç‰Œéšæ®µ</div>
        <div id="phase-main" class="phase-box">ä¸»è¦éšæ®µ</div>
        <div id="phase-battle" class="phase-box">æˆ°é¬¥éšæ®µ</div>
        <div style="font-size: 11px; margin-top:10px; color: #888;">é›£åº¦: <span id="diff-label"></span></div>
        <div style="font-size: 10px; margin-top:2px; color: #666;" id="debug-stars"></div>
    </div>

    <div class="controls">
        <button id="btn-battle" class="btn-battle" onclick="game.enterBattlePhase()">âš”ï¸ æˆ°é¬¥</button>
        <button id="btn-end" class="btn-end" onclick="game.endTurn()">çµæŸå›åˆ â</button>
    </div>

    <div class="game-board">
        <div class="player-zone p2-zone" id="p2-zone">
            <div class="player-hit-effect" id="p2-hit-effect"></div>
            <div class="hand-row" id="p2-hand"></div>
            <div class="field-container">
                <div class="field-row st-zone" id="p2-st"></div>
                <div class="field-row monster-zone" id="p2-field"></div>
            </div>
        </div>

        <div class="player-zone p1-zone" id="p1-zone">
            <div class="player-hit-effect" id="p1-hit-effect"></div>
            <div class="field-container">
                <div class="field-row monster-zone" id="p1-field"></div>
                <div class="field-row st-zone" id="p1-st"></div>
            </div>
            <div class="hand-row" id="p1-hand"></div>
        </div>
    </div>

    <div class="log-box" id="game-log">æ­£åœ¨æ´—åˆ‡ 100+ å¼µå¡ç‰‡ï¼Œæ§‹å»ºéš¨æ©Ÿç‰Œçµ„...</div>

    <div id="winner-overlay">
        <div id="winner-text" style="font-size:50px; color:#ffd700; margin-bottom:20px;"></div>
        <button onclick="location.reload()" style="font-size:20px; width:200px;">é‡æ–°é–‹å§‹</button>
    </div>

    <script>
        // --- V4 è³‡æ–™åº«: 100+ å¯¶å¯å¤¢ ---
        // æ ¼å¼: [Name, Level, Atk, Def, Emoji]
        const RAW_MONSTERS = [
            // Level 1-2 (é›œé­š/å¹¼å¹´)
            ["é¯‰é­šç‹",1,0,0,"ğŸŸ"], ["ç¶ æ¯›èŸ²",1,300,300,"ğŸ›"], ["ç¨è§’èŸ²",1,350,300,"ğŸ›"], ["æ³¢æ³¢",2,800,600,"ğŸ¦"], ["å°æ‹‰é”",2,900,600,"ğŸ€"],
            ["çƒˆé›€",2,1000,500,"ğŸ¦"], ["è¶…éŸ³è ",2,900,700,"ğŸ¦‡"], ["èµ°è·¯è‰",2,800,800,"ğŸŒ±"], ["æ´¾æ‹‰æ–¯",2,700,900,"ğŸ¦€"], ["æ¯›çƒ",2,850,700,"ğŸ¦Ÿ"],
            ["åœ°é¼ ",2,1100,300,"ğŸ¹"], ["å–µå–µ",2,1000,800,"ğŸ˜¸"], ["å¯é”é´¨",2,1100,900,"ğŸ¦†"], ["çŒ´æ€ª",2,1300,500,"ğŸ’"], ["å¡è’‚ç‹—",2,1200,800,"ğŸ¶"],
            ["èšŠé¦™èŒèšª",2,900,900,"ğŸŒ€"], ["å‡±è¥¿",1,500,1500,"ğŸ§˜"], ["è…•åŠ›",3,1600,800,"ğŸ’ª"], ["å–‡å­èŠ½",2,1000,600,"ğŸŒ±"], ["ç‘ªç‘™æ°´æ¯",2,900,1200,"ğŸ¦‘"],
            
            // Level 3-4 (ä¸‹ç´šä¸»åŠ›)
            ["å°ç«é¾",3,1200,800,"ğŸ”¥"], ["å‚‘å°¼é¾œ",3,1000,1500,"ğŸ’§"], ["å¦™è›™ç¨®å­",3,1100,1100,"ğŸŒ¿"], ["çš®å¡ä¸˜",4,1600,800,"âš¡"], ["å°æ‹³çŸ³",3,1100,1600,"ğŸª¨"],
            ["å°ç´…é¦¬",3,1500,1000,"ğŸ´"], ["å‘†å‘†ç¸",3,1000,1500,"ğŸ¦›"], ["å°ç£æ€ª",3,1100,1400,"ğŸ§²"], ["å¤§è”¥é´¨",3,1400,900,"ğŸ¦†"], ["å˜Ÿå˜Ÿ",3,1500,800,"ğŸ¦"],
            ["å°æµ·ç…",3,1200,1200,"ğŸ¦­"], ["è‡­æ³¥",3,1300,1300,"ğŸ’©"], ["å¤§èˆŒè²",3,1000,1800,"ğŸš"], ["é¬¼æ–¯",3,1300,300,"ğŸ‘»"], ["å¤§å²©è›‡",4,1400,2000,"ğŸ"],
            ["å‚¬çœ è²˜",3,1200,1200,"ğŸ˜"], ["å¤§é‰—èŸ¹",3,1700,1100,"ğŸ¦€"], ["é›·é›»çƒ",3,1400,1000,"ğŸ’£"], ["è›‹è›‹",3,1100,1100,"ğŸ¥š"], ["å¡æ‹‰å¡æ‹‰",3,1300,1500,"ğŸ¦´"],
            ["ç“¦æ–¯å½ˆ",3,1200,1400,"ğŸ¦ "], ["å¢¨æµ·é¦¬",3,1100,1000," Seahorse"], ["è§’é‡‘é­š",3,1300,900,"ğŸ "], ["æµ·æ˜Ÿæ˜Ÿ",3,1400,1000,"â­"], ["é£›å¤©è³è‚",4,1800,1200,"ğŸ¦—"],
            ["è¿·å”‡å§",4,1600,1200,"ğŸ’‹"], ["é›»æ“Šç¸",4,1700,1300,"âš¡"], ["é´¨å˜´ç«é¾",4,1800,1100,"ğŸ”¥"], ["å¤§ç”²",4,1850,1500,"ğŸª²"], ["è‚¯æ³°ç¾…",4,1900,1400,"ğŸ‚"],
            ["ä¼Šå¸ƒ",3,1300,1300,"ğŸ•"], ["æ°´ä¼Šå¸ƒ",4,1700,1900,"ğŸ’§"], ["é›·ä¼Šå¸ƒ",4,1800,1200,"âš¡"], ["ç«ä¼Šå¸ƒ",4,1900,1100,"ğŸ”¥"], ["å¤šé‚Šç¸",3,1400,1400,"ğŸ§Š"],
            
            // Level 5-6 (ä¸Šç´šæ€ªç¸ - éœ€1ç¥­å“)
            ["ç«æé¾",5,2100,1400,"ğŸ”¥ğŸ”¥"], ["å¡å’ªé¾œ",5,1900,2000,"ğŸ’§ğŸ’§"], ["å¦™è›™è‰",5,2000,1800,"ğŸŒ¿ğŸŒ¿"], ["å·´å¤§è¶",5,1600,1600,"ğŸ¦‹"], ["å¤§é‡èœ‚",5,1800,1200,"ğŸ"],
            ["æ¯”é›•",6,2200,1500,"ğŸ¦…"], ["æ‹‰é”",5,1800,1400,"ğŸ€"], ["å¤§å˜´é›€",5,2000,1400,"ğŸ¦…"], ["é˜¿æŸæ€ª",5,2100,1500,"ğŸ"], ["çš®å¯è¥¿",6,2000,2000,"ğŸ§š"],
            ["ä¹å°¾",6,2200,1800,"ğŸ¦Š"], ["èƒ–å¯ä¸",5,1800,2200,"ğŸˆ"], ["å¤§å˜´è ",5,1900,1600,"ğŸ¦‡"], ["éœ¸ç‹èŠ±",6,2100,1900,"ğŸŒº"], ["æ´¾æ‹‰æ–¯ç‰¹",5,1900,1800,"ğŸ„"],
            ["æœ«å…¥è›¾",5,2000,1500,"ğŸ¦‹"], ["ä¸‰åœ°é¼ ",5,2100,1200,"ğŸ¹"], ["è²“è€å¤§",5,1900,1400,"ğŸ†"], ["å“¥é”é´¨",6,2300,1800,"ğŸ¦†"], ["ç«çˆ†çŒ´",5,2200,1300,"ğŸ¦"],
            ["é¢¨é€Ÿç‹—",6,2500,1800,"ğŸ•"], ["èšŠé¦™æ³³å£«",6,2200,2100,"ğŸ¸"], ["èƒ¡åœ°",6,2500,1500,"ğŸ¥„"], ["æ€ªåŠ›",6,2600,1800,"ğŸ’ª"], ["å¤§é£ŸèŠ±",5,2100,1400,"ğŸŒ±"],
            ["æ¯’åˆºæ°´æ¯",6,2000,2200,"ğŸ¦‘"], ["éš†éš†å²©",6,2300,2300,"ğŸª¨"], ["çƒˆç„°é¦¬",5,2200,1600,"ğŸ´"], ["å‘†æ®¼ç¸",6,2000,2400,"ğŸš"], ["ä¸‰åˆä¸€ç£æ€ª",5,2100,1800,"ğŸ§²"],
            ["å˜Ÿå˜Ÿåˆ©",5,2300,1500,"ğŸ¦"], ["ç™½æµ·ç…",6,2000,2200,"ğŸ¦­"], ["è‡­è‡­æ³¥",6,2200,2000,"ğŸ’©"], ["åˆºç”²è²",6,1900,2800,"ğŸš"], ["è€¿é¬¼",6,2400,1500,"ğŸ˜ˆ"],
            ["ç´¢åˆ©æŸ",5,2000,1900,"ğŸ˜"], ["å·¨é‰—èŸ¹",5,2400,1800,"ğŸ¦€"], ["é ‘çš®é›·å½ˆ",5,1800,1800,"ğŸ’£"], ["æ¤°è›‹æ¨¹",6,2500,1900,"ğŸŒ´"], ["å˜å•¦å˜å•¦",5,2000,2200,"ğŸ¦´"],
            ["æ²™ç“¦éƒ",5,2300,1200,"ğŸ¦µ"], ["è‰¾æ¯”éƒ",5,2200,1600,"ğŸ¥Š"], ["é›™å½ˆç“¦æ–¯",5,2000,2200,"ğŸ¦ "], ["éµç”²æš´é¾",6,2500,2200,"ğŸ¦"], ["å‰åˆ©è›‹",5,500,3000,"ğŸ¥š"],
            ["è¢‹ç¸",6,2400,2000,"ğŸ¦˜"], ["æµ·åˆºé¾",5,2000,1800,"ğŸ‰"], ["é‡‘é­šç‹",5,2100,1600,"ğŸ "], ["å¯¶çŸ³æµ·æ˜Ÿ",6,2300,2000,"â­"], ["å¸ç›¤é­”å¶",5,1500,2400,"ğŸ¤¡"],
            ["å¡æ¯”ç¸",6,2600,2400,"ğŸ’¤"], ["é›·ä¸˜",6,2400,1800,"âš¡âš¡"],
            
            // Level 7+ (å‚³èªª/æœ€å¼· - éœ€ç¸½æ˜Ÿæ•¸>9)
            ["å™´ç«é¾",7,2800,2200,"ğŸ²ğŸ”¥"], ["æ°´ç®­é¾œ",7,2600,2800,"ğŸ¢ğŸ’§"], ["å¦™è›™èŠ±",7,2700,2500,"ğŸ¸ğŸŒ¿"], ["æš´é¯‰é¾",7,2900,1800,"ğŸ‰"], ["ä¹˜é¾",7,2500,2500,"ğŸ¦•"],
            ["åŒ–çŸ³ç¿¼é¾",7,2800,2000,"ğŸ¦–"], ["å¿«é¾",8,3000,2600,"ğŸ²"], ["æ€¥å‡é³¥",7,2700,2400,"â„ï¸"], ["é–ƒé›»é³¥",7,2800,2300,"âš¡"], ["ç«ç„°é³¥",7,2900,2200,"ğŸ”¥"],
            ["è¶…å¤¢",8,3300,2500,"ğŸ‘½"], ["å¤¢å¹»",8,2500,2500,"ğŸ±"], ["ç­åŸºæ‹‰æ–¯",8,2900,2700,"ğŸ¦–"], ["æ´›å¥‡äº",8,2400,3200,"ğŸŒªï¸"], ["é³³ç‹",8,3200,2400,"ğŸŒˆ"],
            ["è“‹æ­å¡",8,3000,3000,"ğŸ‹"], ["å›ºæ‹‰å¤š",8,3400,2600,"ğŸŒ‹"], ["çƒˆç©ºå",9,3500,2800,"ğŸ‰ğŸŸ¢"]
        ];

        // è½‰æ›ç‚ºç‰©ä»¶é™£åˆ—
        const MONSTERS = RAW_MONSTERS.map((m, i) => ({
            id: `m_${i}`, name: m[0], category: 'monster', level: m[1], atk: m[2], def: m[3], img: m[4]
        }));

        const SPELLS = [
            { id: 's1', name: "å‚·è—¥", category: 'spell', effect: 'heal_1500', img: "ğŸ’Š", desc: "HP+1500" },
            { id: 's2', name: "å¥½å‚·è—¥", category: 'spell', effect: 'heal_2500', img: "ğŸ’‰", desc: "HP+2500" },
            { id: 's3', name: "åŠ›é‡å¼·åŒ–", category: 'spell', effect: 'atk_up_600', img: "âš”ï¸", desc: "ATK+600" },
            { id: 's4', name: "å®ˆå‚™å¼·åŒ–", category: 'spell', effect: 'def_up_600', img: "ğŸ›¡ï¸", desc: "DEF+600" },
            { id: 's5', name: "é›·æ“Š", category: 'spell', effect: 'destroy_one', img: "âš¡", desc: "ç ´å£ä¸€éš»" },
            { id: 's6', name: "é»‘æ´", category: 'spell', effect: 'destroy_all', img: "âš«", desc: "å…¨å ´ç ´å£" },
            { id: 's7', name: "è²ªå©ªä¹‹å£º", category: 'spell', effect: 'draw_2', img: "ğŸº", desc: "æŠ½2å¼µç‰Œ" }
        ];

        const TRAPS = [
            { id: 't1', name: "è®Šç¡¬", category: 'trap', effect: 'def_up', img: "ğŸª¨", desc: "DEF+2000" },
            { id: 't2', name: "é¡å£", category: 'trap', effect: 'destroy_atk', img: "âœ¨", desc: "ç ´å£æ”»æ“Šè€…" },
            { id: 't3', name: "åæ“Š", category: 'trap', effect: 'reflect_1000', img: "â†©ï¸", desc: "åå½ˆ1000å‚·" }
        ];

        // --- éŠæˆ²é‚è¼¯ ---
        class Card {
            constructor(data, owner) {
                this.uid = Math.random().toString(36).substr(2, 9);
                Object.assign(this, data);
                this.owner = owner;
                this.hasAttacked = false;
                this.isFacedown = false;
                this.tempAtkBuff = 0;
            }
            get currentAtk() { return (this.atk || 0) + this.tempAtkBuff; }
            
            render(location) {
                const el = document.createElement('div');
                el.className = 'card';
                el.dataset.uid = this.uid;
                el.dataset.cat = this.category;
                if(this.hasAttacked) el.classList.add('attacked');
                if(this.isFacedown && location !== 'hand') el.classList.add('facedown');
                
                let stars = '';
                if(this.category === 'monster') for(let i=0; i<this.level; i++) stars += 'â˜…';

                el.innerHTML = `
                    <div class="slash-effect"></div>
                    <div class="card-header">${this.name}</div>
                    ${this.category === 'monster' ? `<div class="card-level">${stars}</div>` : ''}
                    <div class="card-img">${this.img}</div>
                    <div class="card-stats">
                        ${this.category === 'monster' ? `<span>${this.currentAtk}</span><span>${this.def}</span>` : `<span style="width:100%;text-align:center">${this.desc}</span>`}
                    </div>
                `;
                el.onclick = (e) => { e.stopPropagation(); game.handleCardClick(this, location); };
                return el;
            }
        }

        class Game {
            constructor(difficulty) {
                this.difficulty = difficulty;
                this.turn = 'p1';
                this.phase = 'draw';
                this.players = {
                    p1: { lp: 8000, hand: [], field: [], st: [], deck: [] },
                    p2: { lp: 8000, hand: [], field: [], st: [], deck: [] }
                };
                this.selectedCard = null;
                this.summonState = { active: false, tributes: [] };
                this.turnSummoned = false;
                
                this.buildDecks(); // éš¨æ©Ÿçµ„ç‰Œ
                
                for(let i=0; i<5; i++) { this.draw('p1'); this.draw('p2'); }
                document.getElementById('diff-label').innerText = difficulty.toUpperCase();
                this.startTurnP1();
            }

            // --- éš¨æ©Ÿç‰Œçµ„æ§‹å»º ---
            buildDecks() {
                // 1. æ§‹å»º P1 ç‰Œçµ„ (æ¨™æº–éš¨æ©Ÿ)
                // çµæ§‹: 20æ€ªç¸(éš¨æ©Ÿ), 5é­”æ³•, 5é™·é˜±
                this.players.p1.deck = this.generateDeck('standard');
                
                // è¨ˆç®— P1 ç‰Œçµ„å¼·åº¦ (æ€ªç¸ç¸½æ˜Ÿæ•¸)
                const p1Stars = this.players.p1.deck
                    .filter(c => c.category === 'monster')
                    .reduce((sum, c) => sum + c.level, 0);

                // 2. æ§‹å»º P2 (CPU) ç‰Œçµ„ - åŸºæ–¼ P1 å¼·åº¦èˆ‡é›£åº¦
                let starMultiplier = 1.0;
                if (this.difficulty === 'medium') starMultiplier = 1.2;
                if (this.difficulty === 'hard') starMultiplier = 1.5;

                const targetStars = Math.floor(p1Stars * starMultiplier);
                this.players.p2.deck = this.generateDeck('target_stars', targetStars);

                // Debug é¡¯ç¤º
                const p2Stars = this.players.p2.deck.filter(c => c.category === 'monster').reduce((s, c) => s + c.level, 0);
                document.getElementById('debug-stars').innerText = `Deck Stars: YOU[${p1Stars}] vs CPU[${p2Stars}]`;
                
                this.log(`ç‰Œçµ„æ§‹å»ºå®Œæˆ! é›™æ–¹å·²æ´—ç‰Œã€‚`);
            }

            generateDeck(mode, targetStars = 0) {
                let deck = [];
                // å¿…å‚™: 5é­”æ³• 5é™·é˜±
                for(let i=0; i<5; i++) deck.push(SPELLS[Math.floor(Math.random()*SPELLS.length)]);
                for(let i=0; i<5; i++) deck.push(TRAPS[Math.floor(Math.random()*TRAPS.length)]);

                // 20 å¼µæ€ªç¸
                let monsters = [];
                if (mode === 'standard') {
                    // æ¨™æº–: å¤§å¤šæ•¸æ˜¯ä½æ˜Ÿ, å°‘é‡é«˜æ˜Ÿ
                    for(let i=0; i<20; i++) {
                        const r = Math.random();
                        let m;
                        if(r < 0.6) m = MONSTERS.filter(c=>c.level<=4)[Math.floor(Math.random() * 40)]; // ä½æ˜Ÿæ± 
                        else if(r < 0.9) m = MONSTERS.filter(c=>c.level>=5 && c.level<=6)[Math.floor(Math.random() * 40)]; // ä¸­æ˜Ÿæ± 
                        else m = MONSTERS.filter(c=>c.level>=7)[Math.floor(Math.random() * 15)]; // é«˜æ˜Ÿæ± 
                        monsters.push(m || MONSTERS[0]);
                    }
                } else if (mode === 'target_stars') {
                    // æ ¹æ“šç›®æ¨™æ˜Ÿæ•¸å¡«å……
                    let currentStars = 0;
                    while(monsters.length < 20) {
                        // å¦‚æœé‚„ç¼ºå¾ˆå¤šæ˜Ÿï¼Œå°±å®¹æ˜“æŠ½åˆ°é«˜æ˜Ÿ
                        let avgNeeded = (targetStars - currentStars) / (20 - monsters.length);
                        let candidates = [];
                        
                        if (avgNeeded >= 6) candidates = MONSTERS.filter(c=>c.level >= 6);
                        else if (avgNeeded >= 4) candidates = MONSTERS.filter(c=>c.level >= 4 && c.level <= 6);
                        else candidates = MONSTERS.filter(c=>c.level <= 4);

                        if(candidates.length === 0) candidates = MONSTERS; // Fallback
                        
                        const m = candidates[Math.floor(Math.random() * candidates.length)];
                        monsters.push(m);
                        currentStars += m.level;
                    }
                }
                
                // åˆä½µä¸¦æ´—ç‰Œ
                deck = deck.concat(monsters);
                return this.shuffle(deck);
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            log(msg) {
                const box = document.getElementById('game-log');
                box.innerText = msg;
                box.style.color = this.turn === 'p1' ? '#aaf' : '#faa';
            }

            draw(p) {
                if(this.players[p].deck.length === 0) return this.endGame(p==='p1'?'CPU':'YOU', "ç‰Œçµ„æŠ½ä¹¾");
                this.players[p].hand.push(new Card(this.players[p].deck.pop(), p));
                this.updateUI();
            }

            startTurnP1() {
                this.turn = 'p1';
                this.phase = 'draw';
                this.turnSummoned = false;
                this.selectedCard = null;
                this.summonState = { active: false, tributes: [] };
                this.resetBuffs();
                this.updateUI();
                
                this.log("[YOU] ä½ çš„å›åˆï¼ŒæŠ½ç‰Œï¼");
                setTimeout(() => {
                    this.draw('p1');
                    this.phase = 'main';
                    this.updateUI();
                }, 800);
            }

            async startTurnAI() {
                this.turn = 'p2';
                this.phase = 'draw';
                this.turnSummoned = false;
                this.selectedCard = null;
                this.resetBuffs();
                this.updateUI();
                this.log("[CPU] å°æ‰‹å›åˆï¼ŒæŠ½ç‰Œã€‚");
                
                await this.delay(1000);
                this.draw('p2');
                this.phase = 'main';
                this.updateUI();
                
                await this.delay(800);
                await this.aiMainPhase();
                
                await this.delay(800);
                this.phase = 'battle';
                this.updateUI();
                await this.aiBattlePhase();

                await this.delay(1000);
                this.endTurn();
            }

            async aiMainPhase() {
                const p2 = this.players.p2;
                if (!this.turnSummoned && p2.field.length < 5) {
                    const monsters = p2.hand.filter(c => c.category === 'monster');
                    if (this.difficulty === 'hard') monsters.sort((a,b) => b.level - a.level || b.atk - a.atk);
                    else monsters.sort((a,b) => 0.5 - Math.random());

                    for (let m of monsters) {
                        let canSummon = false;
                        let tributes = [];

                        if (m.level <= 4) {
                            canSummon = true;
                        } else if (m.level >= 5 && m.level <= 6) {
                            if (p2.field.length >= 1) {
                                canSummon = true;
                                tributes = [p2.field[0]];
                            }
                        } else if (m.level >= 7 && this.difficulty !== 'easy') {
                            const currentStars = p2.field.reduce((acc, c) => acc + c.level, 0);
                            if (currentStars > 9) {
                                canSummon = true;
                                let sum = 0;
                                for(let f of p2.field) { tributes.push(f); sum += f.level; if(sum > 9) break; }
                            }
                        }

                        if (canSummon) {
                            await this.highlightCard(m);
                            if (tributes.length > 0) tributes.forEach(t => this.removeCard(t));
                            this.deployCard(m, 'p2');
                            break; 
                        }
                    }
                }
                
                if (this.difficulty !== 'easy') {
                    const spells = p2.hand.filter(c => c.category === 'spell');
                    for (let s of spells) {
                        if (Math.random() > 0.5) { 
                            await this.highlightCard(s);
                            this.activateSpell(s, 'p2');
                            await this.delay(500);
                        }
                    }
                }
            }

            async aiBattlePhase() {
                const p2 = this.players.p2;
                const p1 = this.players.p1;
                
                for (let attacker of p2.field) {
                    if (attacker.hasAttacked) continue;
                    let target = null;
                    
                    if (p1.field.length === 0) {
                        target = 'direct';
                    } else {
                        if (this.difficulty === 'easy') target = p1.field[Math.floor(Math.random() * p1.field.length)];
                        else {
                            const killable = p1.field.filter(def => attacker.currentAtk > def.def);
                            if (killable.length > 0) target = killable.sort((a,b) => b.atk - a.atk)[0];
                            else if (this.difficulty === 'hard') target = null;
                            else if(Math.random() > 0.7) target = p1.field[0];
                        }
                    }

                    if (target) {
                        await this.highlightCard(attacker);
                        if (target === 'direct') await this.directAttack(attacker);
                        else await this.combat(attacker, target);
                        await this.delay(800);
                        if (this.checkWin()) return;
                    }
                }
            }

            async highlightCard(card) {
                const el = document.querySelector(`.card[data-uid="${card.uid}"]`);
                if (el) {
                    el.classList.add('ai-highlight');
                    await this.delay(600);
                    el.classList.remove('ai-highlight');
                }
            }

            handleCardClick(card, loc) {
                if (this.turn !== 'p1') return;

                // ç»ç¥­
                if (this.summonState.active && loc === 'field' && card.owner === 'p1') {
                    if(!this.summonState.tributes.find(c=>c.uid===card.uid)) {
                        this.summonState.tributes.push(card);
                        let conditionMet = false;
                        if (this.summonState.mode === 'count') conditionMet = this.summonState.tributes.length >= this.summonState.need;
                        else if (this.summonState.mode === 'stars') conditionMet = this.summonState.tributes.reduce((a,b)=>a+b.level, 0) > 9;

                        if (conditionMet) {
                            this.summonState.tributes.forEach(t => this.removeCard(t));
                            this.deployCard(this.summonState.card, 'p1');
                            this.summonState = { active: false, tributes: [] };
                        }
                        this.updateUI();
                    }
                    return;
                }

                // å¬å–š/ç™¼å‹•
                if (loc === 'hand' && this.phase === 'main') {
                    if (card.category === 'monster') {
                        if (this.turnSummoned) { this.log("æœ¬å›åˆå·²å¬å–šé"); return; }
                        if (this.players.p1.field.length >= 5) { this.log("å ´åœ°å·²æ»¿"); return; }

                        let mode = null; let need = 0;
                        if (card.level >= 7) { mode = 'stars'; need = 9; }
                        else if (card.level >= 5) { mode = 'count'; need = 1; }

                        if (need > 0 || mode) {
                            if (mode === 'count' && this.players.p1.field.length < need) { this.log("ç¥­å“ä¸è¶³"); return; }
                            if (mode === 'stars' && this.players.p1.field.reduce((a,b)=>a+b.level, 0) <= 9) { this.log("å ´ä¸Šæ€ªç¸ç¸½æ˜Ÿæ•¸ä¸è¶³ 10ï¼"); return; }
                            this.summonState = { active: true, card: card, mode: mode, need: need, tributes: [] };
                            this.log(mode === 'stars' ? "è«‹é¸æ“‡ç¥­å“ç›´åˆ°ç¸½æ˜Ÿæ•¸è¶…é 9" : "è«‹é¸æ“‡ 1 éš»ç¥­å“");
                            this.updateUI();
                        } else this.deployCard(card, 'p1');
                    }
                    else if (card.category === 'spell') this.activateSpell(card, 'p1');
                    else if (card.category === 'trap') this.setCard(card, 'p1');
                }

                // æˆ°é¬¥
                if (this.phase === 'battle') {
                    if (loc === 'field') {
                        if (card.owner === 'p1' && !card.hasAttacked) {
                            this.selectedCard = card;
                            this.log("é¸æ“‡äº†æ”»æ“Šæ€ªç¸ï¼Œè«‹é¸æ“‡ç›®æ¨™");
                            this.updateUI();
                        } else if (card.owner === 'p2' && this.selectedCard) {
                            this.combat(this.selectedCard, card);
                        }
                    }
                }
            }

            deployCard(card, p) {
                const player = this.players[p];
                player.hand = player.hand.filter(c => c.uid !== card.uid);
                player.field.push(card);
                if(p === this.turn) this.turnSummoned = true;
                this.log(`[${p==='p1'?'YOU':'CPU'}] å¬å–š ${card.name}`);
                this.updateUI();
            }

            setCard(card, p) {
                const player = this.players[p];
                if(player.st.length >= 5) return;
                player.hand = player.hand.filter(c => c.uid !== card.uid);
                card.isFacedown = true;
                player.st.push(card);
                this.log(`[${p==='p1'?'YOU':'CPU'}] è¦†è“‹ä¸€å¼µå¡`);
                this.updateUI();
            }

            activateSpell(card, p) {
                this.players[p].hand = this.players[p].hand.filter(c => c.uid !== card.uid);
                this.log(`é­”æ³•ç™¼å‹•: ${card.name}`);
                if(card.effect === 'heal_1500') this.players[p].lp += 1500;
                if(card.effect === 'heal_2500') this.players[p].lp += 2500;
                if(card.effect === 'atk_up_600') this.players[p].field.forEach(c=>c.tempAtkBuff+=600);
                if(card.effect === 'def_up_600') this.players[p].field.forEach(c=>c.def+=600);
                if(card.effect === 'draw_2') { this.draw(p); this.draw(p); }
                if(card.effect === 'destroy_one' || card.effect === 'destroy_all') {
                    const opp = p==='p1'?'p2':'p1';
                    const targets = this.players[opp].field;
                    if(targets.length > 0) {
                        if(card.effect === 'destroy_one') this.removeCard(targets[0]);
                        else while(this.players[opp].field.length > 0) this.removeCard(this.players[opp].field[0]);
                    }
                }
                this.updateUI();
            }

            async combat(attacker, target) {
                attacker.hasAttacked = true;
                this.selectedCard = null;
                this.updateUI();

                const opp = target.owner;
                const traps = this.players[opp].st.filter(c => c.category === 'trap' && c.isFacedown);
                if (traps.length > 0) {
                    if (Math.random() > 0.3) {
                        const trap = traps[0];
                        trap.isFacedown = false;
                        this.log(`é™·é˜±è§¸ç™¼: ${trap.name}`);
                        this.updateUI();
                        await this.delay(800);
                        this.removeCard(trap, 'st');
                        if (trap.effect === 'destroy_atk') {
                            this.removeCard(attacker);
                            this.log("æ”»æ“Šè€…è¢«ç ´å£ï¼");
                            return;
                        }
                        if (trap.effect === 'def_up') target.def += 2000;
                        if (trap.effect === 'reflect_1000') this.players[attacker.owner].lp -= 1000;
                    }
                }

                const el = document.querySelector(`.card[data-uid="${target.uid}"]`);
                if(el) { el.classList.add('slashing'); await this.delay(400); el.classList.remove('slashing'); }

                if (attacker.currentAtk > target.def) {
                    const dmg = attacker.currentAtk - target.def;
                    this.players[opp].lp = Math.max(0, this.players[opp].lp - dmg);
                    this.removeCard(target);
                    this.log(`æ“Šç ´ï¼å‚·å®³ ${dmg}`);
                } else if (attacker.currentAtk < target.def) {
                    const dmg = target.def - attacker.currentAtk;
                    this.players[attacker.owner].lp = Math.max(0, this.players[attacker.owner].lp - dmg);
                    this.log(`ç„¡æ³•æ“Šç©¿ï¼åå‚· ${dmg}`);
                }
                this.updateUI();
                this.checkWin();
            }

            async directAttack(attacker) {
                const opp = attacker.owner === 'p1' ? 'p2' : 'p1';
                attacker.hasAttacked = true;
                this.selectedCard = null;
                const dmg = attacker.currentAtk;
                this.players[opp].lp = Math.max(0, this.players[opp].lp - dmg);
                
                const hitEffect = document.getElementById(`${opp}-hit-effect`);
                if(hitEffect) { hitEffect.classList.add('hit-anim'); setTimeout(() => hitEffect.classList.remove('hit-anim'), 300); }

                this.log(`${attacker.name} ç›´æ¥æ”»æ“Šç©å®¶ï¼å‚·å®³ ${dmg}`);
                this.updateUI();
                this.checkWin();
            }

            removeCard(card, zone='field') {
                const p = this.players[card.owner];
                if(zone==='field') p.field = p.field.filter(c => c.uid !== card.uid);
                else p.st = p.st.filter(c => c.uid !== card.uid);
                this.updateUI();
            }

            resetBuffs() {
                ['p1','p2'].forEach(p => this.players[p].field.forEach(c => { c.hasAttacked=false; c.tempAtkBuff=0; }));
            }

            checkWin() {
                if (this.players.p1.lp <= 0) return this.endGame('CPU', 'ä½ è¼¸äº†ï¼');
                if (this.players.p2.lp <= 0) return this.endGame('YOU', 'ä½ è´äº†ï¼');
                return false;
            }

            endGame(winner, msg) {
                document.getElementById('winner-overlay').style.display = 'flex';
                document.getElementById('winner-text').innerHTML = `${winner} WIN<br><span style="font-size:24px">${msg}</span>`;
                return true;
            }

            endTurn() {
                if(this.turn === 'p1') this.startTurnAI();
                else this.startTurnP1();
            }

            enterBattlePhase() { 
                if(this.phase==='main' && this.turn==='p1') { 
                    this.phase='battle'; 
                    this.log("é€²å…¥æˆ°é¬¥éšæ®µï¼Œè«‹é»æ“Šæ€ªç¸æ”»æ“Š"); 
                    this.updateUI(); 
                } 
            }

            delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

            updateUI() {
                document.getElementById('p1-lp').innerText = this.players.p1.lp;
                document.getElementById('p2-lp').innerText = this.players.p2.lp;
                
                document.querySelectorAll('.phase-box').forEach(e => e.classList.remove('active'));
                if(document.getElementById(`phase-${this.phase}`)) document.getElementById(`phase-${this.phase}`).classList.add('active');
                if(this.phase === 'main' && this.turn === 'p1') document.getElementById('phase-main').classList.add('active'); 

                document.getElementById('p1-zone').className = `player-zone p1-zone ${this.turn==='p1'?'active-turn':''}`;
                document.getElementById('p2-zone').className = `player-zone p2-zone ${this.turn==='p2'?'active-turn':''}`;
                
                if (this.turn === 'p1' && this.phase === 'battle' && this.selectedCard && this.players.p2.field.length === 0) {
                    document.getElementById('p2-zone').classList.add('can-direct-attack');
                } else {
                    document.getElementById('p2-zone').classList.remove('can-direct-attack');
                }

                document.getElementById('btn-battle').disabled = (this.turn !== 'p1' || this.phase !== 'main');
                document.getElementById('btn-end').disabled = (this.turn !== 'p1');

                const render = (id, list, loc) => {
                    const div = document.getElementById(id);
                    div.innerHTML = '';
                    list.forEach(c => {
                        const el = c.render(loc);
                        if(this.selectedCard?.uid === c.uid) el.classList.add('selected');
                        if(this.summonState.active && loc==='field' && c.owner==='p1') {
                            if(this.summonState.tributes.find(t=>t.uid===c.uid)) el.classList.add('tribute-target');
                            else { el.style.borderColor='#0f0'; el.style.boxShadow='0 0 5px #0f0'; }
                        }
                        div.appendChild(el);
                    });
                };

                render('p1-hand', this.players.p1.hand, 'hand');
                render('p1-field', this.players.p1.field, 'field');
                render('p1-st', this.players.p1.st, 'st');
                render('p2-hand', this.players.p2.hand, 'hand');
                render('p2-field', this.players.p2.field, 'field');
                render('p2-st', this.players.p2.st, 'st');
            }
        }

        let game;
        function startGame(diff) {
            document.getElementById('start-screen').style.display = 'none';
            game = new Game(diff);
        }

        document.getElementById('p2-zone').addEventListener('click', (e) => {
            if (e.target.closest('.card')) return;
            if(game && game.turn==='p1' && game.phase==='battle' && game.selectedCard && game.players.p2.field.length === 0) {
                game.directAttack(game.selectedCard);
            }
        });

    </script>
</body>
</html>
