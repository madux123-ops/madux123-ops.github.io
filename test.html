<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>鬼滅之刃：光明與黑暗戰記</title>
    <style>
        /* --- 全局設定 --- */
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background-color: #222;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            /* 融入炭治郎風格背景 */
            background-image: linear-gradient(45deg, #000 25%, transparent 25%, transparent 75%, #000 75%, #000),
                              linear-gradient(45deg, #000 25%, transparent 25%, transparent 75%, #000 75%, #000);
            background-color: #367c59; 
            background-size: 40px 40px;
            background-position: 0 0, 20px 20px;
        }

        h1 {
            text-shadow: 2px 2px 4px #000;
            margin-bottom: 10px;
        }

        /* --- 遊戲主容器 --- */
        #game-container {
            display: flex;
            gap: 20px;
            background-color: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            border: 3px solid #d4af37; /* 金色邊框，致敬經典 RPG */
            box-shadow: 0 10px 20px rgba(0,0,0,0.5);
        }

        /* --- 戰棋地圖區域 --- */
        #grid-container {
            display: grid;
            grid-template-columns: repeat(6, 60px); /* 6x6 地圖 */
            grid-template-rows: repeat(6, 60px);
            gap: 2px;
            border: 4px solid #555;
            background-color: #333;
        }

        .tile {
            width: 60px;
            height: 60px;
            background-color: #5c4b36; /* 土地顏色 */
            border: 1px solid #444;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }
        
        /* 地板紋理 - 榻榻米/泥土感 */
        .tile::after {
            content: '';
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0.2;
            background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAIklEQVQIW2NkQAJfv379zwjjgzj//v37z4ivDKBCGAY4AABwKA75J6P9OgAAAABJRU5ErkJggg==');
        }

        /* 可移動範圍提示 */
        .tile.movable {
            background-color: rgba(100, 200, 255, 0.4);
            box-shadow: inset 0 0 10px #4a90e2;
        }
        
        /* 可攻擊範圍提示 */
        .tile.attackable {
            background-color: rgba(255, 80, 80, 0.4);
            box-shadow: inset 0 0 10px #e74c3c;
        }

        /* --- 角色單位 --- */
        .unit {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 24px;
            z-index: 2;
            position: relative;
            transition: all 0.2s;
            /* 簡單的陰影 */
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }

        .unit.slayer {
            background: linear-gradient(135deg, #2e8b57, #1a1a1a); /* 炭治郎綠黑 */
            border: 2px solid #00bfff;
        }

        .unit.demon {
            background: linear-gradient(135deg, #800000, #333); /* 惡鬼暗紅 */
            border: 2px solid #ff4d4d;
        }

        .unit.active {
            box-shadow: 0 0 15px yellow;
            transform: scale(1.1);
        }
        
        /* 血條 */
        .hp-bar-bg {
            position: absolute;
            bottom: -5px;
            left: 0;
            width: 100%;
            height: 6px;
            background: #333;
            border-radius: 3px;
        }
        .hp-bar-fill {
            height: 100%;
            background: #2ecc71;
            border-radius: 3px;
            transition: width 0.3s;
        }
        .unit.demon .hp-bar-fill { background: #e74c3c; }

        /* --- UI 介面區域 --- */
        #ui-panel {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .panel-box {
            background: #444;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #666;
        }
        
        .panel-title {
            font-size: 1.1em;
            color: #d4af37;
            border-bottom: 1px solid #666;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        #action-menu {
            display: none; /* 預設隱藏 */
            flex-direction: column;
            gap: 10px;
        }

        button.action-btn {
            padding: 10px;
            background: #2c3e50;
            color: white;
            border: 1px solid #34495e;
            cursor: pointer;
            font-size: 1em;
            border-radius: 5px;
            transition: background 0.2s;
        }
        
        button.action-btn:hover { background: #34495e; }
        button.action-btn:disabled { background: #555; color: #888; cursor: not-allowed; }
        
        .skill-btn { background: #2980b9 !important; }
        .skill-btn:hover { background: #3498db !important; }

        #battle-log {
            height: 150px;
            overflow-y: auto;
            font-size: 0.9em;
            color: #ccc;
        }
        .log-entry { margin-bottom: 5px; }
        .log-damage { color: #ff4d4d; font-weight: bold; }
        .log-skill { color: #00bfff; font-weight: bold; }

    </style>
</head>
<body>

    <h1>鬼滅之刃：光明與黑暗戰記</h1>
    <div style="margin-bottom: 10px; font-size: 0.9em; color: #aaa;">參考《光明與黑暗》戰棋系統的簡化原型</div>

    <div id="game-container">
        <div id="grid-container"></div>

        <div id="ui-panel">
            <div class="panel-box">
                <div class="panel-title">當前回合</div>
                <div id="turn-indicator">準備中...</div>
            </div>

            <div class="panel-box">
                <div class="panel-title">單位資訊</div>
                <div id="unit-stats">請選擇一個單位</div>
            </div>

            <div class="panel-box" id="action-menu-box">
                <div class="panel-title">行動指令</div>
                <div id="action-menu">
                    <button class="action-btn" id="btn-move">移動 (Move)</button>
                    <button class="action-btn" id="btn-attack" disabled>攻擊 (Attack)</button>
                    <button class="action-btn skill-btn" id="btn-skill" disabled>水之呼吸 (Skill)</button>
                    <button class="action-btn" id="btn-wait">待機 (Wait)</button>
                </div>
            </div>
        </div>
    </div>

    <div class="panel-box" style="width: 600px; margin-top: 20px;">
        <div class="panel-title">戰鬥紀錄</div>
        <div id="battle-log"></div>
    </div>

<script>
    // --- 遊戲設定與資料 ---
    const GRID_SIZE = 6;
    let grid = []; // 存放地圖格子的 DOM 元素
    let units = []; // 存放所有單位物件
    let currentTurnIndex = 0; // 當前行動單位的索引
    let selectedUnit = null; // 玩家當前選中的單位
    let gameState = 'IDLE'; // IDLE, MOVING, ACTING, ENEMY_TURN

    // 單位類別定義
    class Unit {
        constructor(id, name, type, x, y, stats) {
            this.id = id;
            this.name = name;
            this.type = type; // 'slayer' or 'demon'
            this.x = x;
            this.y = y;
            this.maxHp = stats.hp;
            this.hp = stats.hp;
            this.atk = stats.atk;
            this.def = stats.def;
            this.moveRange = stats.move;
            this.skillName = stats.skillName;
            this.skillDmg = stats.skillDmg;
            this.hasMoved = false;
            this.hasActed = false;
        }
    }

    // 初始化單位
    function initUnits() {
        units = [
            new Unit(1, '炭治郎', 'slayer', 1, 4, { hp: 50, atk: 12, def: 5, move: 3, skillName: '水之呼吸・壹之型', skillDmg: 20 }),
            new Unit(2, '下弦之陸', 'demon', 4, 1, { hp: 60, atk: 15, def: 3, move: 2, skillName: '血鬼術・斬擊', skillDmg: 18 }),
            new Unit(3, '雜魚鬼A', 'demon', 3, 2, { hp: 30, atk: 10, def: 2, move: 2, skillName: '爪擊', skillDmg: 12 })
        ];
        // 簡單依據 ID 排序行動順序 (實際遊戲會看速度屬性)
        updateTurnIndicator();
    }

    // --- 地圖與渲染系統 ---
    function initGrid() {
        const gridContainer = document.getElementById('grid-container');
        for (let y = 0; y < GRID_SIZE; y++) {
            let row = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                let tile = document.createElement('div');
                tile.classList.add('tile');
                tile.dataset.x = x;
                tile.dataset.y = y;
                tile.onclick = () => handleTileClick(x, y);
                gridContainer.appendChild(tile);
                row.push(tile);
            }
            grid.push(row);
        }
    }

    function renderGrid() {
        // 清除所有格子上的內容和狀態類別
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                grid[y][x].innerHTML = '';
                grid[y][x].classList.remove('movable', 'attackable');
            }
        }

        // 繪製單位
        units.forEach(unit => {
            if (unit.hp <= 0) return; // 死亡單位不繪製
            const unitDiv = document.createElement('div');
            unitDiv.classList.add('unit', unit.type);
            unitDiv.innerText = unit.type === 'slayer' ? '滅' : '鬼';
            
            // 加入血條
            const hpBg = document.createElement('div');
            hpBg.className = 'hp-bar-bg';
            const hpFill = document.createElement('div');
            hpFill.className = 'hp-bar-fill';
            hpFill.style.width = (unit.hp / unit.maxHp * 100) + '%';
            hpBg.appendChild(hpFill);
            unitDiv.appendChild(hpBg);

            if (unit === getCurrentUnit()) {
                unitDiv.classList.add('active');
            }
            grid[unit.y][unit.x].appendChild(unitDiv);
        });

        updateUIStats();
    }

    // --- 遊戲核心邏輯 ---

    function getCurrentUnit() {
        return units[currentTurnIndex];
    }

    function nextTurn() {
        // 重置當前單位的狀態
        let current = getCurrentUnit();
        if (current) {
            current.hasMoved = false;
            current.hasActed = false;
        }

        // 尋找下一個活著的單位
        let attempts = 0;
        do {
            currentTurnIndex = (currentTurnIndex + 1) % units.length;
            attempts++;
        } while (units[currentTurnIndex].hp <= 0 && attempts <= units.length);

        // 檢查勝利條件
        const slayersAlive = units.some(u => u.type === 'slayer' && u.hp > 0);
        const demonsAlive = units.some(u => u.type === 'demon' && u.hp > 0);

        if (!slayersAlive) {
            alert("遊戲結束：惡鬼獲勝，世界陷入黑暗...");
            location.reload();
            return;
        }
        if (!demonsAlive) {
            alert("遊戲結束：鬼殺隊獲勝，迎來了黎明！");
            location.reload();
            return;
        }

        updateTurnIndicator();
        renderGrid();
        
        gameState = 'IDLE';
        selectedUnit = null;
        document.getElementById('action-menu').style.display = 'none';

        const nextUnit = getCurrentUnit();
        if (nextUnit.type === 'demon') {
            gameState = 'ENEMY_TURN';
            setTimeout(enemyAI, 1000); // 延遲執行 AI
        } else {
            // 玩家回合，自動選中
            handleTileClick(nextUnit.x, nextUnit.y);
        }
    }

    function handleTileClick(x, y) {
        if (gameState === 'ENEMY_TURN') return;

        const clickedUnit = units.find(u => u.x === x && u.y === y && u.hp > 0);
        const currentUnit = getCurrentUnit();

        // 狀態 1: 選擇移動目的地
        if (gameState === 'MOVING') {
            if (grid[y][x].classList.contains('movable') && !clickedUnit) {
                // 執行移動
                moveUnit(currentUnit, x, y);
                gameState = 'ACTING';
                renderGrid();
                showActionMenu();
            } else {
                // 取消移動
                gameState = 'IDLE';
                renderGrid();
                document.getElementById('action-menu').style.display = 'none';
            }
            return;
        }
        
        // 狀態 2: 選擇攻擊目標 (普通攻擊或技能)
        if (gameState === 'ATTACKING' || gameState === 'SKILLING') {
             if (grid[y][x].classList.contains('attackable') && clickedUnit && clickedUnit.type !== currentUnit.type) {
                const isSkill = gameState === 'SKILLING';
                executeAttack(currentUnit, clickedUnit, isSkill);
                endAction();
            } else {
                // 取消攻擊選擇
                gameState = 'ACTING';
                renderGrid();
                showActionMenu();
            }
            return;
        }

        // 狀態 3: 閒置時點擊單位
        if (gameState === 'IDLE' || gameState === 'ACTING') {
            if (clickedUnit && clickedUnit === currentUnit && !currentUnit.hasMoved) {
                selectedUnit = clickedUnit;
                renderGrid(); // 清除舊的標記
                showMoveRange(currentUnit);
                gameState = 'MOVING';
                document.getElementById('action-menu').style.display = 'none';
            } else if (clickedUnit) {
                // 僅查看其他單位資訊
                selectedUnit = clickedUnit;
                updateUIStats();
            }
        }
    }

    // 顯示移動範圍 (使用簡單的曼哈頓距離，不考慮障礙物以簡化原型)
    function showMoveRange(unit) {
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const distance = Math.abs(unit.x - x) + Math.abs(unit.y - y);
                // 檢查是否有其他單位擋路
                const isOccupied = units.some(u => u.x === x && u.y === y && u.hp > 0 && u !== unit);
                if (distance <= unit.moveRange && !isOccupied) {
                    grid[y][x].classList.add('movable');
                }
            }
        }
    }

    // 顯示攻擊範圍 (僅相鄰四格)
    function showAttackRange(unit) {
        const adjacent = [
            {x: unit.x+1, y: unit.y}, {x: unit.x-1, y: unit.y},
            {x: unit.x, y: unit.y+1}, {x: unit.x, y: unit.y-1}
        ];
        adjacent.forEach(pos => {
            if (pos.x >= 0 && pos.x < GRID_SIZE && pos.y >= 0 && pos.y < GRID_SIZE) {
                grid[pos.y][pos.x].classList.add('attackable');
            }
        });
    }

    function moveUnit(unit, x, y) {
        unit.x = x;
        unit.y = y;
        unit.hasMoved = true;
        addLog(`${unit.name} 移動到了 (${x}, ${y})`);
    }

    function executeAttack(attacker, defender, isSkill) {
        let damage = 0;
        let attackName = "普通攻擊";

        if (isSkill) {
            // 技能傷害計算：技能基礎傷害 + 攻擊力 - 防禦力
            damage = attacker.skillDmg + attacker.atk - defender.def;
            attackName = attacker.skillName;
            addLog(`<span class="log-skill">${attacker.name} 使用了 ${attackName}！</span>`);
        } else {
            // 普通攻擊傷害計算
            damage = attacker.atk - defender.def;
        }

        // 傷害浮動 (90% - 110%)
        damage = Math.floor(damage * (0.9 + Math.random() * 0.2));
        damage = Math.max(1, damage); // 至少造成 1 點傷害

        defender.hp -= damage;
        addLog(`${attacker.name} 對 ${defender.name} 造成了 <span class="log-damage">${damage}</span> 點傷害。`);

        if (defender.hp <= 0) {
            defender.hp = 0;
            addLog(`<strong>${defender.name} 被擊敗了！</strong>`);
        }
    }

    function endAction() {
        getCurrentUnit().hasActed = true;
        nextTurn();
    }

    // --- UI 介面控制 ---
    function updateTurnIndicator() {
        const current = getCurrentUnit();
        const indicator = document.getElementById('turn-indicator');
        indicator.innerText = `${current.name} (${current.type === 'slayer' ? '我方' : '敵方'}) 的回合`;
        indicator.style.color = current.type === 'slayer' ? '#00bfff' : '#ff4d4d';
    }

    function updateUIStats() {
        const statsBox = document.getElementById('unit-stats');
        if (!selectedUnit) {
            statsBox.innerText = "請選擇一個單位";
            return;
        }
        statsBox.innerHTML = `
            <strong>${selectedUnit.name}</strong><br>
            類型: ${selectedUnit.type === 'slayer' ? '鬼殺隊' : '惡鬼'}<br>
            HP: ${selectedUnit.hp} / ${selectedUnit.maxHp}<br>
            攻擊: ${selectedUnit.atk}<br>
            防禦: ${selectedUnit.def}<br>
            移動: ${selectedUnit.moveRange}
        `;
    }

    function showActionMenu() {
        const menu = document.getElementById('action-menu');
        menu.style.display = 'flex';
        const current = getCurrentUnit();

        // 檢查周圍是否有敵人可攻擊
        const adjacentEnemies = units.some(u => 
            u.type !== current.type && u.hp > 0 &&
            (Math.abs(u.x - current.x) + Math.abs(u.y - current.y) === 1)
        );

        document.getElementById('btn-move').disabled = current.hasMoved;
        document.getElementById('btn-attack').disabled = current.hasActed || !adjacentEnemies;
        document.getElementById('btn-skill').disabled = current.hasActed || !adjacentEnemies;
        document.getElementById('btn-skill').innerText = `${current.skillName} (Skill)`;
    }

    function addLog(message) {
        const log = document.getElementById('battle-log');
        const entry = document.createElement('div');
        entry.className = 'log-entry';
        entry.innerHTML = message;
        log.appendChild(entry);
        log.scrollTop = log.scrollHeight;
    }

    // --- 按鈕事件綁定 ---
    document.getElementById('btn-move').onclick = () => {
        if (getCurrentUnit().hasMoved) return;
        renderGrid();
        showMoveRange(getCurrentUnit());
        gameState = 'MOVING';
        document.getElementById('action-menu').style.display = 'none';
    };

    document.getElementById('btn-attack').onclick = () => {
        renderGrid();
        showAttackRange(getCurrentUnit());
        gameState = 'ATTACKING';
        document.getElementById('action-menu').style.display = 'none';
        addLog("請選擇攻擊目標...");
    };

    document.getElementById('btn-skill').onclick = () => {
        renderGrid();
        showAttackRange(getCurrentUnit());
        gameState = 'SKILLING';
        document.getElementById('action-menu').style.display = 'none';
        addLog(`請選擇 ${getCurrentUnit().skillName} 的目標...`);
    };

    document.getElementById('btn-wait').onclick = () => {
        addLog(`${getCurrentUnit().name} 結束了行動。`);
        endAction();
    };

    // --- 簡易敵人 AI ---
    function enemyAI() {
        const currentDemon = getCurrentUnit();
        if (currentDemon.hp <= 0) { nextTurn(); return; }

        addLog(`[AI] ${currentDemon.name} 正在思考...`);

        // 1. 尋找最近的鬼殺隊隊員
        let target = null;
        let minDistance = 999;
        units.forEach(u => {
            if (u.type === 'slayer' && u.hp > 0) {
                const dist = Math.abs(u.x - currentDemon.x) + Math.abs(u.y - currentDemon.y);
                if (dist < minDistance) {
                    minDistance = dist;
                    target = u;
                }
            }
        });

        if (!target) { endAction(); return; } // 沒有目標

        // 2. 移動邏輯 (簡化：向目標方向移動一步)
        if (minDistance > 1) {
            let newX = currentDemon.x;
            let newY = currentDemon.y;
            if (target.x > currentDemon.x) newX++;
            else if (target.x < currentDemon.x) newX--;
            
            if (target.y > currentDemon.y) newY++;
            else if (target.y < currentDemon.y) newY--;

            // 確保沒人擋路且在移動範圍內 (這裡 AI 作弊一下，只做簡單檢查)
            const isOccupied = units.some(u => u.x === newX && u.y === newY && u.hp > 0);
            if (!isOccupied && (Math.abs(newX - currentDemon.x) + Math.abs(newY - currentDemon.y)) <= currentDemon.moveRange) {
                 moveUnit(currentDemon, newX, newY);
                 renderGrid();
            }
        }

        // 3. 攻擊邏輯
        // 重新計算距離
        const newDist = Math.abs(target.x - currentDemon.x) + Math.abs(target.y - currentDemon.y);
        if (newDist === 1) {
            // 50% 機率用技能，50% 用普攻
            const useSkill = Math.random() > 0.5;
            setTimeout(() => {
                executeAttack(currentDemon, target, useSkill);
                renderGrid();
                endAction();
            }, 800); // 攻擊延遲增加臨場感
        } else {
            setTimeout(endAction, 500);
        }
    }

    // --- 遊戲啟動 ---
    initGrid();
    initUnits();
    renderGrid();
    addLog("戰鬥開始！那田蜘蛛山的遭遇戰。");

</script>
</body>
</html>
