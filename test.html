<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¯¶å¯å¤¢å°æˆ°-é€²åŒ–èˆ‡ç»ç¥­</title>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --field-monster: #2d4a3e;
            --field-st: #3a2a4a; /* é­”æ³•é™·é˜±å€é¡è‰² */
            --card-bg: #e0e0e0;
            --p1-color: #3b82f6;
            --p2-color: #ef4444;
            --text-color: #fff;
            --card-width: 85px;
            --card-height: 125px;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- ä½ˆå±€èª¿æ•´ --- */
        .game-board { flex: 1; display: flex; flex-direction: column; }
        .player-zone { flex: 1; display: flex; flex-direction: column; padding: 5px; position: relative; transition: background 0.3s; justify-content: center;}
        .p2-zone { border-bottom: 2px solid #444; background: rgba(239, 68, 68, 0.05); flex-direction: column-reverse;}
        .p1-zone { background: rgba(59, 130, 246, 0.05); }
        .active-turn { background: rgba(255, 255, 255, 0.1) !important; }

        /* --- å€åŸŸåˆ— --- */
        .field-row {
            display: flex; justify-content: center; gap: 8px; height: var(--card-height); align-items: center;
            border-radius: 8px; margin: 4px 0; box-shadow: inset 0 0 10px rgba(0,0,0,0.5);
            padding: 5px;
        }
        .monster-zone { background-color: var(--field-monster); }
        .st-zone { background-color: var(--field-st); height: 100px;} /* é­”æ³•é™·é˜±å€è¼ƒçŸ® */
        .hand-row {
            display: flex; justify-content: center; gap: -10px; height: 110px; align-items: center;
            overflow-x: visible; z-index: 20;
        }

        /* --- å¡ç‰‡æ¨£å¼ --- */
        .card {
            width: var(--card-width); height: var(--card-height);
            background: var(--card-bg); border-radius: 6px; border: 3px solid #888;
            color: #000; display: flex; flex-direction: column; font-size: 9px;
            position: relative; cursor: pointer; transition: transform 0.2s, box-shadow 0.2s;
            overflow: hidden;
        }
        .hand-row .card { width: 75px; height: 105px; transform: translateY(0px); transition: 0.3s;}
        .hand-row .card:hover { transform: translateY(-15px) scale(1.1); z-index: 100;}

        .card.selected { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; transform: scale(1.05); z-index: 50;}
        .card.tribute-target { border-color: #ff0000; box-shadow: 0 0 15px #ff0000; animation: pulse 1s infinite;}

        .card-header { background: #d4af37; padding: 2px; font-weight: bold; text-align: center; border-bottom: 1px solid #000; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;}
        .card-level { text-align: center; background: #eee; color: #000; font-size: 10px; letter-spacing: -2px;}
        .card-img { flex: 1; display: flex; align-items: center; justify-content: center; font-size: 32px; background: #fff; position: relative;}
        .card-stats { background: #f0f0f0; padding: 2px; display: flex; justify-content: space-between; border-top: 1px solid #000; font-weight: bold; font-size: 10px;}

        /* å¡ç‰‡ç¨®é¡é¡è‰² */
        .card[data-cat="monster"] { border-color: #c0a060; }
        .card[data-cat="spell"] { border-color: #00a86b; } /* é­”æ³•ç¶  */
        .card[data-cat="spell"] .card-header { background: #00a86b; color: white;}
        .card[data-cat="trap"] { border-color: #bc5a84; } /* é™·é˜±ç´« */
        .card[data-cat="trap"] .card-header { background: #bc5a84; color: white;}

        .card.attacked { filter: grayscale(1); cursor: not-allowed; }
        .card.facedown { background: #333; border-color: #555; color: transparent; }
        .card.facedown * { opacity: 0; }
        .card.facedown::after { content: 'ğŸ´'; position: absolute; top:50%; left:50%; transform:translate(-50%, -50%); font-size: 40px; color: #666; opacity: 1;}

        /* --- VFX: æ”»æ“Šç‰¹æ•ˆ --- */
        .slash-effect {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: transparent;
            pointer-events: none;
            z-index: 99;
            display: none;
        }
        .slashing .slash-effect {
            display: block;
            animation: slashAnim 0.6s ease-out;
            background: linear-gradient(45deg, transparent 40%, rgba(255,0,0,0.8) 45%, rgba(255,255,255,0.9) 50%, rgba(255,0,0,0.8) 55%, transparent 60%);
            background-size: 300% 300%;
        }

        @keyframes slashAnim {
            0% { background-position: 100% 0%; opacity: 0; }
            10% { opacity: 1; }
            100% { background-position: 0% 100%; opacity: 0; }
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.05); } 100% { transform: scale(1); } }

        /* --- UI é¢æ¿ --- */
        .info-panel { position: absolute; top: 50%; left: 10px; transform: translateY(-50%); background: rgba(0,0,0,0.8); padding: 10px; border-radius: 8px; z-index: 100; width: 140px; }
        .lp-box { margin-bottom: 5px; font-size: 16px; font-weight: bold; }
        .p1-lp { color: var(--p1-color); } .p2-lp { color: var(--p2-color); }
        .phase-indicator { text-align: center; margin-top: 10px; font-weight: bold; color: #ffd700; border: 1px solid #ffd700; padding: 5px; font-size: 14px;}
        .controls { position: absolute; top: 50%; right: 10px; transform: translateY(-50%); display: flex; flex-direction: column; gap: 10px; z-index: 100; }
        button { padding: 8px 15px; font-size: 14px; cursor: pointer; background: #444; color: white; border: 1px solid #888; border-radius: 5px; }
        button:hover { background: #666; } button:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn-end { background: #8b0000; border-color: #ff0000; }
        .log-box { height: 80px; background: #000; border-top: 1px solid #555; padding: 5px; overflow-y: auto; font-family: monospace; font-size: 11px; }
        .log-entry { margin: 2px 0; border-bottom: 1px solid #333; color: #ccc;}
        #winner-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 999; }
        #winner-text { font-size: 40px; color: #ffd700; margin-bottom: 20px; }
    </style>
</head>
<body>

    <div class="info-panel">
        <div class="lp-box p2-lp">P2: <span id="p2-lp">8000</span></div>
        <div class="lp-box p1-lp">P1: <span id="p1-lp">8000</span></div>
        <div class="phase-indicator" id="current-phase">æŠ½ç‰Œéšæ®µ</div>
        <div style="font-size: 12px; text-align: center; margin-top:5px;">ç•¶å‰: <span id="current-player">P1</span></div>
    </div>

    <div class="controls">
        <button id="btn-battle" onclick="game.enterBattlePhase()">é€²å…¥æˆ°é¬¥</button>
        <button id="btn-main2" onclick="game.enterMainPhase2()" disabled>ä¸»è¦éšæ®µ2</button>
        <button id="btn-end" class="btn-end" onclick="game.endTurn()">çµæŸå›åˆ</button>
    </div>

    <div class="game-board">
        <div class="player-zone p2-zone" id="p2-zone">
            <div class="hand-row" id="p2-hand"></div>
            <div class="field-row st-zone" id="p2-st"></div>
            <div class="field-row monster-zone" id="p2-field"></div>
        </div>

        <div class="player-zone p1-zone" id="p1-zone">
            <div class="field-row monster-zone" id="p1-field"></div>
            <div class="field-row st-zone" id="p1-st"></div>
            <div class="hand-row" id="p1-hand"></div>
        </div>
    </div>

    <div class="log-box" id="game-log">
        <div class="log-entry">éŠæˆ²é–‹å§‹ï¼LPè¨­ç½®ç‚º8000ã€‚è«‹ P1 æŠ½ç‰Œã€‚</div>
    </div>

    <div id="winner-overlay">
        <div id="winner-text">P1 ç²å‹!</div>
        <button onclick="location.reload()" style="font-size: 20px;">é‡æ–°é–‹å§‹</button>
    </div>

    <script>
        // --- è³‡æ–™åº«: å¯¶å¯å¤¢èˆ‡é­”é™·å¡ ---
        // category: 'monster', 'spell', 'trap'
        // level: 1-4 (ç„¡ç¥­å“), 5-6 (1ç¥­å“), 7+ (2ç¥­å“)
        // effect: spell/trap çš„æ•ˆæœä»£ç¢¼
        const CARD_DB = [
            // ä¸‹ç´šæ€ªç¸ (15ç¨®)
            { id: 1, name: "å°ç«é¾", category: 'monster', level: 3, atk: 1200, def: 800, img: "ğŸ”¥" },
            { id: 2, name: "å‚‘å°¼é¾œ", category: 'monster', level: 3, atk: 1000, def: 1500, img: "ğŸ’§" },
            { id: 3, name: "å¦™è›™ç¨®å­", category: 'monster', level: 3, atk: 1100, def: 1100, img: "ğŸŒ¿" },
            { id: 4, name: "çš®å¡ä¸˜", category: 'monster', level: 4, atk: 1600, def: 1000, img: "âš¡" },
            { id: 5, name: "ä¼Šå¸ƒ", category: 'monster', level: 3, atk: 1300, def: 1300, img: "ğŸ•" },
            { id: 6, name: "é¬¼æ–¯", category: 'monster', level: 2, atk: 1000, def: 200, img: "ğŸ‘»" },
            { id: 7, name: "è…•åŠ›", category: 'monster', level: 4, atk: 1700, def: 800, img: "ğŸ’ª" },
            { id: 8, name: "å‡±è¥¿", category: 'monster', level: 1, atk: 500, def: 1500, img: "ğŸ§˜" },
            { id: 9, name: "å°æ‹³çŸ³", category: 'monster', level: 3, atk: 1200, def: 1600, img: "ğŸª¨" },
            { id: 10, name: "é¯‰é­šç‹", category: 'monster', level: 1, atk: 0, def: 0, img: "ğŸŸ" },
            
            // ä¸Šç´šæ€ªç¸ (1ç¥­å“) (10ç¨®)
            { id: 20, name: "ç«æé¾", category: 'monster', level: 5, atk: 2000, def: 1400, img: "ğŸ”¥ğŸ”¥" },
            { id: 21, name: "å¡å’ªé¾œ", category: 'monster', level: 5, atk: 1800, def: 1800, img: "ğŸ’§ğŸ’§" },
            { id: 22, name: "å¦™è›™è‰", category: 'monster', level: 5, atk: 1900, def: 1600, img: "ğŸŒ¿ğŸŒ¿" },
            { id: 23, name: "é›·ä¸˜", category: 'monster', level: 6, atk: 2400, def: 1800, img: "âš¡âš¡" },
            { id: 24, name: "å¡æ¯”ç¸", category: 'monster', level: 6, atk: 2500, def: 2000, img: "ğŸ’¤" },
            { id: 25, name: "è€¿é¬¼", category: 'monster', level: 6, atk: 2300, def: 1500, img: "ğŸ˜ˆ" },
            { id: 26, name: "æ€ªåŠ›", category: 'monster', level: 6, atk: 2600, def: 1600, img: "ğŸ’ªğŸ’ª" },

            // å‚³èªª/æœ€å¼·ç´šæ€ªç¸ (2ç¥­å“) (8ç¨®)
            { id: 40, name: "å™´ç«é¾", category: 'monster', level: 7, atk: 2800, def: 2200, img: "ğŸ²ğŸ”¥" },
            { id: 41, name: "æ°´ç®­é¾œ", category: 'monster', level: 7, atk: 2600, def: 2800, img: "ğŸ¢ğŸ’§" },
            { id: 42, name: "å¦™è›™èŠ±", category: 'monster', level: 7, atk: 2700, def: 2500, img: "ğŸ¸ğŸŒ¿" },
            { id: 43, name: "å¿«é¾", category: 'monster', level: 8, atk: 3000, def: 2500, img: "ğŸ‰" },
            { id: 44, name: "è¶…å¤¢", category: 'monster', level: 8, atk: 3200, def: 2000, img: "ğŸ‘½" },
            { id: 45, name: "æš´é¯‰é¾", category: 'monster', level: 7, atk: 2900, def: 1500, img: "ğŸğŸ’§" },
            { id: 46, name: "çƒˆç©ºå", category: 'monster', level: 8, atk: 3500, def: 2800, img: "ğŸŸ¢ğŸ‰" },

            // é­”æ³•å¡ (Spell) (8ç¨®) - ç°¡å–®æ•ˆæœ
            { id: 100, name: "å‚·è—¥", category: 'spell', effect: 'heal_1000', img: "ğŸ’Š", desc: "å›å¾© 1000 LPã€‚" },
            { id: 101, name: "å¥½å‚·è—¥", category: 'spell', effect: 'heal_2000', img: "ğŸ’ŠğŸ’Š", desc: "å›å¾© 2000 LPã€‚" },
            { id: 102, name: "åŠ›é‡å¼·åŒ–", category: 'spell', effect: 'atk_up_500', img: "âš”ï¸â¬†ï¸", desc: "å ´ä¸Šæ‰€æœ‰å·±æ–¹æ€ªç¸ ATK+500 (ç›´åˆ°å›åˆçµæŸ)ã€‚" },
            { id: 103, name: "ç²¾éˆçƒ", category: 'spell', effect: 'destroy_low', img: "ğŸ”´", desc: "ç ´å£å°æ‰‹å ´ä¸Šä¸€éš» 4æ˜Ÿä»¥ä¸‹çš„æ€ªç¸ã€‚" },
            { id: 104, name: "å¤§å¸«çƒ", category: 'spell', effect: 'destroy_high', img: "ğŸŸ£", desc: "ç ´å£å°æ‰‹å ´ä¸Šä¸€éš» 7æ˜Ÿä»¥ä¸Šçš„æ€ªç¸ã€‚" },

            // é™·é˜±å¡ (Trap) (7ç¨®) - è¢«æ”»æ“Šæ™‚è§¸ç™¼
            { id: 200, name: "è®Šç¡¬", category: 'trap', effect: 'def_up_1500', img: "ğŸª¨ğŸ›¡ï¸", desc: "è¢«æ”»æ“Šæ™‚ï¼Œç›®æ¨™æ€ªç¸ DEF+1500 (åƒ…æ­¤æˆ°é¬¥)ã€‚" },
            { id: 201, name: "æ›¿èº«", category: 'trap', effect: 'negate_attack', img: "ğŸ§¸", desc: "ä½¿å°æ‰‹çš„ä¸€æ¬¡æ€ªç¸æ”»æ“Šç„¡æ•ˆã€‚" },
            { id: 202, name: "åæ“Š", category: 'trap', effect: 'reflect_500', img: "â†ªï¸", desc: "è¢«æ”»æ“Šæ™‚ï¼Œå°æ‰‹å—åˆ° 500 å‚·å®³ã€‚" },
             { id: 203, name: "å…‰ç‰†", category: 'trap', effect: 'dmg_half', img: "ğŸ§±", desc: "è¢«æ”»æ“Šæ™‚ï¼Œæˆ‘æ–¹å—åˆ°çš„æˆ°é¬¥å‚·å®³æ¸›åŠã€‚" },
        ];

        class Card {
            constructor(data, owner) {
                this.uid = Math.random().toString(36).substr(2, 9);
                Object.assign(this, data); // è¤‡è£½æ‰€æœ‰è³‡æ–™å±¬æ€§
                this.owner = owner;
                this.hasAttacked = false;
                this.isFacedown = false;
                this.tempAtkBuff = 0; // ç”¨æ–¼é­”æ³•å¡åŠ æˆ
            }

            get currentAtk() { return (this.atk || 0) + this.tempAtkBuff; }

            render(location) {
                const el = document.createElement('div');
                el.className = `card`;
                el.dataset.uid = this.uid;
                el.dataset.cat = this.category;

                if (this.hasAttacked) el.classList.add('attacked');
                if (this.isFacedown && location !== 'hand') el.classList.add('facedown');

                // æ˜Ÿç´šé¡¯ç¤º
                let stars = '';
                if (this.category === 'monster') {
                    for(let i=0; i<this.level; i++) stars += 'â˜…';
                }

                el.innerHTML = `
                    <div class="slash-effect"></div>
                    <div class="card-header">${this.name}</div>
                    ${this.category === 'monster' ? `<div class="card-level">${stars}</div>` : ''}
                    <div class="card-img">${this.img}</div>
                    <div class="card-stats" style="font-size: ${this.category !== 'monster' ? '8px' : '10px'}">
                        ${this.category === 'monster' 
                            ? `<span>âš”ï¸${this.atk}</span><span>ğŸ›¡ï¸${this.def}</span>` 
                            : `<span style="text-align:center; width:100%">${this.desc || 'é­”æ³•é™·é˜±å¡'}</span>`}
                    </div>
                `;
                
                el.onclick = () => game.handleCardClick(this, location);
                return el;
            }
        }

        class Game {
            constructor() {
                this.turn = 'p1';
                this.phase = 'draw';
                this.players = {
                    p1: { lp: 8000, hand: [], field: [], st: [], deck: [] },
                    p2: { lp: 8000, hand: [], field: [], st: [], deck: [] }
                };
                this.selectedCard = null;
                this.summonState = { active: false, cardToSummon: null, tributesNeeded: 0, selectedTributes: [] };
                this.turnSummonCount = 0; // æ¯å›åˆé€šå¸¸å¬å–šæ¬¡æ•¸
                
                this.initDeck('p1');
                this.initDeck('p2');
                
                for(let i=0; i<5; i++) { this.drawCard('p1'); this.drawCard('p2'); }
                this.startTurn();
            }

            log(msg) {
                const box = document.getElementById('game-log');
                const div = document.createElement('div');
                div.className = 'log-entry';
                div.innerHTML = `[${this.turn.toUpperCase()}] ${msg}`;
                box.insertBefore(div, box.firstChild);
            }

            initDeck(player) {
                for(let i=0; i<30; i++) { // 30å¼µç‰Œçµ„
                    // å¢åŠ ä¸‹ç´šæ€ªç¸çš„æ¬Šé‡
                    let randomCard;
                    const rand = Math.random();
                    if(rand < 0.5) {
                         randomCard = CARD_DB.filter(c=>c.level<=4 && c.category==='monster')[Math.floor(Math.random() * 10)]; // å‰10å€‹ä¸‹ç´š
                    } else if (rand < 0.75) {
                         randomCard = CARD_DB.filter(c=>c.category!=='monster')[Math.floor(Math.random() * CARD_DB.filter(c=>c.category!=='monster').length)]; // é­”é™·
                    }
                    else {
                         randomCard = CARD_DB[Math.floor(Math.random() * CARD_DB.length)]; // å…¨éš¨æ©Ÿ
                    }
                    this.players[player].deck.push(randomCard);
                }
            }

            drawCard(player) {
                if (this.players[player].deck.length === 0) { this.endGame(player === 'p1' ? 'P2' : 'P1', "ç‰Œçµ„æŠ½ä¹¾"); return;}
                const data = this.players[player].deck.pop();
                this.players[player].hand.push(new Card(data, player));
                this.updateUI();
            }

            startTurn() {
                this.phase = 'draw';
                this.turnSummonCount = 0;
                this.selectedCard = null;
                this.summonState = { active: false, cardToSummon: null, tributesNeeded: 0, selectedTributes: [] };
                
                // é‡ç½®ç‹€æ…‹
                ['p1', 'p2'].forEach(p => {
                    this.players[p].field.forEach(c => {
                        c.hasAttacked = false;
                        c.tempAtkBuff = 0; // é‡ç½®å›åˆBuff
                    });
                });
                
                this.updateUI();
                this.log("å›åˆé–‹å§‹ï¼ŒæŠ½ç‰Œã€‚");
                
                setTimeout(() => {
                    this.drawCard(this.turn);
                    this.phase = 'main1';
                    this.updateUI();
                }, 800);
            }

            handleCardClick(card, location) {
                // --- ç»ç¥­æ¨¡å¼ ---
                if (this.summonState.active && location === 'field' && card.owner === this.turn) {
                    this.handleTributeSelection(card);
                    return;
                }

                // --- æ­£å¸¸æ¨¡å¼ ---
                if (card.owner === this.turn && location === 'hand') {
                    if (this.phase === 'main1' || this.phase === 'main2') {
                        if (card.category === 'monster') this.trySummonMonster(card);
                        else if (card.category === 'spell') this.activateSpell(card);
                        else if (card.category === 'trap') this.setTrap(card);
                    }
                } else if (location === 'field') {
                    // æˆ°é¬¥éšæ®µé¸æ“‡æ”»æ“Šè€…æˆ–ç›®æ¨™
                    if (this.phase === 'battle') {
                         if (card.owner === this.turn) {
                             if (!card.hasAttacked) {
                                 this.selectedCard = card;
                                 this.log(`é¸æ“‡ ${card.name} æº–å‚™æ”»æ“Šã€‚`);
                                 this.updateUI();
                             }
                         } else if (this.selectedCard) {
                             this.executeAttack(this.selectedCard, card);
                         }
                    }
                }
            }

            // --- å¬å–šç›¸é—œ ---
            trySummonMonster(card) {
                if (this.turnSummonCount >= 1) { this.log("æœ¬å›åˆå·²é€²è¡Œéé€šå¸¸å¬å–šã€‚"); return; }
                if (this.players[this.turn].field.length >= 5) { this.log("æ€ªç¸å€åŸŸå·²æ»¿ã€‚"); return; }

                let tributesNeeded = 0;
                if (card.level >= 5 && card.level <= 6) tributesNeeded = 1;
                else if (card.level >= 7) tributesNeeded = 2;

                if (tributesNeeded > 0) {
                    if (this.players[this.turn].field.length < tributesNeeded) {
                        this.log(`å¬å–š ${card.name} éœ€è¦ ${tributesNeeded} éš»ç¥­å“ï¼Œå ´ä¸Šæ€ªç¸ä¸è¶³ã€‚`);
                        return;
                    }
                    this.log(`è«‹é¸æ“‡ ${tributesNeeded} éš»æ€ªç¸ä½œç‚ºç¥­å“ç»ç¥­ã€‚`);
                    this.summonState = { active: true, cardToSummon: card, tributesNeeded: tributesNeeded, selectedTributes: [] };
                    this.selectedCard = null; // æ¸…é™¤æˆ°é¬¥é¸æ“‡
                    this.updateUI();
                } else {
                    this.summonMonster(card);
                }
            }

            handleTributeSelection(card) {
                // é¿å…é‡è¤‡é¸æ“‡
                if(this.summonState.selectedTributes.find(c => c.uid === card.uid)) return;

                this.summonState.selectedTributes.push(card);
                this.updateUI(); // æ›´æ–°é«˜äº®

                if (this.summonState.selectedTributes.length === this.summonState.tributesNeeded) {
                    // ç¥­å“è¶³å¤ ï¼ŒåŸ·è¡Œç»ç¥­å¬å–š
                    this.summonState.selectedTributes.forEach(tribute => this.destroyCard(tribute));
                    this.summonMonster(this.summonState.cardToSummon);
                    this.summonState = { active: false, cardToSummon: null, tributesNeeded: 0, selectedTributes: [] };
                }
            }

            summonMonster(card) {
                const p = this.players[this.turn];
                p.hand = p.hand.filter(c => c.uid !== card.uid);
                p.field.push(card);
                this.turnSummonCount++;
                this.log(`å¬å–šäº† ${card.name}ï¼`);
                this.updateUI();
            }

            // --- é­”æ³•é™·é˜±ç›¸é—œ ---
            activateSpell(card) {
                 const p = this.players[this.turn];
                 p.hand = p.hand.filter(c => c.uid !== card.uid); // å¾æ‰‹ç‰Œç§»é™¤ï¼Œé€å…¥å¢“åœ°(ç°¡åŒ–ç‚ºæ¶ˆå¤±)
                 this.log(`ç™¼å‹•é­”æ³•å¡ï¼š${card.name}ï¼`);
                 
                 // é­”æ³•æ•ˆæœå¯¦ç¾
                 switch(card.effect) {
                     case 'heal_1000': this.damageLP(this.turn, -1000); break;
                     case 'heal_2000': this.damageLP(this.turn, -2000); break;
                     case 'atk_up_500':
                         p.field.forEach(m => m.tempAtkBuff += 500);
                         this.log("æˆ‘æ–¹å…¨é«”æ€ªç¸ ATK ä¸Šå‡ 500ï¼");
                         break;
                     // ç°¡åŒ–ç‰ˆç ´å£æ•ˆæœï¼Œéš¨æ©Ÿç ´å£ç¬¦åˆæ¢ä»¶çš„ä¸€éš»
                     case 'destroy_low':
                         const opp = this.turn === 'p1' ? 'p2' : 'p1';
                         const lowTargets = this.players[opp].field.filter(c => c.level <= 4);
                         if(lowTargets.length > 0) {
                             const target = lowTargets[Math.floor(Math.random() * lowTargets.length)];
                             this.destroyCard(target);
                             this.log(`ç ´å£äº†å°æ‰‹çš„ ${target.name}ï¼`);
                         } else this.log("å°æ‰‹å ´ä¸Šæ²’æœ‰ç¬¦åˆæ¢ä»¶çš„æ€ªç¸ã€‚");
                         break;
                 }
                 this.updateUI();
            }

            setTrap(card) {
                const p = this.players[this.turn];
                if(p.st.length >= 5) { this.log("é­”æ³•é™·é˜±å€å·²æ»¿ã€‚"); return; }
                p.hand = p.hand.filter(c => c.uid !== card.uid);
                card.isFacedown = true;
                p.st.push(card);
                this.log(`è¦†è“‹äº†ä¸€å¼µå¡ç‰‡åˆ°å¾Œå ´ã€‚`);
                this.updateUI();
            }

            // --- æˆ°é¬¥æµç¨‹ ---
            enterBattlePhase() {
                if (this.phase !== 'main1') return;
                this.phase = 'battle';
                this.selectedCard = null;
                this.log("é€²å…¥æˆ°é¬¥éšæ®µï¼");
                this.updateUI();
            }
            
            enterMainPhase2() {
                 if (this.phase !== 'battle') return;
                 this.phase = 'main2';
                 this.selectedCard = null;
                 this.log("é€²å…¥ä¸»è¦éšæ®µ 2ã€‚");
                 this.updateUI();
            }

            async executeAttack(attacker, target) {
                attacker.hasAttacked = true;
                this.selectedCard = null;
                this.log(`${attacker.name} (ATK:${attacker.currentAtk}) æ”»æ“Š ${target.name} (DEF:${target.def})ï¼`);

                // --- è§¸ç™¼é™·é˜±å¡ ---
                const defender = target.owner;
                const traps = this.players[defender].st.filter(c => c.isFacedown && c.category === 'trap');
                let attackNegated = false;
                let damageMultiplier = 1;
                let reflectDamage = 0;
                let defenseBuff = 0;

                if (traps.length > 0) {
                    // ç°¡å–®èµ·è¦‹ï¼Œè§¸ç™¼ç¬¬ä¸€å¼µå¯ç”¨çš„é™·é˜±
                    const trap = traps[0];
                    trap.isFacedown = false; // ç¿»é–‹
                    this.log(`å°æ‰‹ç™¼å‹•é™·é˜±å¡ï¼š${trap.name}ï¼`);
                    
                    switch(trap.effect) {
                        case 'negate_attack': attackNegated = true; this.log("æ”»æ“Šç„¡æ•ˆåŒ–ï¼"); break;
                        case 'def_up_1500': defenseBuff = 1500; this.log(`${target.name} çš„ DEF ä¸Šå‡ 1500ï¼`); break;
                        case 'reflect_500': reflectDamage = 500; break;
                        case 'dmg_half': damageMultiplier = 0.5; this.log("æˆ°é¬¥å‚·å®³æ¸›åŠï¼"); break;
                    }
                    // ç§»é™¤ç™¼å‹•å¾Œçš„é™·é˜±
                    this.players[defender].st = this.players[defender].st.filter(c => c.uid !== trap.uid);
                    this.updateUI();
                    await new Promise(r => setTimeout(r, 800)); // ç­‰å¾…é™·é˜±å‹•ç•«å±•ç¤º
                }

                if (attackNegated) { this.updateUI(); return; }

                // --- æ’­æ”¾æ”»æ“Š VFX ---
                await this.playAttackVFX(target);

                // --- å‚·å®³è¨ˆç®— ---
                const finalDef = target.def + defenseBuff;
                if (attacker.currentAtk > finalDef) {
                    const damage = (attacker.currentAtk - finalDef) * damageMultiplier;
                    this.damageLP(target.owner, damage);
                    this.destroyCard(target);
                    this.log(`${target.name} è¢«ç ´å£ï¼å°æ‰‹å—åˆ° ${damage} å‚·å®³ã€‚`);
                } else if (attacker.currentAtk < finalDef) {
                    const damage = (finalDef - attacker.currentAtk) * damageMultiplier;
                    this.damageLP(attacker.owner, damage);
                    this.log(`æ”»æ“Šæœªç ´é˜²ï¼æˆ‘æ–¹å—åˆ° ${damage} åå‚·ã€‚`);
                } else {
                    this.log("æ”»æ“ŠåŠ›èˆ‡å®ˆå‚™åŠ›ç›¸åŒï¼Œç„¡äº‹ç™¼ç”Ÿã€‚");
                }

                if(reflectDamage > 0) {
                    this.damageLP(attacker.owner, reflectDamage);
                    this.log(`å—åˆ°é™·é˜±å¡åæ“Šï¼Œæå‚· ${reflectDamage}ï¼`);
                }

                this.updateUI();
                this.checkWinCondition();
            }

            async playAttackVFX(targetCard) {
                const cardEl = document.querySelector(`.card[data-uid="${targetCard.uid}"]`);
                if(cardEl) {
                    cardEl.classList.add('slashing');
                    // ç­‰å¾…å‹•ç•« CSS çµæŸ (0.6s)
                    await new Promise(resolve => setTimeout(() => {
                        cardEl.classList.remove('slashing');
                        resolve();
                    }, 600));
                }
            }

            directAttack() {
                if (this.phase !== 'battle' || !this.selectedCard) return;
                const opponent = this.turn === 'p1' ? 'p2' : 'p1';
                if (this.players[opponent].field.length === 0) {
                    const dmg = this.selectedCard.currentAtk;
                    this.selectedCard.hasAttacked = true;
                    this.damageLP(opponent, dmg);
                    this.log(`${this.selectedCard.name} ç›´æ¥æ”»æ“Šï¼é€ æˆ ${dmg} å‚·å®³ï¼`);
                    this.selectedCard = null;
                    this.updateUI();
                    this.checkWinCondition();
                }
            }

            // --- è¼”åŠ©åŠŸèƒ½ ---
            destroyCard(card) {
                const p = this.players[card.owner];
                p.field = p.field.filter(c => c.uid !== card.uid);
            }

            damageLP(player, amount) {
                this.players[player].lp = Math.max(0, this.players[player].lp - amount);
            }

            checkWinCondition() {
                if (this.players.p1.lp <= 0) this.endGame('P2');
                else if (this.players.p2.lp <= 0) this.endGame('P1');
            }

            endGame(winner, reason="") {
                document.getElementById('winner-overlay').style.display = 'flex';
                document.getElementById('winner-text').innerHTML = `${winner} ç²å‹!<br><span style="font-size:20px">${reason}</span>`;
            }

            endTurn() {
                this.turn = this.turn === 'p1' ? 'p2' : 'p1';
                this.startTurn();
            }

            updateUI() {
                document.getElementById('p1-lp').innerText = this.players.p1.lp;
                document.getElementById('p2-lp').innerText = this.players.p2.lp;
                document.getElementById('current-phase').innerText = this.getPhaseName();
                document.getElementById('current-player').innerText = this.turn.toUpperCase();
                
                document.getElementById('btn-battle').disabled = (this.phase !== 'main1');
                document.getElementById('btn-main2').disabled = (this.phase !== 'battle');
                
                document.getElementById('p1-zone').className = `player-zone p1-zone ${this.turn === 'p1' ? 'active-turn' : ''}`;
                document.getElementById('p2-zone').className = `player-zone p2-zone ${this.turn === 'p2' ? 'active-turn' : ''}`;

                const renderZone = (zoneId, cards, loc) => {
                    const container = document.getElementById(zoneId);
                    container.innerHTML = '';
                    cards.forEach(card => {
                        const el = card.render(loc);
                        if (this.selectedCard && this.selectedCard.uid === card.uid) el.classList.add('selected');
                        // ç»ç¥­é¸æ“‡é«˜äº®
                        if (this.summonState.active && loc === 'field' && card.owner === this.turn) {
                            if(this.summonState.selectedTributes.find(c=>c.uid === card.uid)) {
                                 el.classList.add('tribute-target'); // å·²é¸ä¸­
                            } else {
                                 el.style.borderColor = '#00ff00'; // å¯é¸æ“‡
                                 el.style.boxShadow = '0 0 10px #00ff00';
                            }
                        }
                        container.appendChild(el);
                    });
                };

                renderZone('p1-hand', this.players.p1.hand, 'hand');
                renderZone('p1-field', this.players.p1.field, 'field');
                renderZone('p1-st', this.players.p1.st, 'st');
                renderZone('p2-hand', this.players.p2.hand, 'hand');
                renderZone('p2-field', this.players.p2.field, 'field');
                renderZone('p2-st', this.players.p2.st, 'st');
            }
            
            getPhaseName() {
                switch(this.phase) {
                    case 'draw': return 'æŠ½ç‰Œéšæ®µ';
                    case 'main1': return 'ä¸»è¦éšæ®µ 1';
                    case 'battle': return 'æˆ°é¬¥éšæ®µ';
                    case 'main2': return 'ä¸»è¦éšæ®µ 2';
                    default: return '';
                }
            }
        }

        const game = new Game();

        // ç›´æ¥æ”»æ“Šè§¸ç™¼å€
        document.getElementById('p2-zone').onclick = (e) => {
            if ((e.target.id === 'p2-zone' || e.target.classList.contains('field-row')) && game.turn === 'p1') game.directAttack();
        };
        document.getElementById('p1-zone').onclick = (e) => {
             if ((e.target.id === 'p1-zone' || e.target.classList.contains('field-row')) && game.turn === 'p2') game.directAttack();
        };

    </script>
</body>
</html>
