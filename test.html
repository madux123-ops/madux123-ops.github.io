<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>忍者卷軸：影之戰 (觸控版)</title>
    <style>
        body {
            background-color: #222;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* 改為靠上對齊 */
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none; /* 禁止手機預設滑動行為 */
            padding-top: 10px; /* 僅保留少許頂部空間 */
        }

        /* 遊戲畫面設定 */
        canvas {
            background-color: #000;
            border: 2px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            /* 讓 Canvas 在小螢幕自動縮放，但保持比例 */
            max-width: 100%; 
            max-height: 65vh; /* 留空間給下方按鈕 */
            width: auto;
            height: auto;
            object-fit: contain;
        }

        #ui-layer {
            width: 100%;
            max-width: 480px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            margin-bottom: 5px;
            padding: 0 10px;
            box-sizing: border-box;
        }

        /* 控制器區域容器 */
        #controls-area {
            position: fixed;
            bottom: 10px;
            left: 0;
            width: 100%;
            height: 160px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none; /* 讓點擊穿透空白處 */
        }

        /* 左側動作按鈕區 (Z, X) */
        .action-pad {
            pointer-events: auto;
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        /* 右側方向鍵區 */
        .d-pad {
            pointer-events: auto;
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 50px 50px 50px;
            gap: 5px;
            margin-bottom: 10px;
        }

        /* 按鈕共用樣式 */
        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            user-select: none;
            cursor: pointer;
            transition: background 0.1s;
        }
        
        .btn:active, .btn.active {
            background: rgba(255, 255, 255, 0.5);
            color: #000;
        }

        /* 動作按鈕大小 */
        .btn-action {
            width: 70px;
            height: 70px;
            background: rgba(255, 50, 50, 0.2); /* 微紅 */
        }

        /* 方向鍵特定位置與樣式 */
        .btn-arrow {
            width: 60px;
            height: 50px;
            border-radius: 10px;
            background: rgba(50, 150, 255, 0.2); /* 微藍 */
        }
        
        /* Grid定位 */
        .up { grid-column: 2; grid-row: 1; }
        .left { grid-column: 1; grid-row: 2; }
        .down { grid-column: 2; grid-row: 3; }
        .right { grid-column: 3; grid-row: 2; }

    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="score">分數: 0</div>
        <div id="lives">生命: 3</div>
        <div id="bombs">炸彈: 5</div>
    </div>

    <canvas id="gameCanvas" width="480" height="640"></canvas>

    <div id="controls-area">
        <div class="action-pad">
            <div class="btn btn-action" id="btn-x" data-key="x">X<br><span style="font-size:10px">炸彈</span></div>
            <div class="btn btn-action" id="btn-z" data-key="z">Z<br><span style="font-size:10px">攻擊</span></div>
        </div>

        <div class="d-pad">
            <div class="btn btn-arrow up" id="btn-up" data-key="ArrowUp">▲</div>
            <div class="btn btn-arrow left" id="btn-left" data-key="ArrowLeft">◀</div>
            <div class="btn btn-arrow right" id="btn-right" data-key="ArrowRight">▶</div>
            <div class="btn btn-arrow down" id="btn-down" data-key="ArrowDown">▼</div>
        </div>
    </div>

<script>
/** 遊戲核心設定 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 遊戲狀態
let gameState = 'MENU';
let frameCount = 0;
let score = 0;
let level = 1;
let killCount = 0;
const KILLS_TO_BOSS = 30;

// 輸入控制
const keys = {
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false,
    z: false, x: false
};

// 實體列表
let player;
let bullets = [];
let enemyBullets = [];
let enemies = [];
let items = [];
let particles = [];
let boss = null;
let warningZones = [];

// --- 輸入處理 (整合鍵盤與觸控) ---

function handleKey(key, isPressed) {
    if (keys.hasOwnProperty(key)) keys[key] = isPressed;

    // 狀態切換邏輯
    if (isPressed) {
        if (gameState === 'MENU' && key === 'z') {
            initGame();
        } else if (gameState === 'GAMEOVER') {
            if (key === 'z') { 
                 player.lives = 3; 
                 player.hp = 100;
                 score = 0; 
                 resetLevel();
            } else if (key === 'x') { 
                 initGame();
            }
        } else if (gameState === 'LEVEL_CLEAR' && key === 'z') {
            nextLevel();
        }
    }

    // 射擊與炸彈重置邏輯
    if (!isPressed) {
        if (key === 'z' && player) player.canShoot = true;
        if (key === 'x' && player) player.canBomb = true;
    }
}

// 1. 鍵盤監聽
window.addEventListener('keydown', e => handleKey(e.key, true));
window.addEventListener('keyup', e => handleKey(e.key, false));

// 2. 觸控按鈕綁定
const touchButtons = document.querySelectorAll('.btn');

touchButtons.forEach(btn => {
    const key = btn.dataset.key;
    
    // 滑鼠/手指按下
    const pressHandler = (e) => {
        e.preventDefault(); // 防止長按跳出選單
        handleKey(key, true);
        btn.classList.add('active');
    };

    // 滑鼠/手指放開
    const releaseHandler = (e) => {
        e.preventDefault();
        handleKey(key, false);
        btn.classList.remove('active');
    };

    btn.addEventListener('mousedown', pressHandler);
    btn.addEventListener('touchstart', pressHandler);

    btn.addEventListener('mouseup', releaseHandler);
    btn.addEventListener('touchend', releaseHandler);
    btn.addEventListener('mouseleave', releaseHandler); // 滑出按鈕範圍視為放開
});


/** 類別定義 (與之前相同，略做視覺調整) */

class Player {
    constructor() {
        this.w = 30;
        this.h = 30;
        this.x = canvas.width / 2 - this.w / 2;
        this.y = canvas.height - 100;
        this.speed = 5;
        this.color = '#00ff00';
        this.lives = 3;
        this.hp = 100;
        this.weaponLevel = 1;
        this.bombs = 5;
        this.canShoot = true;
        this.canBomb = true;
        this.invincibleTimer = 0;
    }

    update() {
        // 移動
        if (keys.ArrowUp && this.y > 0) this.y -= this.speed;
        if (keys.ArrowDown && this.y < canvas.height - this.h) this.y += this.speed;
        if (keys.ArrowLeft && this.x > 0) this.x -= this.speed;
        if (keys.ArrowRight && this.x < canvas.width - this.w) this.x += this.speed;

        // 射擊 (Z)
        if (keys.z && this.canShoot) {
            this.shoot();
            if (this.weaponLevel < 2) this.canShoot = false; 
            if (this.weaponLevel >= 2 && frameCount % 8 !== 0) return; 
        }

        // 炸彈 (X)
        if (keys.x && this.canBomb && this.bombs > 0) {
            this.useBomb();
            this.canBomb = false;
        }

        if (this.invincibleTimer > 0) this.invincibleTimer--;
    }

    draw() {
        if (this.invincibleTimer > 0 && Math.floor(frameCount / 4) % 2 === 0) return;
        
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y + 5, this.w, 5);
        
        // 血條
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x, this.y + this.h + 5, this.w, 4);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(this.x, this.y + this.h + 5, this.w * (this.hp / 100), 4);
    }

    shoot() {
        let speed = 10;
        if (this.weaponLevel === 1) {
            bullets.push(new Bullet(this.x + this.w/2, this.y, 0, -speed, 'player'));
        }
        else if (this.weaponLevel === 2) {
             bullets.push(new Bullet(this.x + this.w/2, this.y, 0, -12, 'player'));
        }
        else if (this.weaponLevel === 3) {
            bullets.push(new Bullet(this.x + 5, this.y, 0, -speed, 'player'));
            bullets.push(new Bullet(this.x + this.w - 5, this.y, 0, -speed, 'player'));
        }
        else {
            bullets.push(new Bullet(this.x + this.w/2, this.y, 0, -speed, 'player'));
            bullets.push(new Bullet(this.x + this.w/2, this.y, -3, -speed * 0.9, 'player'));
            bullets.push(new Bullet(this.x + this.w/2, this.y, 3, -speed * 0.9, 'player'));
        }
    }

    useBomb() {
        this.bombs--;
        updateUI();
        createExplosion(canvas.width/2, canvas.height/2, 500, '#FFF', 20);
        enemyBullets = [];
        enemies.forEach(e => {
            e.takeDamage(50);
            createExplosion(e.x + e.w/2, e.y + e.h/2, 50, '#FFA500', 10);
        });
        if(boss) {
            boss.takeDamage(100);
            createExplosion(boss.x + boss.w/2, boss.y + boss.h/2, 100, '#FFA500', 20);
        }
    }

    takeDamage(amount) {
        if (this.invincibleTimer > 0) return;
        this.hp -= amount;
        if (this.hp <= 0) {
            this.lives--;
            updateUI();
            createExplosion(this.x + this.w/2, this.y + this.h/2, 50, '#0f0', 20);
            
            if (this.lives < 0) {
                gameState = 'GAMEOVER';
            } else {
                this.hp = 100;
                this.x = canvas.width / 2 - this.w / 2;
                this.y = canvas.height - 100;
                this.invincibleTimer = 120;
                this.weaponLevel = Math.max(1, this.weaponLevel - 1);
            }
        } else {
            this.invincibleTimer = 30;
        }
    }
}

class Bullet {
    constructor(x, y, vx, vy, owner) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.owner = owner;
        this.r = 4; this.markedForDeletion = false;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        if (this.x < 0 || this.x > canvas.width || this.y < 0 || this.y > canvas.height) this.markedForDeletion = true;
    }
    draw() {
        ctx.beginPath();
        if (this.owner === 'player') {
            ctx.fillStyle = '#FFFF00';
            ctx.moveTo(this.x, this.y - 5);
            ctx.lineTo(this.x + 5, this.y);
            ctx.lineTo(this.x, this.y + 5);
            ctx.lineTo(this.x - 5, this.y);
        } else {
            ctx.fillStyle = '#FF4444';
            ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2);
        }
        ctx.fill();
    }
}

class Enemy {
    constructor(type) {
        this.w = 30; this.h = 30;
        this.x = Math.random() * (canvas.width - this.w);
        this.y = -40;
        this.hp = 3;
        this.type = type || 'normal';
        this.vy = 2 + Math.random() * 2;
        this.vx = (Math.random() - 0.5) * 1;
        this.markedForDeletion = false;
        this.shootTimer = Math.random() * 60;
    }
    update() {
        this.y += this.vy; this.x += this.vx;
        if (this.x <= 0 || this.x >= canvas.width - this.w) this.vx *= -1;
        if (this.y > canvas.height) this.markedForDeletion = true;

        this.shootTimer--;
        if (this.shootTimer <= 0) {
            if (this.type === 'shooter') {
                enemyBullets.push(new Bullet(this.x + this.w/2, this.y + this.h, 0, 5, 'enemy'));
                this.shootTimer = 100;
            } else if (this.type === 'normal' && Math.random() < 0.3) {
                enemyBullets.push(new Bullet(this.x + this.w/2, this.y + this.h, 0, 4, 'enemy'));
                this.shootTimer = 150;
            }
        }
    }
    draw() {
        ctx.fillStyle = this.type === 'shooter' ? '#c0392b' : '#d35400';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x + 5, this.y + 10, 8, 5);
        ctx.fillRect(this.x + 18, this.y + 10, 8, 5);
    }
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            this.markedForDeletion = true;
            score += 100;
            killCount++;
            if (Math.random() < 0.1) {
                let itemType = Math.random() < 0.7 ? 'power' : 'bomb';
                items.push(new Item(this.x, this.y, itemType));
            }
            createExplosion(this.x + this.w/2, this.y + this.h/2, 20, '#FFA500', 5);
            updateUI();
        }
    }
}

class Boss {
    constructor() {
        this.w = 80; this.h = 60;
        this.x = canvas.width / 2 - this.w / 2;
        this.y = -100;
        this.maxHp = 500 * level;
        this.hp = this.maxHp;
        this.state = 'enter';
        this.timer = 0;
        this.moveDir = 1;
    }
    update() {
        this.timer++;
        if (this.state === 'enter') {
            this.y += 2;
            if (this.y >= 50) this.state = 'idle';
        } else if (this.state === 'idle') {
            this.x += 2 * this.moveDir;
            if (this.x <= 0 || this.x >= canvas.width - this.w) this.moveDir *= -1;
            if (this.timer % 120 === 0) {
                let rand = Math.random();
                if (rand < 0.4) this.state = 'prepare_laser';
                else if (rand < 0.7) this.state = 'summon';
                else this.state = 'spread_shot';
            }
        } else if (this.state === 'prepare_laser') {
            warningZones.push(new WarningZone(player.x - 20, 0, 70, canvas.height, 60));
            this.state = 'idle';
        } else if (this.state === 'summon') {
            enemies.push(new Enemy('shooter'));
            enemies.push(new Enemy('normal'));
            this.state = 'idle';
        } else if (this.state === 'spread_shot') {
            for(let i=-2; i<=2; i++) {
                enemyBullets.push(new Bullet(this.x + this.w/2, this.y + this.h, i, 4, 'enemy'));
            }
            this.state = 'idle';
        }
    }
    draw() {
        ctx.fillStyle = '#8e44ad';
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(this.x + 10, this.y + 10, this.w - 20, 10);
        ctx.fillStyle = '#555';
        ctx.fillRect(0, 0, canvas.width, 10);
        ctx.fillStyle = '#e74c3c';
        ctx.fillRect(0, 0, canvas.width * (this.hp / this.maxHp), 10);
    }
    takeDamage(amount) {
        this.hp -= amount;
        if (this.hp <= 0) {
            score += 5000;
            createExplosion(this.x + this.w/2, this.y + this.h/2, 200, '#FFF', 50);
            boss = null;
            gameState = 'LEVEL_CLEAR';
        }
    }
}

class WarningZone {
    constructor(x, y, w, h, duration) {
        this.x = x; this.y = y; this.w = w; this.h = h;
        this.timer = duration; this.maxTimer = duration; this.active = true;
    }
    update() {
        this.timer--;
        if (this.timer <= 0) {
            if (rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
                player.takeDamage(30);
            }
            createExplosion(this.x + this.w/2, player.y, 50, '#FF4444', 10);
            this.active = false;
        }
    }
    draw() {
        ctx.save();
        let alpha = (this.timer / this.maxTimer) * 0.5 + 0.2;
        ctx.fillStyle = `rgba(255, 0, 0, ${alpha})`;
        ctx.fillRect(this.x, this.y, this.w, this.h);
        ctx.strokeStyle = 'red';
        ctx.strokeRect(this.x, this.y, this.w, this.h);
        ctx.restore();
    }
}

class Item {
    constructor(x, y, type) {
        this.x = x; this.y = y; this.type = type;
        this.w = 20; this.h = 20; this.vy = 2; this.markedForDeletion = false;
    }
    update() {
        this.y += this.vy;
        if (this.y > canvas.height) this.markedForDeletion = true;
        if (rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
            if (this.type === 'power') {
                player.weaponLevel = Math.min(player.weaponLevel + 1, 4);
                score += 200;
            } else if (this.type === 'bomb') {
                player.bombs++;
            }
            updateUI();
            this.markedForDeletion = true;
        }
    }
    draw() {
        ctx.font = '20px Arial';
        if (this.type === 'power') {
            ctx.fillStyle = 'red';
            ctx.fillText('P', this.x, this.y + 20);
        } else {
            ctx.fillStyle = 'blue';
            ctx.fillText('B', this.x, this.y + 20);
        }
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 6; this.vy = (Math.random() - 0.5) * 6;
        this.life = 30; this.color = color;
    }
    update() { this.x += this.vx; this.y += this.vy; this.life--; }
    draw() { ctx.fillStyle = this.color; ctx.globalAlpha = this.life / 30; ctx.fillRect(this.x, this.y, 4, 4); ctx.globalAlpha = 1; }
}

function createExplosion(x, y, count, color, range) {
    for(let i=0; i<count; i++) particles.push(new Particle(x + (Math.random()-0.5)*range, y + (Math.random()-0.5)*range, color));
}
function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}
function updateUI() {
    document.getElementById('score').innerText = `分數: ${score}`;
    document.getElementById('lives').innerText = `生命: ${player.lives}`;
    document.getElementById('bombs').innerText = `炸彈: ${player.bombs}`;
}
function initGame() {
    score = 0; level = 1; killCount = 0;
    player = new Player();
    resetLevel();
}
function resetLevel() {
    bullets = []; enemyBullets = []; enemies = []; items = []; particles = []; warningZones = [];
    boss = null;
    gameState = 'PLAYING';
    updateUI();
}
function nextLevel() {
    level++; killCount = 0; player.hp = 100; resetLevel();
}

function gameLoop() {
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'MENU') {
        ctx.fillStyle = 'white';
        ctx.font = '30px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('忍者卷軸：影之戰', canvas.width/2, canvas.height/2 - 40);
        ctx.font = '20px sans-serif';
        ctx.fillText('點擊下方 Z 鍵開始', canvas.width/2, canvas.height/2 + 20);
    } 
    else if (gameState === 'PLAYING') {
        frameCount++;
        if (!boss && enemies.length < 5 + level && Math.random() < 0.02) {
            let type = Math.random() > 0.8 ? 'shooter' : 'normal';
            enemies.push(new Enemy(type));
        }
        if (!boss && killCount >= KILLS_TO_BOSS * level) boss = new Boss();

        player.update(); player.draw();
        if (boss) { boss.update(); boss.draw(); }

        warningZones.forEach((z, i) => { z.update(); z.draw(); if (!z.active) warningZones.splice(i, 1); });
        bullets.forEach((b, i) => { b.update(); b.draw(); if (b.markedForDeletion) bullets.splice(i, 1); });
        enemyBullets.forEach((b, i) => { 
            b.update(); b.draw(); 
            if (b.markedForDeletion) enemyBullets.splice(i, 1);
            else if (rectIntersect(b.x, b.y, b.r*2, b.r*2, player.x, player.y, player.w, player.h)) {
                player.takeDamage(10); b.markedForDeletion = true;
            }
        });
        enemies.forEach((e, i) => {
            e.update(); e.draw();
            if (e.markedForDeletion) enemies.splice(i, 1);
            if (rectIntersect(e.x, e.y, e.w, e.h, player.x, player.y, player.w, player.h)) {
                player.takeDamage(20); e.takeDamage(10);
            }
        });
        items.forEach((item, i) => { item.update(); item.draw(); if (item.markedForDeletion) items.splice(i, 1); });
        particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });

        bullets.forEach(b => {
            enemies.forEach(e => {
                if (rectIntersect(b.x, b.y, 4, 10, e.x, e.y, e.w, e.h)) {
                    e.takeDamage(1); b.markedForDeletion = true;
                    createExplosion(b.x, b.y, 2, '#fff', 5);
                }
            });
            if (boss && rectIntersect(b.x, b.y, 4, 10, boss.x, boss.y, boss.w, boss.h)) {
                 boss.takeDamage(1); b.markedForDeletion = true;
                 createExplosion(b.x, b.y, 2, '#fff', 5);
            }
        });
    } 
    else if (gameState === 'GAMEOVER') {
        ctx.fillStyle = 'red';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('勝敗乃兵家常事', canvas.width/2, canvas.height/2 - 20);
        ctx.fillStyle = 'white';
        ctx.font = '20px sans-serif';
        ctx.fillText('Z: 接關  |  X: 重來', canvas.width/2, canvas.height/2 + 40);
    }
    else if (gameState === 'LEVEL_CLEAR') {
        ctx.fillStyle = '#2ecc71';
        ctx.font = '40px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(`第 ${level} 關 通過!`, canvas.width/2, canvas.height/2 - 20);
        ctx.font = '20px sans-serif';
        ctx.fillText('按 Z 進入下一關', canvas.width/2, canvas.height/2 + 40);
    }

    requestAnimationFrame(gameLoop);
}

requestAnimationFrame(gameLoop);

</script>
</body>
</html>
