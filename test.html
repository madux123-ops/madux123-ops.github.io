<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>鬼滅之刃：無限城決戰篇 (RPG版)</title>
    <style>
        /* --- 全局設定 --- */
        body {
            font-family: 'Microsoft JhengHei', sans-serif;
            background-color: #111;
            color: #eee;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 10px;
            /* 背景：深色日式紋理 */
            background-image: radial-gradient(#333 15%, transparent 16%), radial-gradient(#333 15%, transparent 16%);
            background-size: 20px 20px;
            background-position: 0 0, 10px 10px;
        }

        h1 { margin: 5px 0; color: #ffcc00; text-shadow: 2px 2px #000; }
        .sub-header { color: #aaa; font-size: 0.9em; margin-bottom: 10px; }

        /* --- 遊戲主容器 --- */
        #game-wrapper {
            display: flex;
            gap: 15px;
            align-items: flex-start;
        }

        /* --- 戰棋地圖 --- */
        #grid-container {
            display: grid;
            grid-template-columns: repeat(10, 45px); /* 10x10, 每格 45px */
            grid-template-rows: repeat(10, 45px);
            gap: 2px;
            background-color: #222;
            border: 4px solid #555;
            padding: 2px;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
        }

        .tile {
            width: 45px;
            height: 45px;
            background-color: #3d3d3d;
            border: 1px solid #4d4d4d;
            position: relative;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .tile.movable { background-color: rgba(100, 200, 255, 0.3); box-shadow: inset 0 0 5px #4a90e2; }
        .tile.attackable { background-color: rgba(255, 80, 80, 0.3); box-shadow: inset 0 0 5px #e74c3c; }

        /* --- 單位樣式 --- */
        .unit {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 16px;
            z-index: 2;
            position: relative;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.8);
            border: 2px solid #fff;
        }

        /* 我方角色配色 */
        .unit.tanjiro { background: linear-gradient(135deg, #2e8b57, #000); border-color: #00bfff; }
        .unit.zenitsu { background: linear-gradient(135deg, #ffd700, #ff8c00); border-color: #fff; color: #000; }
        .unit.inosuke { background: linear-gradient(135deg, #708090, #4682b4); border-color: #dcdcdc; }

        /* 敵方配色 */
        .unit.demon { background: #555; border-color: #888; color: #bbb; font-size: 12px; }
        .unit.boss { background: linear-gradient(135deg, #800000, #ff0000); border-color: #ff4d4d; font-size: 18px; color: #fff; }

        .unit.active { box-shadow: 0 0 10px 3px yellow; transform: scale(1.1); z-index: 10; }
        .unit.done { filter: grayscale(80%); opacity: 0.7; }

        /* 血條與等級 */
        .hp-bar-bg {
            position: absolute; bottom: -4px; left: 0; width: 100%; height: 4px; background: #000;
        }
        .hp-bar-fill { height: 100%; background: #0f0; transition: width 0.2s; }
        .unit.demon .hp-bar-fill, .unit.boss .hp-bar-fill { background: #f00; }
        
        .lvl-badge {
            position: absolute; top: -5px; right: -5px;
            background: #000; color: #fff; font-size: 10px;
            padding: 1px 3px; border-radius: 3px; border: 1px solid #aaa;
        }

        /* --- UI 面板 --- */
        #ui-panel {
            width: 260px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .panel-box {
            background: #2a2a2a; border: 1px solid #444; padding: 10px; border-radius: 5px;
        }
        .panel-title { color: #ffcc00; border-bottom: 1px solid #555; padding-bottom: 5px; margin-bottom: 5px; font-size: 0.95em; }

        #action-menu { display: none; flex-direction: column; gap: 5px; }
        button {
            padding: 8px; cursor: pointer; background: #333; color: white; border: 1px solid #555; border-radius: 4px;
        }
        button:hover { background: #444; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        .skill-btn { background: #1a3c5e; border-color: #4a90e2; }

        #log-window {
            height: 120px; overflow-y: auto; font-size: 0.85em; color: #ccc; background: #1a1a1a; padding: 5px; border: 1px solid #333;
        }
        .log-lvlup { color: #ffd700; font-weight: bold; }
        .log-dmg { color: #ff4d4d; }
        .log-stage { color: #00ff00; font-weight: bold; text-align: center; margin: 5px 0; border-top: 1px dashed #555; }

    </style>
</head>
<body>

    <h1>鬼滅之刃：無限城決戰 RPG</h1>
    <div class="sub-header" id="stage-indicator">第 1 關 - 那田蜘蛛山外圍</div>

    <div id="game-wrapper">
        <div id="grid-container"></div>

        <div id="ui-panel">
            <div class="panel-box">
                <div class="panel-title">回合資訊</div>
                <div id="turn-info">準備開始...</div>
            </div>

            <div class="panel-box">
                <div class="panel-title">選中單位</div>
                <div id="unit-stats" style="font-size: 0.9em; line-height: 1.4;">點擊單位查看數值</div>
            </div>

            <div class="panel-box" id="action-box">
                <div class="panel-title">指令</div>
                <div id="action-menu">
                    <button id="btn-move">移動 (2格)</button>
                    <button id="btn-attack">攻擊</button>
                    <button id="btn-skill" class="skill-btn">戰技</button>
                    <button id="btn-wait">待機</button>
                </div>
            </div>

            <div class="panel-box">
                <div class="panel-title">戰鬥紀錄</div>
                <div id="log-window"></div>
            </div>
        </div>
    </div>

<script>
    // --- 遊戲常數 ---
    const GRID_SIZE = 10;
    const MAX_LEVEL = 9;
    
    // --- 類別定義 ---
    class Unit {
        constructor(id, name, type, role, x, y, stats) {
            this.id = id;
            this.name = name;
            this.type = type; // 'slayer' or 'demon'
            this.role = role; // 'tanjiro', 'zenitsu', 'inosuke', 'grunt', 'boss'
            this.x = x;
            this.y = y;
            
            // 基礎數值
            this.level = stats.level || 1;
            this.maxHp = stats.hp;
            this.hp = stats.hp;
            this.atk = stats.atk;
            this.def = stats.def;
            this.range = stats.range || 1; // 攻擊距離
            this.isAoE = stats.isAoE || false; // 是否範圍攻擊
            
            // 成長系統
            this.xp = 0;
            this.maxXp = 100 * this.level;
            
            // 狀態旗標
            this.hasMoved = false;
            this.hasActed = false;
        }

        // 獲得經驗值與升級邏輯
        gainXp(amount) {
            if (this.type !== 'slayer') return;
            
            this.xp += amount;
            addLog(`${this.name} 獲得 ${amount} EXP`);

            if (this.xp >= this.maxXp) {
                this.levelUp();
            }
        }

        levelUp() {
            this.level++;
            this.xp = 0;
            this.maxXp = Math.floor(this.maxXp * 1.2);
            
            // 屬性成長 (約 15-20%)
            this.maxHp = Math.floor(this.maxHp * 1.2);
            this.atk = Math.floor(this.atk * 1.15);
            this.def = Math.floor(this.def * 1.15);
            
            // 升級回滿血
            this.hp = this.maxHp;
            
            addLog(`<div class="log-lvlup">✨ ${this.name} 升到了 Lv.${this.level}！能力提升，體力全滿！</div>`);
            renderGrid(); // 更新血條與等級顯示
        }
    }

    // --- 全局變數 ---
    let gridElements = [];
    let allies = []; // 我方隊伍 (永久保存)
    let enemies = []; // 敵方隊伍 (每關重置)
    let allUnits = []; // 當前場上所有單位
    let currentLevel = 1;
    let turnIndex = 0;
    let gameState = 'IDLE'; // IDLE, MOVING, TARGETING, ENEMY_TURN
    let selectedUnit = null;

    // --- 初始化與關卡生成 ---

    function initGame() {
        createGrid();
        // 初始化主角群 (只執行一次)
        allies = [
            new Unit(1, '炭治郎', 'slayer', 'tanjiro', 1, 4, { hp: 100, atk: 25, def: 8, range: 1 }),
            new Unit(2, '善逸', 'slayer', 'zenitsu', 0, 3, { hp: 70, atk: 35, def: 5, range: 3 }), // 遠攻
            new Unit(3, '伊之助', 'slayer', 'inosuke', 0, 5, { hp: 110, atk: 22, def: 10, range: 1, isAoE: true }) // 範圍
        ];
        loadLevel(1);
    }

    function createGrid() {
        const container = document.getElementById('grid-container');
        container.innerHTML = '';
        gridElements = [];
        for (let y = 0; y < GRID_SIZE; y++) {
            let row = [];
            for (let x = 0; x < GRID_SIZE; x++) {
                let tile = document.createElement('div');
                tile.className = 'tile';
                tile.onclick = () => onTileClick(x, y);
                container.appendChild(tile);
                row.push(tile);
            }
            gridElements.push(row);
        }
    }

    function loadLevel(levelNum) {
        currentLevel = levelNum;
        document.getElementById('stage-indicator').innerText = `第 ${levelNum} 關 / 共 ${MAX_LEVEL} 關`;
        addLog(`<div class="log-stage">=== 第 ${levelNum} 關 開始 ===</div>`);

        // 重置我方位置
        allies[0].x = 1; allies[0].y = 4;
        allies[1].x = 0; allies[1].y = 3;
        allies[2].x = 0; allies[2].y = 5;
        
        // 生成敵人 (難度隨關卡提升)
        enemies = [];
        const difficultyMult = 1 + (levelNum * 0.15); // 每關強度增加 15%
        
        // 1. 生成雜魚 (3-5隻)
        const gruntCount = 3 + Math.floor(Math.random() * 3); 
        for(let i=0; i<gruntCount; i++) {
            let ex = 6 + Math.floor(Math.random() * 4); // 右側
            let ey = Math.floor(Math.random() * 10);
            // 避免重疊簡單處理
            if(enemies.some(u => u.x === ex && u.y === ey)) ey = (ey + 1) % 10;
            
            enemies.push(new Unit(100+i, `惡鬼`, 'demon', 'grunt', ex, ey, {
                hp: Math.floor(40 * difficultyMult),
                atk: Math.floor(12 * difficultyMult),
                def: Math.floor(2 * difficultyMult),
                level: levelNum
            }));
        }

        // 2. 生成 Boss (12鬼月)
        const bossName = getBossName(levelNum);
        enemies.push(new Unit(200, bossName, 'demon', 'boss', 9, 4, {
            hp: Math.floor(150 * difficultyMult),
            atk: Math.floor(25 * difficultyMult),
            def: Math.floor(8 * difficultyMult),
            level: levelNum + 2
        }));

        // 合併單位列表
        allUnits = [...allies, ...enemies];
        
        // 開始回合
        startTurnSequence();
    }

    function getBossName(lvl) {
        const names = ["下弦之陸", "下弦之伍", "下弦之壹", "上弦之陸·墮姬", "上弦之伍·玉壺", "上弦之肆·半天狗", "上弦之參·猗窩座", "上弦之貳·童磨", "上弦之壹·黑死牟"];
        return names[lvl-1] || "鬼舞辻無慘";
    }

    // --- 核心循環與渲染 ---

    function startTurnSequence() {
        // 清理死亡單位
        allUnits = allUnits.filter(u => u.hp > 0);
        allies = allUnits.filter(u => u.type === 'slayer');
        enemies = allUnits.filter(u => u.type === 'demon');

        // 勝利/失敗判定
        if (allies.length === 0) {
            alert("全滅... 鬼殺隊的意志斷絕了。");
            location.reload();
            return;
        }
        if (enemies.length === 0) {
            if (currentLevel < MAX_LEVEL) {
                alert(`第 ${currentLevel} 關完成！準備進入下一層無限城。`);
                loadLevel(currentLevel + 1);
            } else {
                alert("恭喜！你擊敗了所有惡鬼，迎來了黎明！");
            }
            return;
        }

        // 排序行動 (簡單輪流：所有我方 -> 所有敵方)
        // 為了簡化，我們用 index 追蹤
        if (turnIndex >= allUnits.length) turnIndex = 0;
        
        // 確保輪到的單位是活著的
        let safety = 0;
        while(allUnits[turnIndex].hp <= 0 && safety < 100) {
            turnIndex = (turnIndex + 1) % allUnits.length;
            safety++;
        }

        renderGrid();
        updateTurnUI();

        const current = allUnits[turnIndex];
        
        if (current.type === 'demon') {
            gameState = 'ENEMY_TURN';
            setTimeout(aiTurn, 600);
        } else {
            gameState = 'IDLE';
            // 自動選中當前角色
            onTileClick(current.x, current.y);
        }
    }

    function renderGrid() {
        // 清除格子樣式
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                let cell = gridElements[y][x];
                cell.innerHTML = '';
                cell.className = 'tile'; // reset
            }
        }

        // 繪製單位
        allUnits.forEach(u => {
            if (u.hp <= 0) return;
            let div = document.createElement('div');
            div.className = `unit ${u.role} ${u.type}`;
            if (u === allUnits[turnIndex]) div.classList.add('active');
            if (u.hasActed) div.classList.add('done');
            
            // 顯示名字簡寫
            div.innerText = u.name.substring(0, 1);

            // 血條
            let hpBg = document.createElement('div');
            hpBg.className = 'hp-bar-bg';
            let hpFill = document.createElement('div');
            hpFill.className = 'hp-bar-fill';
            hpFill.style.width = (u.hp / u.maxHp * 100) + '%';
            hpBg.appendChild(hpFill);
            div.appendChild(hpBg);

            // 等級標籤
            let lvl = document.createElement('div');
            lvl.className = 'lvl-badge';
            lvl.innerText = u.level;
            div.appendChild(lvl);

            gridElements[u.y][u.x].appendChild(div);
        });
    }

    // --- 玩家互動 ---

    function onTileClick(x, y) {
        if (gameState === 'ENEMY_TURN') return;

        const current = allUnits[turnIndex];
        const clickedUnit = allUnits.find(u => u.x === x && u.y === y && u.hp > 0);

        // 1. 移動階段
        if (gameState === 'MOVING') {
            if (gridElements[y][x].classList.contains('movable') && !clickedUnit) {
                moveUnit(current, x, y);
                gameState = 'IDLE';
                // 移動後重新選中自己以顯示菜單
                onTileClick(x, y);
            } else {
                // 取消移動
                gameState = 'IDLE';
                renderGrid();
                showActionMenu(false);
            }
            return;
        }

        // 2. 攻擊階段
        if (gameState === 'TARGETING') {
            if (gridElements[y][x].classList.contains('attackable')) {
                // 執行攻擊 (需判斷格子上有沒有人，伊之助可能是空地但有範圍傷害)
                if (clickedUnit || current.isAoE) {
                     executeAttack(current, x, y);
                }
            } else {
                gameState = 'IDLE';
                renderGrid();
                onTileClick(current.x, current.y); // 回到選單
            }
            return;
        }

        // 3. 閒置/選單階段
        if (current.type === 'slayer' && !current.hasActed) {
            // 如果點擊的是當前行動角色
            if (clickedUnit === current) {
                selectedUnit = current;
                showActionMenu(true);
                updateStatsPanel(current);
            } else if (clickedUnit) {
                // 僅查看別人
                updateStatsPanel(clickedUnit);
                showActionMenu(false);
            }
        }
    }

    // --- 行動邏輯 ---

    function showMoveRange() {
        if (allUnits[turnIndex].hasMoved) return;
        
        gameState = 'MOVING';
        const u = allUnits[turnIndex];
        const range = 2; // 固定移動 2 格

        renderGrid(); // 清除舊高亮
        
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const dist = Math.abs(x - u.x) + Math.abs(y - u.y);
                const occupied = allUnits.some(unit => unit.x === x && unit.y === y && unit.hp > 0 && unit !== u);
                if (dist <= range && !occupied) {
                    gridElements[y][x].classList.add('movable');
                }
            }
        }
    }

    function moveUnit(unit, x, y) {
        unit.x = x;
        unit.y = y;
        unit.hasMoved = true;
        renderGrid();
    }

    function startAttackMode(isSkill) {
        if (allUnits[turnIndex].hasActed) return;
        
        gameState = 'TARGETING';
        const u = allUnits[turnIndex];
        // 技能傷害倍率簡單處理: 技能 = 攻擊 * 1.5, 普攻 = 攻擊 * 1.0
        u.tempDmgMult = isSkill ? 1.5 : 1.0; 

        renderGrid();

        // 計算攻擊範圍
        for (let y = 0; y < GRID_SIZE; y++) {
            for (let x = 0; x < GRID_SIZE; x++) {
                const dist = Math.abs(x - u.x) + Math.abs(y - u.y);
                // 善逸 Range=3, 其他 Range=1
                if (dist <= u.range && dist > 0) {
                    // 如果有敵人，標記紅色
                    const target = allUnits.find(t => t.x === x && t.y === y && t.hp > 0);
                    if (target && target.type !== u.type) {
                        gridElements[y][x].classList.add('attackable');
                    }
                    // 伊之助的範圍攻擊允許點空地嗎？ 這裡簡化為必須點擊敵人
                }
            }
        }
        addLog(isSkill ? "選擇戰技目標..." : "選擇攻擊目標...");
    }

    function executeAttack(attacker, targetX, targetY) {
        const targets = [];
        const mainTarget = allUnits.find(u => u.x === targetX && u.y === targetY && u.hp > 0);

        if (mainTarget) targets.push(mainTarget);

        // 伊之助的範圍攻擊 (獸之呼吸)：同時攻擊目標周圍九宮格
        if (attacker.isAoE && mainTarget) {
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    if (dx === 0 && dy === 0) continue;
                    const subTarget = allUnits.find(u => u.x === mainTarget.x + dx && u.y === mainTarget.y + dy && u.hp > 0 && u.type !== attacker.type);
                    if (subTarget) targets.push(subTarget);
                }
            }
            addLog(`${attacker.name} 使用範圍獠牙斬！`);
        }

        if (targets.length === 0) return; // 無效攻擊

        targets.forEach(defender => {
            // 傷害公式
            let baseDmg = attacker.atk * (attacker.tempDmgMult || 1);
            let dmg = Math.floor(baseDmg - (defender.def * 0.5));
            // 浮動與最小傷害
            dmg = Math.max(1, Math.floor(dmg * (0.9 + Math.random() * 0.2)));
            
            // 暴擊 (善逸高機率)
            if (attacker.role === 'zenitsu' && Math.random() > 0.7) {
                dmg = Math.floor(dmg * 1.5);
                addLog(`⚡ 霹靂一閃！暴擊！`);
            }

            defender.hp -= dmg;
            addLog(`${attacker.name} 對 ${defender.name} 造成 <span class="log-dmg">${dmg}</span> 傷害`);

            if (defender.hp <= 0) {
                defender.hp = 0;
                addLog(`${defender.name} 被消滅了！`);
                // 獲得經驗值 (基礎值 + 等級差加成)
                let xpGain = 35 + (defender.level * 10);
                if (defender.role === 'boss') xpGain *= 3;
                attacker.gainXp(xpGain);
            }
        });

        endAction();
    }

    function endAction() {
        const u = allUnits[turnIndex];
        u.hasActed = true;
        u.hasMoved = true;
        u.tempDmgMult = 1;
        
        showActionMenu(false);
        gameState = 'IDLE';
        
        turnIndex = (turnIndex + 1) % allUnits.length;
        startTurnSequence();
    }

    // --- AI ---

    function aiTurn() {
        const demon = allUnits[turnIndex];
        
        // 尋找最近的我方
        let target = null;
        let minDist = 999;
        
        allies.forEach(a => {
            if (a.hp > 0) {
                const dist = Math.abs(a.x - demon.x) + Math.abs(a.y - demon.y);
                if (dist < minDist) {
                    minDist = dist;
                    target = a;
                }
            }
        });

        if (!target) { endAction(); return; }

        // 移動邏輯 (AI 移動力也是 2)
        if (minDist > 1) {
            // 簡單逼近算法
            let moves = 0;
            let bestX = demon.x, bestY = demon.y;
            
            // 嘗試走 2 步
            for(let i=0; i<2; i++) {
                let dx = target.x - bestX;
                let dy = target.y - bestY;
                
                let nextX = bestX, nextY = bestY;
                if (Math.abs(dx) > Math.abs(dy)) {
                    nextX += Math.sign(dx);
                } else {
                    nextY += Math.sign(dy);
                }

                // 檢查碰撞
                const blocked = allUnits.some(u => u.x === nextX && u.y === nextY && u.hp > 0);
                if (!blocked && (nextX !== target.x || nextY !== target.y)) {
                    bestX = nextX;
                    bestY = nextY;
                }
            }
            demon.x = bestX;
            demon.y = bestY;
            renderGrid();
        }

        // 攻擊邏輯
        const distAfterMove = Math.abs(target.x - demon.x) + Math.abs(target.y - demon.y);
        if (distAfterMove === 1) {
            setTimeout(() => {
                // Boss 有機率用強力攻擊
                demon.tempDmgMult = (demon.role === 'boss' && Math.random() > 0.6) ? 1.5 : 1.0;
                executeAttack(demon, target.x, target.y);
            }, 500);
        } else {
            setTimeout(endAction, 500);
        }
    }

    // --- UI 更新 ---

    function updateTurnUI() {
        const u = allUnits[turnIndex];
        const info = document.getElementById('turn-info');
        info.innerHTML = `<span style="color: ${u.type==='slayer'?'#00bfff':'#ff4d4d'}">${u.name} 的回合</span>`;
    }

    function updateStatsPanel(u) {
        const stats = document.getElementById('unit-stats');
        stats.innerHTML = `
            <strong>${u.name} (Lv.${u.level})</strong><br>
            HP: ${u.hp} / ${u.maxHp}<br>
            攻: ${u.atk} | 防: ${u.def}<br>
            EXP: ${u.xp} / ${u.maxXp}<br>
            特性: ${u.role === 'zenitsu' ? '遠程(3格)' : (u.role === 'inosuke' ? '範圍攻擊' : '近戰')}
        `;
    }

    function showActionMenu(show) {
        const menu = document.getElementById('action-menu');
        if (!show) {
            menu.style.display = 'none';
            return;
        }
        menu.style.display = 'flex';
        const u = allUnits[turnIndex];
        
        document.getElementById('btn-move').disabled = u.hasMoved;
        document.getElementById('btn-attack').disabled = u.hasActed;
        
        // 技能按鈕文字
        const skillBtn = document.getElementById('btn-skill');
        skillBtn.disabled = u.hasActed;
        if(u.role === 'tanjiro') skillBtn.innerText = "水之呼吸 (強擊)";
        if(u.role === 'zenitsu') skillBtn.innerText = "霹靂一閃 (遠程)";
        if(u.role === 'inosuke') skillBtn.innerText = "空間感知 (範圍)";
    }

    function addLog(msg) {
        const win = document.getElementById('log-window');
        win.innerHTML += `<div>${msg}</div>`;
        win.scrollTop = win.scrollHeight;
    }

    // --- 按鈕事件 ---
    document.getElementById('btn-move').onclick = showMoveRange;
    
    document.getElementById('btn-attack').onclick = () => startAttackMode(false);
    
    document.getElementById('btn-skill').onclick = () => startAttackMode(true); // 技能視為高傷害/特殊攻擊

    document.getElementById('btn-wait').onclick = () => {
        addLog(`${allUnits[turnIndex].name} 待機`);
        endAction();
    };

    // 啟動
    initGame();

</script>
</body>
</html>
